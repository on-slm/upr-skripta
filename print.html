<!DOCTYPE HTML>
<html lang="cs" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Úvod do programování</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        <style>
.xterm {
  margin-top: 10px;
}
.content {
  overflow-y: visible !important;
}
video {
    max-width: 100%;
}
</style>
<script src="https://kelvin.cs.vsb.cz/upr/animations.js"></script>


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="theme/css/tufte.css">
        
        <link rel="stylesheet" href="theme/asciinema-player.css">
        
        <link rel="stylesheet" href="src/wasm/xterm.min.css">
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "rust" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="uvod/uvod.html"><strong aria-hidden="true">1.</strong> Úvod</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="uvod/programovani.html"><strong aria-hidden="true">1.1.</strong> Programování</a></li><li class="chapter-item "><a href="uvod/programovaci_jazyky.html"><strong aria-hidden="true">1.2.</strong> Programovací jazyky</a></li><li class="chapter-item "><a href="uvod/jazyk_c.html"><strong aria-hidden="true">1.3.</strong> Jazyk C</a></li><li class="chapter-item "><a href="uvod/pamet.html"><strong aria-hidden="true">1.4.</strong> Paměť</a></li></ol></li><li class="chapter-item "><a href="prostredi/nastaveni_prostredi.html"><strong aria-hidden="true">2.</strong> Nastavení prostředí</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="prostredi/linux.html"><strong aria-hidden="true">2.1.</strong> Linux</a></li><li class="chapter-item "><a href="prostredi/editor.html"><strong aria-hidden="true">2.2.</strong> Editor</a></li><li class="chapter-item "><a href="prostredi/preklad_programu.html"><strong aria-hidden="true">2.3.</strong> Překlad</a></li><li class="chapter-item "><a href="prostredi/ladeni.html"><strong aria-hidden="true">2.4.</strong> Ladění</a></li></ol></li><li class="chapter-item "><a href="c/programovani.html"><strong aria-hidden="true">3.</strong> Programování v C</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/syntaxe.html"><strong aria-hidden="true">3.1.</strong> Syntaxe</a></li><li class="chapter-item "><a href="c/prikazy_vyrazy.html"><strong aria-hidden="true">3.2.</strong> Příkazy a výrazy</a></li><li class="chapter-item "><a href="c/promenne/promenne.html"><strong aria-hidden="true">3.3.</strong> Proměnné</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/promenne/globalni_promenne.html"><strong aria-hidden="true">3.3.1.</strong> Globální proměnné</a></li><li class="chapter-item "><a href="c/promenne/konstanty.html"><strong aria-hidden="true">3.3.2.</strong> Konstanty</a></li><li class="chapter-item "><a href="c/promenne/slozeny_zapis.html"><strong aria-hidden="true">3.3.3.</strong> Složený zápis</a></li><li class="chapter-item "><a href="c/promenne/pojmenovavani.html"><strong aria-hidden="true">3.3.4.</strong> Pojmenovávání proměnných</a></li></ol></li><li class="chapter-item "><a href="c/datove_typy/datove_typy.html"><strong aria-hidden="true">3.4.</strong> Datové typy</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/datove_typy/celociselne_typy.html"><strong aria-hidden="true">3.4.1.</strong> Celočíselné typy</a></li><li class="chapter-item "><a href="c/datove_typy/desetinne_typy.html"><strong aria-hidden="true">3.4.2.</strong> Desetinné číselné typy</a></li><li class="chapter-item "><a href="c/datove_typy/pravdivostni_typy.html"><strong aria-hidden="true">3.4.3.</strong> Pravdivostní typy</a></li><li class="chapter-item "><a href="c/datove_typy/konverze.html"><strong aria-hidden="true">3.4.4.</strong> Konverze</a></li></ol></li><li class="chapter-item "><a href="c/rizeni_toku/rizeni_toku.html"><strong aria-hidden="true">3.5.</strong> Řízení toku</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/rizeni_toku/podminky.html"><strong aria-hidden="true">3.5.1.</strong> Podmínky</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/rizeni_toku/if.html"><strong aria-hidden="true">3.5.1.1.</strong> Příkaz if</a></li><li class="chapter-item "><a href="c/rizeni_toku/switch.html"><strong aria-hidden="true">3.5.1.2.</strong> Příkaz switch</a></li><li class="chapter-item "><a href="c/rizeni_toku/ternarni_operator.html"><strong aria-hidden="true">3.5.1.3.</strong> Ternární operátor</a></li></ol></li><li class="chapter-item "><a href="c/rizeni_toku/cykly.html"><strong aria-hidden="true">3.5.2.</strong> Cykly</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/rizeni_toku/while.html"><strong aria-hidden="true">3.5.2.1.</strong> Cyklus while</a></li><li class="chapter-item "><a href="c/rizeni_toku/for.html"><strong aria-hidden="true">3.5.2.2.</strong> Cyklus for</a></li></ol></li></ol></li><li class="chapter-item "><a href="c/funkce/funkce.html"><strong aria-hidden="true">3.6.</strong> Funkce</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/funkce/rekurze.html"><strong aria-hidden="true">3.6.1.</strong> Rekurze</a></li><li class="chapter-item "><a href="c/funkce/stdlib.html"><strong aria-hidden="true">3.6.2.</strong> Funkce standardní knihovny</a></li></ol></li><li class="chapter-item "><a href="c/preprocesor/preprocesor.html"><strong aria-hidden="true">3.7.</strong> Preprocesor</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/preprocesor/vkladani_souboru.html"><strong aria-hidden="true">3.7.1.</strong> Vkládání souborů</a></li><li class="chapter-item "><a href="c/preprocesor/makra.html"><strong aria-hidden="true">3.7.2.</strong> Makra</a></li></ol></li><li class="chapter-item "><a href="c/prace_s_pameti/prace_s_pameti.html"><strong aria-hidden="true">3.8.</strong> Práce s pamětí</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/prace_s_pameti/automaticka_pamet.html"><strong aria-hidden="true">3.8.1.</strong> Automatická paměť</a></li><li class="chapter-item "><a href="c/prace_s_pameti/ukazatele.html"><strong aria-hidden="true">3.8.2.</strong> Ukazatele</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/prace_s_pameti/ukazatele_na_funkce.html"><strong aria-hidden="true">3.8.2.1.</strong> Ukazatele na funkce</a></li></ol></li><li class="chapter-item "><a href="c/prace_s_pameti/dynamicka_pamet.html"><strong aria-hidden="true">3.8.3.</strong> Dynamická paměť</a></li><li class="chapter-item "><a href="c/prace_s_pameti/globalni_pamet.html"><strong aria-hidden="true">3.8.4.</strong> Globální paměť</a></li></ol></li><li class="chapter-item "><a href="c/pole/pole.html"><strong aria-hidden="true">3.9.</strong> Pole</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/pole/staticke_pole.html"><strong aria-hidden="true">3.9.1.</strong> Statické pole</a></li><li class="chapter-item "><a href="c/pole/dynamicke_pole.html"><strong aria-hidden="true">3.9.2.</strong> Dynamické pole</a></li><li class="chapter-item "><a href="c/pole/vicerozmerne_pole.html"><strong aria-hidden="true">3.9.3.</strong> Vícerozměrné pole</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/pole/zubata_pole.html"><strong aria-hidden="true">3.9.3.1.</strong> Zubatá pole</a></li></ol></li></ol></li><li class="chapter-item "><a href="c/text/text.html"><strong aria-hidden="true">3.10.</strong> Text</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/text/znaky.html"><strong aria-hidden="true">3.10.1.</strong> Znaky</a></li><li class="chapter-item "><a href="c/text/retezce.html"><strong aria-hidden="true">3.10.2.</strong> Řetězce</a></li><li class="chapter-item "><a href="c/text/vstupavystup.html"><strong aria-hidden="true">3.10.3.</strong> Vstup a výstup</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/text/vstup.html"><strong aria-hidden="true">3.10.3.1.</strong> Vstup</a></li><li class="chapter-item "><a href="c/text/vystup.html"><strong aria-hidden="true">3.10.3.2.</strong> Výstup</a></li></ol></li></ol></li><li class="chapter-item "><a href="c/struktury/vlastni_datove_typy.html"><strong aria-hidden="true">3.11.</strong> Vlastní datové typy</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/struktury/struktury.html"><strong aria-hidden="true">3.11.1.</strong> Struktury</a></li><li class="chapter-item "><a href="c/struktury/struktury_funkce.html"><strong aria-hidden="true">3.11.2.</strong> Struktury a funkce</a></li></ol></li><li class="chapter-item "><a href="c/soubory/soubory.html"><strong aria-hidden="true">3.12.</strong> Soubory</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/soubory/otevirani_souboru.html"><strong aria-hidden="true">3.12.1.</strong> Otevření souborů</a></li><li class="chapter-item "><a href="c/soubory/prace_se_soubory.html"><strong aria-hidden="true">3.12.2.</strong> Práce se soubory</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/soubory/zapis_do_souboru.html"><strong aria-hidden="true">3.12.2.1.</strong> Zápis do souboru</a></li><li class="chapter-item "><a href="c/soubory/cteni_ze_souboru.html"><strong aria-hidden="true">3.12.2.2.</strong> Čtení ze souboru</a></li></ol></li></ol></li><li class="chapter-item "><a href="c/modularizace/modularizace.html"><strong aria-hidden="true">3.13.</strong> Modularizace</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/modularizace/linker.html"><strong aria-hidden="true">3.13.1.</strong> Linker</a></li><li class="chapter-item "><a href="c/modularizace/pouzivani_kodu_z_jinych_souboru.html"><strong aria-hidden="true">3.13.2.</strong> Používání kódu z jiných souborů</a></li><li class="chapter-item "><a href="c/modularizace/hlavickove_soubory.html"><strong aria-hidden="true">3.13.3.</strong> Hlavičkové soubory</a></li><li class="chapter-item "><a href="c/modularizace/knihovny.html"><strong aria-hidden="true">3.13.4.</strong> Knihovny</a></li></ol></li><li class="chapter-item "><a href="c/automatizace_prekladu.html"><strong aria-hidden="true">3.14.</strong> Automatizace překladu</a></li><li class="chapter-item "><a href="c/aplikovane_ulohy/ulohy.html"><strong aria-hidden="true">3.15.</strong> Aplikované úlohy</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/aplikovane_ulohy/tga.html"><strong aria-hidden="true">3.15.1.</strong> TGA</a></li><li class="chapter-item "><a href="c/aplikovane_ulohy/gif.html"><strong aria-hidden="true">3.15.2.</strong> GIF</a></li><li class="chapter-item "><a href="c/aplikovane_ulohy/sdl.html"><strong aria-hidden="true">3.15.3.</strong> SDL</a></li><li class="chapter-item "><a href="c/aplikovane_ulohy/chipmunk.html"><strong aria-hidden="true">3.15.4.</strong> Chipmunk</a></li></ol></li><li class="chapter-item "><a href="c/co_dal.html"><strong aria-hidden="true">3.16.</strong> Co dál?</a></li></ol></li><li class="chapter-item "><a href="ruzne/ruzne.html"><strong aria-hidden="true">4.</strong> Různé</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ruzne/rozklad_problemu.html"><strong aria-hidden="true">4.1.</strong> Rozklad problému</a></li><li class="chapter-item "><a href="ruzne/vyhodnocovani_vyrazu.html"><strong aria-hidden="true">4.2.</strong> Vyhodnocování výrazů</a></li><li class="chapter-item "><a href="ruzne/funkce_main.html"><strong aria-hidden="true">4.3.</strong> Funkce main</a></li><li class="chapter-item "><a href="ruzne/nahodna_cisla.html"><strong aria-hidden="true">4.4.</strong> Generování náhodných čísel</a></li><li class="chapter-item "><a href="ruzne/parametry_prekladace.html"><strong aria-hidden="true">4.5.</strong> Parametry překladače</a></li></ol></li><li class="chapter-item "><a href="ulohy/ulohy.html"><strong aria-hidden="true">5.</strong> Úlohy</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ulohy/zaklady.html"><strong aria-hidden="true">5.1.</strong> Základy</a></li><li class="chapter-item "><a href="ulohy/ukazatele.html"><strong aria-hidden="true">5.2.</strong> Ukazatele</a></li><li class="chapter-item "><a href="ulohy/pole.html"><strong aria-hidden="true">5.3.</strong> Pole</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ulohy/pvp.html"><strong aria-hidden="true">5.3.1.</strong> PvP bitevní hra</a></li></ol></li><li class="chapter-item "><a href="ulohy/dvourozmerne_pole.html"><strong aria-hidden="true">5.4.</strong> Dvourozměrné pole</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ulohy/digitalni_hodiny.html"><strong aria-hidden="true">5.4.1.</strong> Digitální hodiny</a></li></ol></li><li class="chapter-item "><a href="ulohy/retezce.html"><strong aria-hidden="true">5.5.</strong> Řetězce</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ulohy/chat_cleaner.html"><strong aria-hidden="true">5.5.1.</strong> Chat cleaner</a></li></ol></li><li class="chapter-item "><a href="ulohy/struktury.html"><strong aria-hidden="true">5.6.</strong> Struktury</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ulohy/tga_watch.html"><strong aria-hidden="true">5.6.1.</strong> TGA hodiny</a></li><li class="chapter-item "><a href="ulohy/letters.html"><strong aria-hidden="true">5.6.2.</strong> Létající písmenka</a></li></ol></li><li class="chapter-item "><a href="ulohy/soubory.html"><strong aria-hidden="true">5.7.</strong> Soubory</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ulohy/terce.html"><strong aria-hidden="true">5.7.1.</strong> Střelba na terče</a></li><li class="chapter-item "><a href="ulohy/meme.html"><strong aria-hidden="true">5.7.2.</strong> Meme generarátor</a></li></ol></li><li class="chapter-item "><a href="ulohy/sdl.html"><strong aria-hidden="true">5.8.</strong> SDL hry</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ulohy/snake/snake.html"><strong aria-hidden="true">5.8.1.</strong> Had</a></li></ol></li><li class="chapter-item "><a href="ulohy/ruzne.html"><strong aria-hidden="true">5.9.</strong> Různé</a></li></ol></li><li class="chapter-item "><a href="caste_chyby/caste_chyby.html"><strong aria-hidden="true">6.</strong> Časté chyby</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="caste_chyby/pametove_chyby.html"><strong aria-hidden="true">6.1.</strong> Paměťové chyby</a></li></ol></li><li class="chapter-item "><a href="galerie_projektu/galerie_projektu.html"><strong aria-hidden="true">7.</strong> Galerie projektů</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="galerie_projektu/2020.html"><strong aria-hidden="true">7.1.</strong> 2020/2021</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Úvod do programování</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/mrlvsb/upr-skripta" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#Úvod" id="Úvod">Úvod</a></h1>
<p>Tento text vznikl pro potřeby výuky předmětu <a href="https://github.com/geordi/upr-course">Úvod do programování</a> na FEI VŠB-TUO.
Slouží k získání přehledu o základních konceptech programovacího jazyka C.
Není však plnohodnotnou náhradou za poslechy přednášek a návštěvy cvičení a programovat vás (stejně
jako žádný jiný text) nenaučí, toho lze dosáhnout pouze opakovaným zkoušením a řešením různých úloh.
Studentům tedy silně doporučujeme, aby přednášky a cvičení navštěvovali a hlavně aby se věnovali programování
doma, alespoň hodinu denně.</p>
<p>V tomto textu naleznete stručný úvod o programování, překladu a ladění programů, nastavení prostředí
k editaci zdrojového kódu, a zejména popis základních konstrukcí jazyka <em>C</em> (proměnné, podmínky,
cykly, funkce, ukazatele, pole, řetězce, struktury atd.) spolu se sadou úloh k procvičení jednotlivých
témat. Pomocí ikony <i class="fa fa-search"></i> vlevo nahoře můžete v textu rychle vyhledávat, pokud
potřebujete najít informace o konkrétním tématu.</p>
<p>Několik poznámek k textu:</p>
<ul>
<li>Tento text neslouží jako kompletní průvodce jazyka C. Pro takovýto účel lze doporučit některý
knižní titul, např. Učebnice jazyka <em>C</em> od Pavla Herouta nebo přímo standard jazyka <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf">C99</a>.</li>
<li>Jelikož je předmět UPR zaměřen na vývoj v operačním systému Linux, tak ukázky kódu a příkazů v terminálu
předpokládají použití tohoto operačního systému (konkrétně distribuce <code>Ubuntu</code>).</li>
<li>Tento text je psán česky, nicméně primárním jazykem programování (celosvětově) je angličtina. Přeložené pojmy,
které mají zavedené anglické názvy, budou v tomto textu uvedeny v závorce <em>kurzívou</em>.</li>
<li>V tomto textu naleznete různé ukázky <em>C</em> kódu. Některé z nich můžete sami upravovat a dokonce
i spustit rovnou v prohlížeči pomocí ikony <i class="fa fa-play"></i> v pravém horním rohu kódu.
Ukázky budou pro zjednodušení používat názvy v češtině, nicméně jakmile už nebudete v
programování úplní nováčci, silně vám doporučujeme psát zdrojové kódy v angličtině.</li>
<li>Pokud v textu naleznete gramatickou či faktickou chybu nebo budete mít jakoukoliv zpětnou vazbu
k obsahu či formě textu, dejte nám prosím vědět na <a href="mailto:jakub.beranek@vsb.cz?subject=UPR%20skripta%20-%20chyba">tento e-mail</a>
nebo vytvořte issue na <a href="https://github.com/mrlvsb/upr-skripta/issues/new">GitHubu</a>.</li>
</ul>
<p>Autory textu jsou <a href="https://github.com/geordi">Jan Gaura</a>, <a href="https://github.com/trnila">Dan Trnka</a> a
<a href="https://github.com/kobzol">Kuba Beránek</a>.</p>
<p><em>Historii změn</em> tohoto studijního textu můžete naleznout v jeho
<a href="https://github.com/mrlvsb/upr-skripta/commits/master">GitHub repozitáři</a>.</p>
<h1><a class="header" href="#programování" id="programování">Programování</a></h1>
<p>Programování je proces tvorby programu, tj. sady příkazů pro počítač, který slouží k vyřešení
nějakého konkrétního <strong>problému</strong>. Problémem se zde myslí nějaká úloha, kterou chceme vyřešit.
Takovéto úlohy obsahují nějaký (počítačem zpracovatelný) vstup, například:</p>
<ul>
<li>pohyb myši</li>
<li>stisk klávesy</li>
<li>zvuk z mikrofonu</li>
<li>textový soubor na disku</li>
</ul>
<p>a k nim určený výstup, například:</p>
<ul>
<li>vykreslení obrazce či textu na monitoru</li>
<li>zapsání dat do souboru na disku</li>
<li>odeslání informací přes síť</li>
</ul>
<p>Aby počítačový program korektně řešil nějakou úlohu, tak musí na všechny validní vstupy vrátit
správný výstup. Pokud vstup neodpovídá zadání, tak by měl program vrátit rozumnou chybovou hlášku.
Postup pro řešení nějaké úlohy daný jasně definovanými kroky se nazývá <strong>algoritmus</strong>. Zápisu
(algoritmu) v nějakém konkrétním programovacím jazyce se pak říká <strong>implementace</strong> (algoritmu).</p>
<p>Zde je příklad úloh, které se během semestru naučíte řešit pomocí jazyka <em>C</em>:</p>
<ul>
<li>Spočítej průměr seznamu čísel</li>
<li>Načti údaje o uživateli ze souboru a vypiš je v podobě tabulky</li>
<li>Načti obrázek z disku, změň jeho velikost a ulož ho do jiného souboru</li>
<li>Vytvoř animaci ze sady obrázků na disku</li>
</ul>
<p>Řešením podobných úloh si osvojíte základy programování a budete poté moct řešit zajímavější úlohy,
jako je například tvorba počítačové hry nebo aplikace komunikující přes internet.</p>
<h1><a class="header" href="#programovací-jazyky" id="programovací-jazyky">Programovací jazyky</a></h1>
<p>Z pohledu počítače je program sekvence příkazů (nazývaných <strong>instrukce</strong>), které může počítač
vykonat k vyřešení nějakého problému. Abychom mohli počítači říct, co má vykonávat, potřebujeme mu
příkazy zadat ve formě, které bude rozumět. Ač se to možná nezdá, tak počítače umí vykonávat pouze
velmi jednoduché příkazy. V podstatě umí pouze provádět aritmetické a logické operace (sčítání,
odčítání, násobení) s čísly a manipulovat (číst, zapisovat, přesouvat) s těmito čísly v paměti.</p>
<p>Veškeré složitější úkoly, jako třeba vykreslení obrázku na obrazovku, zapsání textu do dokumentu
nebo simulace světa v počítačové hře je výsledkem kombinací tisíců či milionů takovýchto
jednoduchých instrukcí.</p>
<p>Zde je ukázka jednoduchého programu, který zdvojnásobí číslo <code>8</code> pomocí příkazů <code>MOV</code> a <code>ADD</code>:</p>
<pre><code class="language-x86asm">MOV EAX, 8
ADD EAX, EAX
</code></pre>
<p>Pokud bychom programy psali pouze pomocí těchto jednoduchých příkazů<sup class='margin-toggle sidenote-number'>1</sup>, tak by bylo složité se v
nich vyznat, obzvláště, pokud by obsahovaly stovky, tisíce nebo dokonce miliony takovýchto příkazů.
Ideálně bychom chtěli programy zapisovat v přirozeném jazyce (<code>Vykresli čtverec na obrazovku</code>,
<code>Zapiš text do dokumentu</code>), nicméně tomu počítače nerozumí a je velmi náročné jej převést na
správnou sekvenci příkazů pro počítač, protože jazyky, které používáme, jsou často nejednoznačné a
nemají jednotnou strukturu.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Vyzkoušíte si to v navazujícím předmětu <a href="https://poli.cs.vsb.cz/edu/apps/">Architektury počítačů a paralelních systémů</a>.</p>
</span>
<p>Jako kompromis tak vznikly <strong>programovací jazyky</strong>, které umožňují zápis programů ve formě, která
je lidem srozumitelná, ale zároveň ji lze relativně jednoduše převést na příkazy, které je schopen
počítač provést. Převodu programu zapsaného v programovacím jazyce na počítačové instrukce se
říká <strong>překlad</strong>
(<em>compilation</em>) a programy, které tento překlad provádějí, se nazývají <strong>překladače</strong> (<em>compilers</em>)
. Později si ukážeme, jak takovýto překladač použít k překladu kódu.</p>
<p>Zde je ukázka části programu v jazyce <em>C</em>:</p>
<pre><code class="language-c">while (je_tlacitko_zmacknuto(MEZERNIK)) {
    posun_nahoru(postava);
}
</code></pre>
<p>I někdo, kdo se s jazykem <em>C</em> nikdy nesetkal, může z tohoto kusu kódu zhruba odvodit, co asi dělá,
pokud ho přečte jako větu. Tento program však může být převeden na stovky až tisíce počítačových
instrukcí a z takového množství příkazů už by bylo složité odvodit, k čemu je program určen.</p>
<h1><a class="header" href="#jazyk-c" id="jazyk-c">Jazyk <em>C</em></a></h1>
<p>Existuje nespočet programovacích jazyků, například Python, Java, C#, PHP, Rust či Javascript. Každý
z nich má své výhody a nevýhody a záleží na konkrétním problému, který je třeba vyřešit, pro
zvolení vhodného programovacího jazyka.</p>
<p>V tomto kurzu se budeme zabývat pouze programovacím jazykem <strong>C</strong>. Tento jazyk vytvořili Dennis
Ritchie a Ken Thompson v laboratořích firmy Bell v roce 1972, tedy již před téměř 50 lety, a za tu
dobu se nedočkal mnoha výrazných změn.</p>
<p>I když pro něj v dnešní době asi nenaleznete obrovské množství pracovních nabídek a není primární
volbou pro tvorbu webových či mobilních aplikací, vyplatí se mu rozumět a umět ho používat, a to
hned z několika důvodů:</p>
<ul>
<li>Jazyk <em>C</em> lze použít na téměř všech existujících platformách a je tak velmi univerzálním jazykem.
Téměř veškerý existující software obsahuje kusy kódu v jazyce <em>C</em>. Operační systémy (Linux,
OS X, Windows, Android, iOS), prohlížeče (Chrome, Firefox, Edge), multimediální programy
(Photoshop, Powerpoint, Word, BitTorrent), hry (World of Warcraft, Quake, Doom, Call of Duty,
League of Legends, DOTA 2, Fortnite), vestavěná zařízení (mikročipy, pračky, řídící jednotky
vesmírných letadel nebo aut). Všechny tyto věci jsou buď částečně anebo zcela poháněny jazykem
<em>C</em>.</li>
<li>Je to jednoduchý jazyk, který neobsahuje velké množství funkcí, které lze naleznout ve většině
modernějších jazyků. Díky tomu se dá naučit za jeden semestr.</li>
<li>Jeho úroveň abstrakce není o mnoho výše než základní počítačové instrukce. Při výuce <em>C</em> tak lze
zároveň pochopit, jak funguje počítač a operační systém. Díky tomu lze také při správném
zacházení psát velmi efektivní programy (to ale nicméně není obsahem tohoto kurzu).</li>
<li><strong>Syntaxe</strong> (způsob zápisu) jazyka <em>C</em> ovlivnila velké množství jazyků, které vznikly po něm.
Jakmile se ji naučíte, tak budete schopni rozumět syntaxi většiny současných nejpoužívanějších
jazyků (C++, C#, Java, Kotlin, Javascript, PHP, Rust, …).</li>
</ul>
<p>Jazyk <em>C</em> má samozřejmě také řadu nevýhod. Vzhledem k jeho stáří a omezené sadě funkcionalit je
často značně pracnější a zdlouhavější pomocí něj dosáhnout stejného výsledku než u modernějších
programovacích jazyků. Nevede také programátory za ručičku – při psaní programu v jazyce <em>C</em> je
velmi jednoduché udělat chybu, která může způsobit (v lepším případě) pád programu nebo
(v horším případě) může běžící program poškodit tak, že začne vydávat chybný výstup nebo se začne
chovat zcela nepředvídatelně.</p>
<p>Tyto chyby se můžou projevit jen někdy, nebo jenom na určité kombinaci hardwaru či operačního
systému, a programátor na ně není často nijak upozorněn a musí je najít ručně zkoumáním zdrojového
kódu. Podobný typ chyb je také nejčastějším zdrojem bezpečnostních děr ve všech možných softwarech,
které (jak už víme) téměř vždy obsahují alespoň část kódu napsaného v &quot;Céčku&quot;.</p>
<p>Zde je vybraný seznam populárních programů napsaných v jazyce <em>C</em>, které jsou tzv. <strong>open-source</strong><sup class='margin-toggle sidenote-number'>2</sup>,
takže si jejich zdrojový kód můžete prohlédnout a v případě potřeby i modifikovat:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Jejich zdrojový kód je volně sdílen.</p>
</span>
<ul>
<li><a href="https://github.com/torvalds/linux">Linux</a> (operační systém)</li>
<li><a href="https://github.com/id-Software/Quake-III-Arena">Quake III</a> (počítačová hra)</li>
<li><a href="https://github.com/git/git">git</a> (verzovací systém)</li>
<li><a href="https://github.com/php/php-src">PHP</a> (překladač/interpret jazyka PHP)</li>
<li><a href="https://github.com/obsproject/obs-studio">OBS Studio</a> (streamovací software)</li>
</ul>
<h1><a class="header" href="#paměť" id="paměť">Paměť</a></h1>
<p>Počítače si potřebují ukládat výsledky výpočtů do paměti, aby je později mohly opět načíst a
pracovat s nimi. Je mnoho typů paměti, s kterými lze pracovat, nejběžněji se setkáme s tzv.
operační pamětí (<strong>RAM</strong>). RAM znamená Random-Access Memory, tedy paměť s náhodným přístupem. To
znamená, že počítač může do paměti šahat v libovolném pořadí a na libovolném místě, kde je to
potřeba.</p>
<h3><a class="header" href="#reprezentace-hodnot-v-paměti" id="reprezentace-hodnot-v-paměti">Reprezentace hodnot v paměti</a></h3>
<p>Počítačová paměť uchovává informace v buňkách, které obsahují jedno číslo, které může obsahovat 256
různých hodnot. To vychází z toho, že informace je reprezentována <strong>bity</strong>, jednotkou informací,
která může nabývat pouze dvě hodnoty - pravda (<em>true</em>) nebo nepravda (<em>false</em>). Každá buňka paměti
obsahuje jeden <strong>byte</strong>, neboli právě 8 bitů.</p>
<p>Pracuje se zde s dvojkovou (binární) soustavou, pokud tedy máme k dispozici <em>n</em> bitů, tak pomocí
nich můžeme reprezentovat \( 2^n \) hodnot. Např. s dvěma bity můžeme reprezentovat 4 různé
hodnoty
(00, 01, 10, 11). Více o binární soustavě a bytech se dozvíte v předmětu
<a href="https://edison.sso.vsb.cz/cz.vsb.edison.edu.study.prepare.web/SubjectVersion.faces?version=440-2104/01&amp;subjectBlockAssignmentId=375761&amp;studyFormId=2&amp;studyPlanId=22001&amp;locale=cs&amp;back=true">Základy digitálních systémů (ZDS)</a>.</p>
<p>I když paměť vždy obsahuje hodnoty (čísla) v dvojkové soustavě, je důležité si uvědomit, že význam
těmto hodnotám přiřazujeme my, tedy programátoři a uživatelé počítače. Pokud je v paměti hodnota <strong>65</strong>,
tak může reprezentovat například:</p>
<ul>
<li>počet získaných bodů studenta (interpretujeme ji jako číslo)</li>
<li>písmeno <code>A</code> v nějakém dokumentu (interpretujeme ji jako znak v
kódování <a href="https://www.asciitable.com/">ASCII</a>)</li>
<li>tmavě šedý pixel (interpretujeme ji jako barvu)</li>
</ul>
<p>I v případě, že hodnoty v paměti interpretujeme přímo jako čísla, tak reprezentované číslo nemusí
přímo odpovídat číselné hodnotě v paměti. Například hodnotu <strong>255</strong> uloženou v <em>bytu</em> paměti můžeme
vnímat jako celé nezáporné číslo (<em>unsigned integer</em>) <strong>255</strong>, anebo také jako celé číslo se
znaménkem (<em>signed integer</em>) <strong>-1</strong>
v <a href="https://cs.wikipedia.org/wiki/Dvojkov%C3%BD_dopln%C4%9Bk">dvojkovém doplňku</a>.<sup class='margin-toggle sidenote-number'>1</sup></p>
<span class='sidenote'><p><sup class='number'>1</sup>Můžeme si klidně ale vymyslet reprezentaci, kde hodnota <code>255</code> v paměti bude reprezentovat
číslo <code>42</code>. Nebo třeba emoji 😈. Záleží jen na nás.</p>
</span>
<p>Čísla v paměti sama o sobě nemají žádný význam, záleží pouze na tom, jak je my, a obzvláště naše
programy, interpretují a jaké operace nad nimi provádějí.</p>
<h3><a class="header" href="#adresování-paměti" id="adresování-paměti">Adresování paměti</a></h3>
<p>Abychom se mohli odkazovat na hodnoty v paměti, tak musíme mít možnost rozlišit jednotlivé buňky od
sebe. Toho dosáhneme pomocí <strong>adresy</strong>. Paměť je adresována tak, že každá paměťová buňka (každý <em>byte</em>)
má číselnou adresu od 0 do velikosti paměti (nevčetně). Velmi zjednodušeně řečeno, pokud máte RAM
paměť o velikosti 8 GiB (8 589 934 592 &quot;bajtů&quot;), tak můžete adresovat buňky od 0 do 8589934591<sup class='margin-toggle sidenote-number'>2</sup>.</p>
<span class='sidenote'><p><sup class='number'>2</sup>Programy běžně nemají přístup k celé paměti počítače (mimo jiné z bezpečnostních důvodů). Váš
operační systém používá tzv. <strong>virtuální paměť</strong>, která každému běžícímu programu přiděluje určité
rozsahy paměti, s kterými může pracovat. Více se dozvíte v předmětu
<a href="http://poli.cs.vsb.cz/edu/osy/">Operační systémy</a>.</p>
</span>
<p>Pokud byste programovali počítač přímo pomocí instrukcí, tak mu můžete dát například instrukci
<code>Nastav byte na adrese 58 na hodnotu 5</code> nebo <code>Přečti 4 byty začínající na adrese 1028</code>. Při
programování v <em>C</em> ovšem často budou adresy skryté na pozadí a bude se o ně starat překladač, my se
budeme na konkrétní úsek paměti obvykle odkazovat jménem, které mu přiřadíme.</p>
<h1><a class="header" href="#nastavení-prostředí" id="nastavení-prostředí">Nastavení prostředí</a></h1>
<p>Abyste mohli efektivně programovat v <em>C</em>, musíte si nainstalovat, nakonfigurovat a naučit se používat
sadu programů. V této kapitole naleznete stručný popis toho, jak si nastavit
<a href="prostredi/linux.html">operační systém Linux</a>, <a href="prostredi/editor.html">textový editor</a>
k psaní programů, <a href="prostredi/preklad_programu.html">překladač</a> pro překlad z jazyka <em>C</em> do spustitelného souboru
a také jak <a href="prostredi/ladeni.html">řešit chyby</a> při psaní programů.</p>
<h1><a class="header" href="#linux" id="linux">Linux</a></h1>
<p>Jak už bylo zmíněno v <a href="prostredi/../uvod/uvod.html">úvodu</a>, v UPR budeme psát a spouštět programy v operačním
systém <a href="https://en.wikipedia.org/wiki/Linux">Linux</a>. Je tak nutné, abyste si na svém počítači
tento operační systém zprovoznili.</p>
<p>Pokud používáte operační systém OS X, tak teoreticky Linux instalovat nemusíte, stačí si nastavit
překladač <a href="https://www.cyberciti.biz/faq/howto-apple-mac-os-x-install-gcc-compiler/"><code>gcc</code></a>.</p>
<p><strong>Pokud při instalaci Linuxu narazíte na problémy, které se vám nepodaří vyřešit, konzultujte je
ihned s vaším cvičícím, který vám s instalací pomůže. Je nezbytné mít zprovozněný překladač <code>gcc</code>
a Linux (nebo OS X), abyste mohli řešit úlohy do UPR.</strong></p>
<p>Pokud používáte operační systém Windows, tak pro použití Linuxu můžete využít jeden z následujících
tří možností.</p>
<blockquote>
<p>Návod pro práci s terminálem na Linuxu můžete najít např. <a href="https://wiki.ubuntu.cz/syst%C3%A9m/p%C5%99%C3%ADkazov%C3%A1_%C5%99%C3%A1dka/termin%C3%A1l">zde</a>.
Tahák pro příkazy terminálu najdete <a href="https://github.com/geordi/upr-course/blob/master/assets/cheatsheets/linux.pdf">zde</a>.</p>
</blockquote>
<h2><a class="header" href="#windows-subsystem-for-linux-doporučeno" id="windows-subsystem-for-linux-doporučeno">Windows Subsystem for Linux (doporučeno)</a></h2>
<p>WSL je systém, který umožňuje nainstalovat Linux pod operačním systémem Windows. Jakmile jej
nainstalujete, budete mít k dispozici Linuxový terminál (<code>bash</code>) a budete moct používat překladač
<a href="prostredi/preklad_programu.html">gcc</a> a editor <a href="prostredi/editor.html">Visual Studio Code</a>. Výhoda tohoto řešení je, že
pro použití Linuxu nemusíte restartovat počítač ani zapínat virtuální stroj, Linux je v podstatě
jenom &quot;další aplikace&quot; pod Windows.</p>
<p>Návod pro zprovoznění WSL spolu s prostředím pro vývoj v jazyce <em>C</em> naleznete
<a href="https://code.visualstudio.com/docs/cpp/config-wsl">zde</a>. Při instalaci WSL používejte distribuci
<code>Ubuntu 20.04</code>.</p>
<h2><a class="header" href="#virtualizovaný-linux" id="virtualizovaný-linux">Virtualizovaný Linux</a></h2>
<p>Linux můžete také používat ve virtualizované podobě pomocí
<a href="https://cs.wikipedia.org/wiki/Virtu%C3%A1ln%C3%AD_stroj">virtuálního stroje</a>. Připravili jsme pro
vás tzv. obraz virtuálního stroje, který obsahuje již nastavený Linux, konkrétně <code>Ubuntu 20.04</code>,
se vším potřebným pro předmět UPR.</p>
<p>Abyste jej mohli použít, tak si nejprve musíte nainstalovat virtualizační program
<a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox</a>. Poté si
<a href="http://mrl.cs.vsb.cz/data/upr/UPR.ova">předpřipravený obraz</a> stáhněte, otevřete ho ve VirtualBoxu
a potvrďte import s výchozím nastavením.</p>
<p>Virtuální počítač poté bude možné spustit z programu VirtualBox. Uživatelské jméno i heslo je
<code>student</code>.</p>
<h2><a class="header" href="#nativní-instalace-linuxu" id="nativní-instalace-linuxu">Nativní instalace Linuxu</a></h2>
<p>Nejspolehlivější variantou použití Linuxu je nainstalovat si ho přímo &quot;na železo&quot;, tj. bez
virtualizace. Můžete jej například nastavit v režimu
<a href="https://www.tecmint.com/install-ubuntu-alongside-with-windows-dual-boot/">dual boot</a>, kdy se při
startu počítače můžete rozhodnout, zdali se nabootuje do Windows (či jiného operačního systému)
nebo do Linuxu. Pokud jste s Linuxem nikdy nepracovali, tak doporučujeme použít Linuxovou
<a href="https://itsfoss.com/install-ubuntu/">distribuci Ubuntu</a> ve verzi <code>20.04</code>.</p>
<h1><a class="header" href="#vývojové-prostředí" id="vývojové-prostředí">Vývojové prostředí</a></h1>
<p>Abychom mohli přeložit a spustit nějaký program, musíme ho obvykle nejprve zapsat do
jednoho nebo více souborů ve formě tzv. <strong>zdrojového kódu</strong> (<em>source code</em>). K usnadnění tohoto procesu
existují <strong>textové editory</strong> a <strong>vývojová prostředí</strong> jako například <code>MS Visual Studio</code>, <code>QtCreator</code>, <code>JetBrains CLion</code>,
<code>CodeBlocks</code>, <code>Visual Studio Code</code>, <code>vim</code>, <code>emacs</code> apod. Tyto programy usnadňují psaní kódu pomocí zvýrazňování
syntaxe, automatizace překladu, spouštění a testování programů a také správy projektů.</p>
<p>Na cvičeních UPR budeme používat editor <code>Visual Studio Code</code>, který je
<a href="https://code.visualstudio.com/">dostupný zdarma</a>. Níže je stručný návod k jeho použití. Při
programování se hodí detailně znát a efektivně využívat editor, který používáte, ale pro začátek
nám budou stačit naprosté základy.</p>
<h2><a class="header" href="#instalace-potřebných-rozšíření-pomocí-terminálu" id="instalace-potřebných-rozšíření-pomocí-terminálu">Instalace potřebných rozšíření (pomocí terminálu)</a></h2>
<p>VSCode podporuje programovací jazyky pomocí rozšíření, po první instalaci VSCode
tak nejprve musíme nainstalovat potřebná rozšíření pro jazyk C. V terminálu spusťte tyto příkazy:</p>
<pre><code class="language-bash">$ code --install-extension ms-vscode.cpptools
</code></pre>
<blockquote>
<p>Návod pro práci s terminálem na Linuxu můžete najít např. <a href="https://wiki.ubuntu.cz/syst%C3%A9m/p%C5%99%C3%ADkazov%C3%A1_%C5%99%C3%A1dka/termin%C3%A1l">zde</a>.
Tahák pro příkazy terminálu najdete <a href="https://github.com/geordi/upr-course/blob/master/assets/cheatsheets/linux.pdf">zde</a>.</p>
</blockquote>
<h2><a class="header" href="#instalace-potřebných-rozšíření-pomocí-uživatelského-rozhraní" id="instalace-potřebných-rozšíření-pomocí-uživatelského-rozhraní">Instalace potřebných rozšíření (pomocí uživatelského rozhraní)</a></h2>
<ol>
<li>Otevřete obrazovku rozšíření (<code>Ctrl+Shift+X</code> nebo spusťte akci <code>Install Extensions</code>)</li>
<li>Vyhledejte rozšíření <code>C/C++</code> a nainstalujte ho</li>
</ol>
<h2><a class="header" href="#ukázka-nastavení-projektu" id="ukázka-nastavení-projektu">Ukázka nastavení projektu</a></h2>
<p>Jako vzorový projekt můžete použít <a href="https://github.com/geordi/upr-course/tree/master/faq/vscode-template-project">tuto</a>
šablonu.</p>
<p><img src="prostredi/../static/video/vsc_first_run.gif" alt="Nastavení VSCode" /></p>
<h2><a class="header" href="#užitečné-zkratky" id="užitečné-zkratky">Užitečné zkratky</a></h2>
<ul>
<li>Spustit program - <code>F5</code></li>
<li>Naformátovat kód - <code>Ctrl + Shift + I</code></li>
<li>Zobrazit vyhledávač akcí - <code>Ctrl + Shift + P</code></li>
</ul>
<h1><a class="header" href="#překlad-programu" id="překlad-programu">Překlad programu</a></h1>
<p>Pro překlad programů, které budeme psát v jazyce <em>C</em>, do <strong>spustitelného</strong> (<em>executable</em>) souboru
budeme používat program, kterému se říká překladač.
Překladačů jazyka <em>C</em> existuje celá řada, my budeme využívat asi nejpoužívanější překladač pro
Linuxové systémy s názvem <a href="https://gcc.gnu.org/"><strong>GCC</strong></a> (GNU Compiler Collection). </p>
<p>Překladač <code>gcc</code>, spolu s dalšími potřebnými nástroji, můžete na Ubuntu v terminálu nainstalovat
pomocí následujícího příkazu:</p>
<pre><code class="language-bash">$ sudo apt install build-essential
</code></pre>
<h2><a class="header" href="#překlad-prvního-programu" id="překlad-prvního-programu">Překlad prvního programu</a></h2>
<p>Ještě než si ukážeme, jak vlastně programovací jazyk <em>C</em> funguje, tak zkusíme přeložit velmi jednoduchý
<em>C</em> program do spustitelného souboru a spustit jej.
Vytvořte soubor s názvem <code>main.c</code> a nakopírujte<sup class='margin-toggle sidenote-number'>1</sup> do něj následující <em>C</em> kód (později si vysvětlíme,
jak tento kód funguje):</p>
<span class='sidenote'><p><sup class='number'>1</sup>Kód z buněk můžete kopírovat pomocí tlačítka <i class="fa fa-copy"></i> v pravém horním rohu
buňky s kódem.</p>
</span>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Hello world!\n&quot;);
    return 0;
}
</code></pre>
<blockquote>
<p>Tento program se nazývá <code>Hello world</code>, jelikož tento text vypíše na obrazovku.
Podobný jednoduchý program je zpravidla tím prvním, co programátor vytvoří, když se učí nějaký
programovací jazyk.</p>
</blockquote>
<p>Nyní otevřete terminál (<code>Ctrl + Alt + T</code> v Ubuntu) ve složce s tímto souborem, spusťte program
<code>gcc</code> a předejte mu cestu k tomuto souboru:</p>
<pre><code class="language-bash">$ gcc main.c -o program
</code></pre>
<p>Tímto příkazem řeknete &quot;Gécécéčku&quot;, aby přeložil zdrojový soubor <code>main.c</code> a uložil výsledný spustitelný
soubor do souboru <code>program</code><sup class='margin-toggle sidenote-number'>2</sup>. Pokud byste přepínač <code>-o &lt;nazev souboru&gt;</code> nepoužili, tak se vytvoří spustitelný
soubor s názvem <code>a.out</code>.</p>
<span class='sidenote'><p><sup class='number'>2</sup>Na Windowsu spustitelné soubory mají obvykle příponu <code>.exe</code>, na Linuxu to však není běžnou praxí a spustitelné soubory typicky žádnou příponu nemají.</p>
</span>
<p>Pokud chcete nyní program spustit, stačí v terminálu zadat cestu k danému spustitelnému souboru.</p>
<pre><code class="language-bash">$ ./program
Hello world!
</code></pre>
<p>Program by měl na výstup vytisknout text <code>Hello world!</code>.</p>
<details>
<summary>Tipy pro práci s příkazovou řádkou</summary>
<ul>
<li>Při psaní programu budete chtít často po úpravě zdrojového kódu opětovně provést překlad a poté
program spustit. Abyste to provedli v jednom terminálovém příkazu, můžete tyto dva příkazy spojit pomocí <code>&amp;&amp;</code>:
<pre><code class="language-bash">$ gcc main.c -o main &amp;&amp; ./main
</code></pre>
Pokud překlad proběhne úspěšně, tak operátor <code>&amp;&amp;</code> zajistí spuštění následujícího příkazu.</li>
<li>Pokud nechcete příkazy v terminálu psát neustále dokola, šipkou nahoru (↑) můžete vyvolat nedávno
spuštěné příkazy v terminálu.</li>
</ul>
</details>
<p>Pro lepší představu o překladu programů zde máte k dispozici ještě krátké shrnující video:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/Hu7l9NpQ3g8" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h3><a class="header" href="#jak-překlad-probíhá" id="jak-překlad-probíhá">Jak překlad probíhá?</a></h3>
<p>Překlad programu bude detailně vysvětlen později v sekci o <a href="prostredi/../c/modularizace/linker.html">linkeru</a>.
Prozatím nám bude stačit tato zkrácená verze:</p>
<p>Překlad programů probíhá ve dvou hlavních fázích: <strong>překlad</strong> (<em>translation</em>) a <strong>linkování</strong> (<em>linking</em>).
Dohromady se oboum těmto krokům také říká <strong>kompilace</strong> (<em>compilation</em>).</p>
<p>Při překladu překladač vezme každý <em>C</em> zdrojový soubor, který mu předložíme, a samostatně jej přeloží
do tzv. <strong>objektového souboru</strong> (<em>object file</em>). Takovýto soubor obsahuje již přeložené instrukce pro
procesor, ale není sám o sobě spustitelný, tj. nejedná se o program, ale pouze o přeložený binární kód.</p>
<p>Jakmile jsou všechny zdrojové soubory přeloženy do objektových souborů, tak přichází na řadu další
program, tzv. <strong>linker</strong>, který tyto objektové soubory spojí dohromady,
<a href="https://cs.wikipedia.org/wiki/Linker#Funkce_linkeru">propojí</a> je dle potřeby, případně k nim připojí
externí <a href="prostredi/../c/modularizace/knihovny.html">knihovny</a> a na konci vytvoří finální spustitelný soubor, který lze poté
spustit.</p>
<p>Když použijete program <code>gcc</code> způsobem, jaký jsme si ukázali výše, tak se na pozadí spustí překladač
a poté i linker a oba dva tyto kroky se tak provedou automaticky. Je ale možné provést je i separátně:</p>
<pre><code class="language-bash">$ gcc -c main.c      # vytvoří objektový soubor main.o
$ gcc main.o -o main # slinkování souboru main.o 
</code></pre>
<h1><a class="header" href="#ladění-programů" id="ladění-programů">Ladění programů</a></h1>
<p>Tato sekce slouží k řešení často se vyskytujících problémů při programování v C. Pokud váš program
padá při běhu nebo se nechová tak, jak má, tak v něm nejspíše máte nějakou chybu (tzv. <strong>bug</strong>).
Proces hledání chyby, která způsobuje pád nebo špatné chování programu se pak nazývá <strong>ladění</strong> (<em>debugging</em>).</p>
<h3><a class="header" href="#chyby-při-překladu-programu" id="chyby-při-překladu-programu">Chyby při překladu programu</a></h3>
<p>Pokud váš program nelze přeložit a překladač vypisuje nějakou chybovou hlášku, tak máte v zápisu programu
nějakou chybu, obvykle v syntaxi, tedy zápisu kódu. Je dobré si danou chybovou hlášku pořádně přečíst,
obvykle se odkazuje na relativně přesné místo, kde máte kód špatně, a někdy dokonce i nabízí řešení,
jak problém vyřešit.</p>
<p>Při překladu můžete dostat například následující chybovou hlášku:</p>
<pre><code class="language-bash">main.c: In function ‘main’:
main.c:2:2: error: ‘a’ undeclared (first use in this function)
    2 |  a = 0;
</code></pre>
<p>Tato konkrétní chyba byla způsobena tím, že byla použitá proměnná bez její předchozí deklarace. Pokud
chybě nerozumíte, zkuste ji nejprve vygooglit, ideálně pouze část, která není konkrétně závislá na
podobě vašeho projektu. Nemá cenu googlit <code>main.c:2:2</code>, protože tento text je závislý na tom, jak jste
si pojmenovali své soubory, ostatní programátoři nejspíše mají jiné názvy souborů. V případě této chyby
by tedy bylo lepší googlit text <code>error: undeclared (first use in this function)</code>.</p>
<p>Může se stát, že překladač vypíše více chybových hlášek zároveň, i když chyba
v programu je pouze jedna. Zkuste scrollovat výstupem hlášek nahoru, abyste zjistili, která chyba
byla vypsána jako první, zbytek výpisu může být &quot;planý poplach&quot;.</p>
<p>Pokud se vám nedaří chybu vygooglit, tak kontaktujte svého cvičícího.</p>
<p>Při překladu můžete použít dodatečné přepínače, při jejichž použití vydá překladač více varování o
možných problémových místech ve vašem kódu:</p>
<pre><code class="language-bash">$ gcc -Wall -Wextra -pedantic main.c -o program
</code></pre>
<h3><a class="header" href="#chyby-při-běhu-programu" id="chyby-při-běhu-programu">Chyby při běhu programu</a></h3>
<p>Pokud váš program padá při běhu, můžete zkusit následující způsoby ladění:</p>
<h4><a class="header" href="#address-sanitizer" id="address-sanitizer">Address sanitizer</a></h4>
<p>Tento nástroj modifikuje váš program tak, aby dokázal detekovat značné množství chyb při jeho běhu,
a pokud nějakou chybu najde, tak váš program okamžitě ukončí a popíše, k jakému problému došlo. </p>
<pre><code class="language-bash">$ gcc -g -fsanitize=address main.c -o program
</code></pre>
<p>Jakmile takto přeložený program spustíte a dojde k nějaké chybě, tak bude její popis vypsán na výstup.</p>
<p>Pokud se chyba opraví těsně po svém vzniku, je to mnohem jednodušší, než když se chyba projeví až
později v úplně jiné části kódu. <strong>Doporučujeme tak vždy používat Address Sanitizer při vývoji programů v C</strong>.
Ušetříte si tak spoustu času a námahy při ladění chyb.</p>
<h4><a class="header" href="#logování" id="logování">Logování</a></h4>
<p>Jedním z nejjednodušších způsobů, jak se dozvědět, co se v programu děje, je jednoduše tisknout
hodnoty zajímavých proměnných na výstup programu. Pokud přidáte takovýto výstup na různá místa v kódu,
můžete pak podle výstupu zpětně rekonstruovat, co se při běhu programu dělo.</p>
<h4><a class="header" href="#krokování" id="krokování">Krokování</a></h4>
<p>Pro interaktivnější zkoumání chování programů je možné je tzv. <strong>krokovat</strong>. K tomu je potřeba nástroj,
který umí program pozastavit při jeho běhu a zobrazit uživateli, co se v něm děje. Takovéto nástroje se nazývají
<strong>debuggery</strong>. Při krokování se program zastaví na určitém místě (řádku) v kódu, a programátor pak může
zkoumat hodnoty proměnných a spouštět program řádek po řádku.</p>
<p>Pro vás je nejjednodušší použít krokování integrované ve VSCode:</p>
<ul>
<li>Klikněte na sloupeček vlevo od čísla řádku, na kterém chcete, aby se program zastavil.
Objeví se tam červené kolečko (tzv. <strong>breakpoint</strong>).</li>
<li>Spusťte program s laděním (<code>F5</code>). Program by se na řádku s breakpointem měl zastavit.</li>
<li>Ve sloupci <code>Variables</code> v levé části VSCode můžete prozkoumat hodnoty proměnných.</li>
<li>Pomocí příkazu <code>Step Over</code> (<code>F10</code>) program vykoná následující řádek a poté se opět zastaví. Pokud
nechcete přeskakovat volání funkcí, použijte <code>Step Into</code> (<code>F11</code>).</li>
</ul>
<p><video src="../static/video/debugging.webm" controls></video></p>
<blockquote>
<p>VSCode používá pro ladění vašeho programu debugger <code>gdb</code>. Pokud ho chcete použít manuálně, návod
můžete najít například <a href="https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu-pouziti-gdb-a-jeho-nadstaveb/">zde</a>.</p>
</blockquote>
<h1><a class="header" href="#programování-v-c" id="programování-v-c">Programování v <em>C</em></a></h1>
<p>V této kapitole naleznete popis základních konstrukcí jazyka <em>C</em>, které jsou základními
stavebními kameny pro tvorbu programů. Ke každému tématu je k dispozici také sada úloh. Pokud úlohy
zvládnete vypracovat, tak budete mít jistotu, že jste dané téma pochopili a můžete se posunout dále.
Pokud nezvládnete úlohy splnit, tak můžete mít s navazujícími koncepty problém. Pokud nebudete stíhat,
tak kontaktujte svého cvičícího.</p>
<p>Před přečtením této kapitoly si nejprve přečtěte předchozí kapitoly, zejména sekci o
<a href="c/../uvod/pamet.html">paměti</a>.</p>
<p>Zde je přibližný seznam témat, které si během semestru ukážeme. Pořadí témat probíraných na cvičení
a přednáškách se může od tohoto seznamu lišit, tento text je určen spíše jako &quot;kuchařka&quot;, ve které
se můžete k jednotlivým tématům vracet, abyste si je připomněli. Text je nicméně psaný tak, aby se
dal zhruba číst v uvedeném pořadí bez toho, aby používal pojmy, které zatím nebyly vysvětleny.</p>
<h2><a class="header" href="#základní-témata" id="základní-témata">Základní témata</a></h2>
<ul>
<li><a href="c/syntaxe.html">Syntaxe</a> - jak vypadá syntaxe (způsob zápisu) jazyka <em>C</em></li>
<li><a href="c/prikazy_vyrazy.html">Příkazy a výrazy</a> - jak provádět výpočty</li>
<li><a href="c/promenne/promenne.html">Proměnné</a> - jak něco uložit a načíst z paměti</li>
<li><a href="c/datove_typy/datove_typy.html">Datové typy</a> - jak interpretovat hodnoty v paměti</li>
<li><a href="c/rizeni_toku/rizeni_toku.html">Řízení toku</a> - jak se rozhodovat a provádět akce opakovaně</li>
<li><a href="c/funkce/funkce.html">Funkce</a> - jak opakovaně využít a parametrizovat opakující se kód</li>
<li><a href="c/prace_s_pameti/ukazatele.html">Ukazatele</a> - jak sdílet data v paměti a pracovat s adresami</li>
<li><a href="c/pole/pole.html">Pole</a> - jak jednotně pracovat s velkým množstvím dat</li>
<li><a href="c/text/text.html">Text</a> - jak v programech pracovat s textem</li>
<li><a href="c/struktury/vlastni_datove_typy.html">Struktury</a> - jak vytvořit vlastní datové typy</li>
<li><a href="c/soubory/soubory.html">Soubory</a> - jak číst a zapisovat soubory</li>
<li><a href="c/modularizace/modularizace.html">Modularizace</a> - jak rozdělit program do více zdrojových souborů</li>
<li><a href="c/modularizace/knihovny.html">Knihovny</a> - jak využít existující kód od jiných programátorů</li>
</ul>
<p>Všechny tyto koncepty jsou velmi univerzální a v tzv. <a href="https://cs.wikipedia.org/wiki/Imperativn%C3%AD_programov%C3%A1n%C3%AD">imperativních</a>
programovacích jazycích jsou v podstatě všudypřítomné. Jakmile se je jednou naučíte, tak je budete
moct využívat téměř v libovolném populárním programovacím jazyku (Java, C#, Kotlin, Python, PHP,
Javascript, Rust, C++ atd.). </p>
<h2><a class="header" href="#navazující-aplikovaná-témata" id="navazující-aplikovaná-témata">Navazující aplikovaná témata</a></h2>
<ul>
<li><a href="c/aplikovane_ulohy/tga.html">TGA</a> - jak vytvořit obrázek</li>
<li><a href="c/aplikovane_ulohy/gif.html">GIF</a> - jak vytvořit animaci</li>
<li><a href="c/aplikovane_ulohy/sdl.html">SDL</a> - jak vytvořit interaktivní grafickou aplikaci či hru</li>
<li><a href="c/aplikovane_ulohy/chipmunk.html">Chipmunk</a> - jak simulovat fyzikální procesy</li>
</ul>
<h1><a class="header" href="#základy-syntaxe" id="základy-syntaxe">Základy syntaxe</a></h1>
<p><em>C</em> je (programovací) jazyk a jako každý jazyk má svá pravidla, které je nutno dodržovat.
Například v češtině musíme dodržovat určitá pravidla a zvyklosti, abychom byli schopni výsledný
text pochopit. Věty <code>jsme, M y máma, táta a</code> nebo <code>.o dku  d! ty z, jsi</code> nedávají smysl,
protože obsahují interpunkční znaménka na špatných místech, větné členy jsou ve špatném pořadí
a některá slova obsahují mezery na místech, kam nepatří. Stejně tak v jazyce <em>C</em> můžete velmi jednoduše
napsat program, kterému <a href="c/../prostredi/preklad_programu.html">překladač</a> nebude rozumět a překlad poté skončí se
syntaktickou chybou (<em>syntax error</em>). Na syntax <em>C</em> si musíte postupně zvyknout, poté už podobné chyby
budete schopni snadno vyřešit.</p>
<p>Zde je asi nejkratší možný program v jazyce <em>C</em>:</p>
<pre><code class="language-c">int main() {
    return 0;
}
</code></pre>
<p>Tento program nic nedělá, pouze se zapne a poté vypne. V programu je pouze <a href="c/funkce/funkce.html">funkce</a>
s názvem <code>main</code>. Funkce si popíšeme později, prozatím budeme psát kód vždy uvnitř funkce <code>main</code>,
tj. mezi složené závorky <code>{</code> <code>}</code>, na řádky před <code>return 0;</code>. Jednotlivé prvky programu si
postupně vysvětlíme v následujících sekcích, prozatím si však všimněte, že <strong>bílé znaky</strong> (<em>whitespace</em>)<sup class='margin-toggle sidenote-number'>1</sup>
jsou obvykle překladačem ignorovány. Například</p>
<span class='sidenote'><p><sup class='number'>1</sup><a href="https://cs.wikipedia.org/wiki/B%C3%ADl%C3%BD_znak">Bílé znaky</a> jsou (neviditelné) znaky,
které reprezentují mezery v textu, tj. odřádkování, mezerník, tabulátor atd.</p>
</span>
<pre><code class="language-c">int 


main()                 {
    
    
    return         0;
}

</code></pre>
<p>reprezentuje úplně stejný program. Nicméně asi sami uznáte, že pokud bychom s bílými znaky nakládali
takto nerozvážně, tak by zdrojový kód byl pro lidi špatně čitelný. Proto doporučujeme formátování provádět
automaticky ve <a href="c/../prostredi/editor.html">VSCode</a> pomocí zkratky <code>Ctrl + Shift + I</code>, ať nad ním nemusíte přemýšlet.</p>
<p>Bílé znaky nicméně nejsou ignorovány úplně na všech místech. Například v <a href="c/text/retezce.html">řetězcích</a>
jsou bílé znaky brány jako součást textu. Nemůžete také rozdělovat mezerami názvy (např. <code>in t</code> nebo
<code>ma in</code> v programu výše by způsobily chybu při překladu).</p>
<h3><a class="header" href="#komentáře" id="komentáře">Komentáře</a></h3>
<p>Abychom mohli v následujících sekcích popisovat kusy kódu, ukážeme si teď <strong>komentáře</strong>. Jedná se
o text ve zdrojovém kódu, který je určen pro programátory, a ne pro překladač, který je zcela ignoruje.
Bez komentářů bychom nemohli do zdrojového kódu dodávat poznámky, protože překladač by jinak měl snahu
je interpretovat jako <em>C</em> kód. Komentáře v kódu obvykle poznáte snadno, protože je váš editor bude vykreslovat
jinou barvou než zbytek kódu.</p>
<p>V <em>C</em> existují dva typy komentářů:</p>
<ul>
<li>Řádkové komentáře - pokud do kódu napíšete <code>//</code>, tak vše za těmito lomítky až do konce řádku se 
bude brát jako komentář.
<pre><code class="language-c">// komentář 1
int main() {
    // komentář 2
    return 0; // komentář 3
}
</code></pre>
</li>
<li>Blokové komenáře - pokud do kódu napíšete <code>/*</code>, tak bude jako komentář označen všechen následující
text, dokud nedojde k ukončení komentáře pomocí <code>*/</code>.
<pre><code class="language-c">int main() {
    /* zde je komentář
zde taky
a tady taky */
    return 0;
}
</code></pre>
</li>
</ul>
<p>Ze začátku je asi jednodušší používat řádkové komentáře, ve VSCode můžete použít klávesovou zkratku
<code>Ctrl + /</code> pro zakomentování/odkomentování řádku kódu. Pokud vám přijde nějaký kus kódu komplikovaný,
tak si k němu zkuste dopsat komentář, který vysvětlí, co má daný kód dělat. Porozumíte tak kódu
snadněji, až se k němu např. za měsíc vrátíte.</p>
<h3><a class="header" href="#klíčová-slova" id="klíčová-slova">Klíčová slova</a></h3>
<p><strong>Klíčová slova</strong> (<em>keywords</em>) jsou vestavěné názvy, kterým překladač přiřazuje speciální
význam. V textovém editoru je typicky poznáte tak, že budou zabarvená jinou barvou než názvy
vytvořené programátorem. Například v tomto kódu jsou <code>int</code> a <code>return</code> klíčová slova:</p>
<pre><code class="language-c">int main() {
    return 0;
}
</code></pre>
<p>Během semestru se postupně naučíte, k čemu se jednotlivá klíčová slova používají. Jejich kompletní
seznam můžete najít například <a href="https://www.programiz.com/c-programming/list-all-keywords-c-language">zde</a>.</p>
<h3><a class="header" href="#speciální-znaky" id="speciální-znaky">Speciální znaky</a></h3>
<p>Při programování (jak už v <em>C</em>, tak i v jiných jazycích) budete používat spousty symbolů, které běžně
asi často nevyužíváte (například <code>[</code>, <code>]</code>, <code>{</code>, <code>}</code>, <code>&lt;</code>, <code>&gt;</code>, <code>=</code>, <code>%</code>, <code>#</code>, <code>&amp;</code>, <code>*</code>, <code>;</code>, <code>\</code>,
<code>&quot;</code>, <code>'</code>). Obzvláště pokud pro programování budete používat českou klávesnici, je dobré si ze začátku
najít nějaký tahák (např. <a href="https://github.com/geordi/upr-course/blob/master/assets/cheatsheets/keyboard-cs.pdf">tento</a>),
abyste nemuseli pokaždé zdlouhavě vzpomínat, na které klávese se daný znak nachází. </p>
<h3><a class="header" href="#formátování-kódu" id="formátování-kódu">Formátování kódu</a></h3>
<p>Už víme, že překladač ignoruje bílé znaky a celkové formátování kódu. Nicméně programátorům obvykle
velmi záleží na tom, jaké má kód odsazení, zarovnání, závorkování atd. Existuje mnoho
<a href="https://en.wikipedia.org/wiki/Indentation_style">stylů</a>, pomocí kterých můžete kód formátovat.
Například programátoři se dokážou pohádat o tom, zda složené závorky na začátku bloku psát na
stejném:</p>
<pre><code class="language-c">if (...) {

}
while (...) {

}
</code></pre>
<p>nebo novém řádku:</p>
<pre><code class="language-c">if (...)
{
}
while (...)
{
}
</code></pre>
<p>Jaký styl formátování použijete je na vás, nicméně obecně platným pravidlem je, že byste se měli
držet ve svých programech jednotného stylu a nemíchat více stylů dohromady.</p>
<hr />
<p><strong>Cvičení</strong></p>
<ol>
<li>Vytvořte si ve VS Code soubor (pojmenovaný např. <code>main.c</code>) a nakopírujte nebo napište do něj
&quot;prázdný&quot; <em>C</em> program ukázaný výše. Zkuste program
<a href="c/../prostredi/preklad_programu.html#p%C5%99eklad-prvn%C3%ADho-programu">přeložit</a> a spustit.</li>
<li>Zkuste do kódu přidat komentáře nebo bílé znaky (např. prázdné řádky nebo mezery). Otestujte, že
překladač tyto věci při překladu ignoruje.</li>
</ol>
<h1><a class="header" href="#vykonávání-programů" id="vykonávání-programů">Vykonávání programů</a></h1>
<p>Jak už víme, programy jsou <a href="c/../uvod/programovaci_jazyky.html">sekvence příkazů</a> pro počítač, který je provádí
instrukci po instrukci (resp. řádek po řádku). Jakmile počítač vykoná jeden řádek vašeho programu, tak skočí
na řádek níže, dokud nedojde na konec programu. Aby počítač věděl, kterou instrukci má provést
jako první, tak mu musíme říct, kde má začít. K tomu přesně slouží <a href="c/funkce/funkce.html">funkce</a> (pojmenovaný
blok kódu) se speciálním názvem <code>main</code>:</p>
<pre><code class="language-c">int main() {
    // ZDE
    return 0;
}
</code></pre>
<p>Výše zmíněný program se po <a href="c/../prostredi/preklad_programu.html">překladu</a> a spuštění začne vykonávat na prvním řádku
funkce <code>main</code>, a jakmile provede všechny řádky, tak program skončí. Tento program je
v podstatě prázdný, takže se pouze zapne a vypne. Prozatím budeme veškerý kód psát dovnitř funkce
<code>main</code>, mezi složené závorky (<code>{</code>, <code>}</code>) a před řádek <code>return 0;</code> (tedy na místo komentáře <code>ZDE</code>).
<a href="c/../ruzne/funkce_main.html">Později</a> si vysvětlíme, jak tato funkce funguje, prozatím to berte tak,
že v programu vždy musí funkce <code>main</code> být, aby počítač věděl, odkud začít vykonávání kódu. </p>
<h1><a class="header" href="#příkazy" id="příkazy">Příkazy</a></h1>
<p>Programy v <em>C</em> se skládají z <strong>příkazů</strong> (<em>statements</em>). Příkaz říká počítači, co má provést, na
mnohem vyšší úrovni než <a href="c/../uvod/programovaci_jazyky.html">instrukce</a> - jeden C příkaz může být přeložen
překladačem na desítky instrukcí pro procesor. Existuje mnoho různých typů příkazů, které naleznete
v následujících sekcích. Většina příkazů nějakým způsobem pracuje s <em>výrazy</em>, začneme tedy jejich popisem.</p>
<h1><a class="header" href="#výrazy" id="výrazy">Výrazy</a></h1>
<p>Jak už vyplývá z jeho názvu, hlavní funkcí počítače je něco počítat. Jedním ze
základních konstrukcí jazyka <em>C</em> (i jiných programovacích jazyků) tak je možnost vypočítat různé hodnoty.
Něco, co se dá vypočítat (tak, aby výsledkem byla nějaká hodnota), se nazývá <strong>výraz</strong> (<em>expression</em>).
Příkladem asi nejjednoduššího výrazu je číslo, např. <code>5</code>. Takovýto výraz již není nutné dále vyhodnocovat,
jeho hodnota je prostě <code>5</code>. Pokud v programu použijete přímo hodnotu nějakého čísla (popř. něčeho
jiného, jak uvidíme později), tak se takový výraz označuje jako <strong>literál</strong> (<em>literal</em>).</p>
<p>V <em>C</em> můžeme s výrazy provádět různé operace pomocí <strong>operátorů</strong>. Můžeme například použít operátor <code>+</code>
s dvěma výrazy, čímž vznikne složitější výraz: <code>5 + 5</code>, který se v programu vyhodnotí na hodnotu <code>10</code>.
O operátorech si více povíme v kapitole o <a href="c/datove_typy/celociselne_typy.html#operace-s-%C4%8D%C3%ADseln%C3%BDmi-typy">datových typech</a>.</p>
<h3><a class="header" href="#výpis-výrazů" id="výpis-výrazů">Výpis výrazů</a></h3>
<p>Abyste si ze začátku mohli jednoduše zobrazit hodnoty výrazů, tak si ukážeme kód, pomocí kterého
můžete vypsat text na výstup programu (do terminálu). K výpisu můžete použít příkaz</p>
<pre><code class="language-c">printf(&quot;&lt;text&gt;&quot;);
</code></pre>
<p>Text, který vložíte mezi uvozovky (<code>&quot;</code>) se vypíše na výstup programu<sup class='margin-toggle sidenote-number'>2</sup>:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Tento kód můžete modifikovat i spustit přímo v prohlížeči. Stačí kliknout na ikonu
<i class="fa fa-play"></i> vpravo nahoře nebo stisknout <code>Ctrl+Enter</code>.</p>
</span>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Hello world!\n&quot;);
    return 0;
}
</code></pre>
<p>Abyste <code>printf</code> mohli použít, musíte na začátek programu vložit řádek <code>#include &lt;stdio.h&gt;</code>.
Tento řádek i <code>printf</code> zatím berte jako &quot;black box&quot;, <a href="c/preprocesor/vkladani_souboru.html">později</a> si
vysvětlíme, jak přesně fungují.</p>
<p>V zadaném textu můžete používat určité speciální znaky. Například sekvence znaků <code>\n</code> způsobí, že
na výstupu dojde k <strong>odřádkování</strong> (<em>newline</em>), po kterém se text začne vypisovat na dalším řádku:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Prvni radek\nDruhy radek&quot;);
    return 0;
}
</code></pre>
<p>Abyste mohli tisknout hodnoty výrazů, můžete použít <strong>zástupné znaky</strong> (<em>placeholders</em>). Pokud chcete
vypsat <em>číselnou</em> hodnotu na výstup programu, stačí v textu použít zástupný znak <code>%d</code>, za uvozovky
přidat čárku a doplnit výraz na místo určené komentářem:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Cislo: %d\n&quot;, /* Hodnota tohoto výrazu se vypíše na výstup */ 1);
    return 0;
}
</code></pre>
<p>Když chcete vypsat například výsledek vyhodnocení výrazu <code>10 + 5</code>, tak stačí napsat:
<code>printf(&quot;%d\n&quot;, 10 + 5);</code> a na výstup programu by se měl vypsat text <code>15</code>.</p>
<blockquote>
<p>#Q1
Proc se vyhodnoti 10 + 5 drive? Proc se nevyhodnoti drive napr. <code>printf(&quot;%d&quot;, 10</code>?
Otazkou by samozrejme bylo, co by se v takovem pripade stalo s tim vynehanym <code>+ 5)</code> :-)</p>
</blockquote>
<p>Pokud chcete vytisknout více hodnot, tak prostě řádek s <code>printf(…);</code> zkopírujte a na uvedené místo
vložte jiný výraz. Počítač provádí programy řádek po řádku, odshora dolů.</p>
<blockquote>
<p>#Q2 &quot;Počítač provádí programy řádek po řádku, odshora dolů.&quot;
Jak se to vezme, ne? Po nactiSoubor1 nemusi byt nasledujici radek nactiSoubor2 vubec proveden,
pokud nactiSoubor1 typicky vyhodilo error. Potom se pravadi obvykle uplne jine radky.
Anebo si pletu &quot;pocitac provadi&quot; s &quot;program provadi&quot; nebo tak neco?</p>
</blockquote>
<p>Doplňte na místo komentáře
do programu níže nějaký výraz a zkuste uhodnout, co se vypíše na výstup po přeložení a spuštění programu.</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;%d\n&quot;, 1);
    printf(&quot;%d\n&quot;, /* tady vložte výraz */);
    return 0;
}
</code></pre>
<hr />
<p><strong>Cvičení</strong></p>
<p>Zkuste si na místo komentáře doplnit několik výrazů (např. <code>5 + 8</code>, <code>8 * 3</code>, <code>12 * (2 + 3)</code>),
přeložit program, spustit ho a podívat se, co vypíše na výstup, abyste si vyzkoušeli vyhodnocování
výrazů. <strong>Zkuste to na svém počítači pomocí <a href="c/../prostredi/editor.html">editoru</a> a <a href="c/../prostredi/preklad_programu.html">překladače</a>,
ne pouze v prohlížeči!</strong></p>
<hr />
<h3><a class="header" href="#datové-typy" id="datové-typy">Datové typy</a></h3>
<p>Každý výraz má svůj datový typ, který udává, jak je hodnota výrazu v programu interpretována a také
jaké operace má smysl nad výrazem dělat. Více o datových typech a operátorech se dozvíte v sekci
<a href="c/datove_typy/datove_typy.html">Datové typy</a>.</p>
<h3><a class="header" href="#vedlejší-efekty" id="vedlejší-efekty">Vedlejší efekty</a></h3>
<p>Pokud chcete pouze vypočítat výraz (&quot;jen tak&quot;), mimo nějaký příkaz, stačí za něj dát středník. Tím
ze samostatného výrazu uděláte příkaz:</p>
<pre><code class="language-c">1 + 1; // vypočte se `2`, výsledek se na nic nepoužije
</code></pre>
<p>Toto má smysl dělat pouze u výrazů, které mají nějaký <strong>vedlejší efekt</strong> (<em>side effect</em>), který
způsobí, že při provádění výrazu se v programu něco změní. Jinak by výraz sám o sobě byl vypočten,
ale nic dalšího by se nestalo. O výrazech, které umí produkovat vedlejší efekty, se dozvíte v pozdějších
sekcích.</p>
<h3><a class="header" href="#příkazy-vs-výrazy" id="příkazy-vs-výrazy">Příkazy vs výrazy</a></h3>
<p>Jakmile se budete postupně učit o jednotlivých konstrukcích jazyka C, je důležité uvědomit si, jaký
je rozdíl mezi výrazem (něco, co se dá vypočítat) a příkazem, pomocí kterého počítači říkáme, aby
něco (s nějakým výrazem) udělal (například vypsal ho na výstup, zapsal do paměti atd.).</p>
<blockquote>
<p>#Q3 Ackoliv jsem se to snazil pochopit za poslednich 10 let milionkrat, porad mi rozdil mezi expressions
a statements neni jasny. Tato kapitola mi v tom poradek neudelala.
Expression = neco, co se da vypocitat tak, aby vysledkem byla nejaka hodnota. Hodnotou je zde mysleno
striktne ciselna hodnota? Pak je ale expression cela komplet cela funkce main, kdyz vraci ciselnou
hodnotu 1? Osamocene vyhrazne keywords jazyka, for, if, sizeof, *, int apod. jsou co? Vypocitat se
nedaji, tudiz to expressions nebudou. Statements tedy az ve spojeni s necim, predpokladam.
Dale, je konstrukce if else operatorem? Dokazu si predstavit existenci operatora |x| (abs. hodnota)
implementovaneho prave touto konstrucki. Co by pak if/else bylo?
Dale, vyse je napsano, ze <code>printf(&quot;string&quot;);</code> je prikaz. A dle posledniho odstavce by pak <code>&quot;string&quot;</code>
bylo neco, co se da vypocitat. Tezko si predstavit, jak vypocitavam cislo 5, znak <code>x</code> nebo string
<code>text</code>. Neni to spise neco, <em>s cim se da pocitat</em>? Atd. atp.
Je mi jasne, ze v C99 bude ten rozdil nejak formalne exaktne vymezen. Mozna by se ta hromada ruznych
druhu vysvetleni (v dobre vire, urcite), co jsem uz slysel, mela vymenit za nudny formalismus.
Mozna by to bylo lepe.</p>
</blockquote>
<p>Něco, co se dá vypočítat (tak, aby výsledkem byla nějaká hodnota), se nazývá <strong>výraz</strong> (<em>expression</em>).</p>
<h1><a class="header" href="#proměnné" id="proměnné">Proměnné</a></h1>
<p>Aby programy mohly řešit nějaký úkol, tak si téměř vždy musí umět něco zapamatovat. K tomu
slouží tzv. <strong>proměnné</strong> (<em>variables</em>). Proměnné nám umožňují pracovat s pamětí počítače (RAM)
intuitivním způsobem - část paměti si pojmenujeme nějakým jménem a dále se na ni tímto jménem
odkazujeme. Do proměnné poté můžeme uložit nějakou hodnotu, čímž si ji počítač &quot;zapamatuje&quot;. Tuto
hodnotu můžeme později v programu přečíst anebo ji změnit.</p>
<p>Příklady použití proměnných:</p>
<ul>
<li>Ve webové aplikaci si číselná proměnná pamatuje počet návštěvníků. Při zobrazení stránky
se hodnota proměnné zvýší o 1.</li>
<li>Ve hře si číselná proměnná pamatuje počet životů hráčovy postavy. Pokud dojde k zásahu postavy
nepřítelem, tak se počet životů sníží o zranění (<em>damage</em>) nepřítelovy zbraně. Pokud hráč sebere lékárníčku,
tak se počet jeho životů opět zvýší.</li>
<li>V terminálu si proměnná reprezentující znaky pamatuje text, který byl zadán na klávesnici.</li>
</ul>
<h3><a class="header" href="#definice" id="definice">Definice</a></h3>
<p>Proměnné jsou jedním z nejzákladnějších a nejčastěji používaných stavebních kamenů většiny programů, během
semestru se s nimi budeme setkávat neustále. Není tak náhodou, že jedním z nejzákladnějších příkazů
v <em>C</em> je právě vytvoření proměnné. Tím řekneme počítači, aby vyčlenil (tzv. <strong>naalokoval</strong>) místo v paměti,
které si v programu nějak pojmenujeme a dále se na něho pomocí jeho jména můžeme odkazovat<sup class='margin-toggle sidenote-number'>1</sup>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>O tom, jak přesně tato alokace paměti probíhá, se dozvíte později v sekci o
<a href="c/promenne/../prace_s_pameti/automaticka_pamet.html">práci s pamětí</a>.</p>
</span>
<p>Takto vypadá příkaz <strong>definice</strong> (vytvoření) proměnné s názvem <code>vek</code> s datovým typem <code>int</code>:</p>
<pre><code class="language-c">int vek;
</code></pre>
<p>Jakmile proměnnou nadefinujeme, tak z ní můžeme buď číst anebo zapisovat paměť, kterou tato proměnná
reprezentuje, pomocí jejího názvu (zde <code>vek</code>).</p>
<h3><a class="header" href="#platnost" id="platnost">Platnost</a></h3>
<p>Proměnná je platná (lze ji používat) vždy od místa (řádku) definice do konce <strong>bloku</strong>, ve kterém byla
nadefinována. Bloky jsou kusy kódu ohraničené složenými závorkami (<code>{</code> a <code>}</code>):</p>
<pre><code class="language-c">int main() {
    // zde není platné ani `a`, ani `b`
    int a;
    // zde je platné pouze `a`

    {
        // zde je platné pouze `a`
        int b;
        // zde je platné `a` i `b`
    } // zde končí platnost proměnné `b`

    // zde je platné pouze `a`

    return 0;
} // zde končí platnost proměnné `a`
</code></pre>
<p>Všimněte si, že bloky lze vnořovat (lze vytvořit blok v bloku), a proměnné jsou platné i ve vnořených
blocích. Oblast kódu, ve které je proměnná validní, se nazývá <em>(variable) scope</em>.</p>
<h3><a class="header" href="#datový-typ" id="datový-typ">Datový typ</a></h3>
<p><code>int</code> před názvem proměnné udává její datový typ, o kterém pojednává <a href="c/promenne/../datove_typy/datove_typy.html">následující kapitola</a>.
Prozatím si řekněme, že <code>int</code> je zkratka pro <code>integer</code>, tedy celé číslo. Tím říkáme programu, že má
tuto proměnnou (resp. paměť, kterou proměnná reprezentuje) interpretovat jako celé číslo se znaménkem.</p>
<h3><a class="header" href="#inicializace" id="inicializace">Inicializace</a></h3>
<p>Do proměnné bychom měli při jejím vytvoření rovnou uložit nějaký <em>výraz</em>, který musí být stejného
datového typu jako je typ proměnné:</p>
<pre><code class="language-c">int a = 10;
int b = 10 + 15;
</code></pre>
<p>Obecná syntaxe pro definici proměnné je</p>
<p><code>&lt;datový typ&gt; &lt;název&gt;;</code></p>
<p>popřípadě</p>
<p><code>&lt;datový typ&gt; &lt;název&gt; = &lt;výraz&gt;;</code></p>
<p>pokud použijeme inicializaci.</p>
<blockquote>
<p>#Q4 Nerika se inicializaci take deklarace? Anebo to si s necim pletu...</p>
</blockquote>
<blockquote>
<p>Všimněte si, že na konci definice proměnné vždy musí následovat středník (<strong>;</strong>).
Opomenutí středníku na konci příkazu je velmi častá chyba, která často končí těžko srozumitelnými chybovými
hláškami při překladu. Dávejte si tak na středníky pozor, obzvláště ze začátku.</p>
</blockquote>
<h4><a class="header" href="#vždy-inicializujte-proměnné" id="vždy-inicializujte-proměnné">Vždy inicializujte proměnné!</a></h4>
<p>Je opravdu důležité do proměnné vždy při její definici přiřadit nějakou úvodní hodnotu. Pokud to
neuděláme, tak její hodnota bude <strong>nedefinovaná</strong> (<em>undefined</em>). Čtení hodnoty takovéto nedefinované proměnné
způsobuje <strong>nedefinované chování</strong> (<em>undefined behaviour</em>)<sup class='margin-toggle sidenote-number'>2</sup> programu. Pokud k tomu dojde, tak si překladač
s vaším programem může udělat, co se mu zachce, a váš program se poté může chovat nepředvídatelně.</p>
<span class='sidenote'><p><sup class='number'>2</sup>Situace, které můžou způsobit nedefinované chování, budou dále v textu označené pomocí ikony
💣.</p>
</span>
<blockquote>
<p>#Q5 Takze v C neexistuji specialni datove typy a la <code>undefined</code>, <code>NIL</code> apod.?</p>
</blockquote>
<p><strong>Proto vždy dávejte proměnným iniciální hodnotu!</strong></p>
<h3><a class="header" href="#Čtení" id="Čtení">Čtení</a></h3>
<p>Pokud v programu použijeme název platné proměnné, tak vytvoříme výraz, který se vyhodnotí jako její
současná hodnota:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int main() {
    int a = 5;
    int b = a;  // hodnota `b` je 5
    int c = b + a + 1;  // hodnota `c` je 11

    printf(&quot;a = %d, b krat 2 = %d, c = %d&quot;, a, b * 2, c);

    return 0;
}
</code></pre>
<p>Proměnnou (resp. její název) tak lze použít kdekoliv, kde je očekáván výraz (pokud sedí datové typy).
Pro výpis hodnot proměnných na výstup programu můžete použít <code>printf</code>.
Hodnoty proměnných můžete zkoumat také krokováním pomocí <a href="c/promenne/../../prostredi/ladeni.html#krokov%C3%A1n%C3%AD">debuggeru</a>.</p>
<h3><a class="header" href="#zápis" id="zápis">Zápis</a></h3>
<p>Pokud by proměnná měla pouze svou původní hodnotu, tak by nebyla moc užitečná. Hodnoty proměnných
naštěstí jde měnit. Můžeme k tomu použít výraz <strong>přiřazení</strong> (<em>assignment</em>):</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int main() {
    int a = 5;  // hodnota `a` je 5
    printf(&quot;%d\n&quot;, a);

    a = 8;      // hodnota `a` je nyní 8
    printf(&quot;%d\n&quot;, a);

    return 0;
}
</code></pre>
<p>Obecná syntaxe pro přiřazení do proměnné je</p>
<p><code>&lt;název proměnné&gt; = &lt;výraz&gt;</code></p>
<p>Opět musí platit, že výraz musí být stejného typu<sup class='margin-toggle sidenote-number'>3</sup>, jako je proměnná, do které přiřazujeme. Na konci
řádku také nesmí chybět středník. Přiřazení je příklad výrazu, který má <a href="c/promenne/../prikazy_vyrazy.html#vedlej%C5%A1%C3%AD-efekty">vedlejší efekt</a>.
Abychom z něj udělali příkaz, musíme za něj dát středník <code>;</code>.</p>
<span class='sidenote'><p><sup class='number'>3</sup><em>C</em> umožňuje automatické (tzv. <strong>implicitní</strong>) konverze mezi některými datovými typy, takže typ výrazu
nemusí být nutně vždy stejný. Tyto konverze se nicméně často chovají neintuitivně a překladač vás před nimi
obvykle nijak nevaruje, i když vrátí výsledek, který nedává smysl. Snažte se tak ze začátku opravdu vždy
používat odpovídající typy. Více se dozvíte v sekci o <a href="c/promenne/../datove_typy/datove_typy.html">datových typech</a>. </p>
</span>
<blockquote>
<p><strong>Jak přiřazení funguje?</strong> Počítač se podívá, na jaké adrese v paměti daná proměnná leží, a zapíše do
paměti hodnotu výrazu, který do proměnné zapisujeme, čímž změní její hodnotu v paměti. Z toho vyplývá,
že dává smysl zapisovat hodnoty pouze do něčeho, co má adresu v paměti<sup class='margin-toggle sidenote-number'>4</sup>. Například příkaz <code>5 = 8;</code> nedává smysl. <code>5</code>
je výraz, číselná hodnota, která nemá žádnou adresu v paměti, nemůžeme tak do ní nic zapsat. Stejně tak
jako nedává smysl říct <code>Číslo 5 odteď bude mít hodnotu 8</code>.</p>
<span class='sidenote'><p><sup class='number'>4</sup>Zatím známe pouze proměnné, později si však ukážeme <a href="c/promenne/../prace_s_pameti/ukazatele.html">další možnosti</a>, jak vytvořit
&quot;něco, co má adresu v paměti&quot;, a co tak půjde použít na levé straně výrazu přiřazení <code>=</code>.</p>
</span></blockquote>
<h3><a class="header" href="#definice-více-proměnných-najednou" id="definice-více-proměnných-najednou">Definice více proměnných najednou</a></h3>
<p>Pokud potřebujete vytvořit více proměnných stejného datového typu, můžete použít více názvů
oddělených čárkou za datovým typem proměnné. Takto například lze vytvořit tři celočíselné proměnné
s názvy <code>x</code>, <code>y</code> a <code>z</code>:</p>
<pre><code class="language-c">int x = 1, y = 2, z = 3;
</code></pre>
<blockquote>
<p>Doporučujeme však tento způsob tvorby více proměnných spíše nepoužívat, aby byl kód přehlednější.</p>
</blockquote>
<hr />
<p><strong>Cvičení</strong></p>
<ol>
<li>Zkuste napsat program, který vytvoří několik proměnných, přečte a změní jejich hodnoty
a pak je vypíše na výstup programu (k výpisu využijte <code>printf</code>, který jsme si již ukázali <a href="c/promenne/../prikazy_vyrazy.html#v%C3%BDpis-v%C3%BDraz%C5%AF">dříve</a>).</li>
<li>Použijte <a href="c/promenne/../../prostredi/ladeni.html#krokov%C3%A1n%C3%AD">debugger</a>, abyste se interaktivně za běhu programu
podívali, jaké jsou hodnoty jednotlivých proměnných a jak se měni v čase po provedení přiřazení.</li>
</ol>
<p>Více úloh naleznete <a href="c/promenne/../../ulohy/zaklady.html">zde</a>.</p>
<hr />
<h1><a class="header" href="#globální-proměnné" id="globální-proměnné">Globální proměnné</a></h1>
<p>Proměnné, které jsme si ukázali, byly vytvářeny uvnitř <a href="c/promenne/../funkce/funkce.html">funkcí</a> (tj. ne na nejvyšší
úrovni souboru). Takovéto proměnné se nazývají <strong>lokální proměnné</strong>. Pokud chceme, aby k nějaké
proměnné byl přístup odkudkoliv v programu, tak můžeme vytvořit proměnnou na úrovni souboru.
Takovéto proměnné se nazývají <strong>globální</strong>.</p>
<p>V rámci jednoho souboru lze globální proměnnou použít od místa, kde je definována, až po
konec souboru:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

// zde nelze použít proměnnou `globalni_promenna`

int globalni_promenna = 1;

// zde lze použít proměnnou `globalni_promenna`

int main() {
    // zde lze použít proměnnou `globalni_promenna`

    globalni_promenna += 1;
    printf(&quot;%d\n&quot;, globalni_promenna);

    return 0;
}

void funkce2() {
    // zde lze použít proměnnou `globalni_promenna`
    printf(&quot;%d\n&quot;, globalni_promenna);
}
</code></pre>
<h3><a class="header" href="#iniciální-hodnota" id="iniciální-hodnota">Iniciální hodnota</a></h3>
<p>Narozdíl od lokálních proměnných, globální proměnné se nainicializují na hodnotu <code>0</code><sup class='margin-toggle sidenote-number'>1</sup>, i když
jim žádnou úvodní hodnotu nedáte. I tak je ale dobrým zvykem úvodní hodnotu takovýmto proměnným dát,
aby šlo jasně vidět, že absence úvodní hodnoty není pouze nedopatřením ze strany programátora.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Je to zajištěno tím, že jsou uloženy v sekci spustitelného souboru nazývané
<a href="https://en.wikipedia.org/wiki/.bss"><code>.bss</code></a>. Po spuštění programu jsou tak automaticky vynulovány.</p>
</span>
<h3><a class="header" href="#nepoužívání-globálních-proměnných" id="nepoužívání-globálních-proměnných">(Ne)používání globálních proměnných</a></h3>
<p>Globální proměnné jsou zde zmíněny pro úplnost, nicméně doporučujeme je používat spíše zřídka,
obzvláště pokud půjde o globální proměnné, které půjde měnit (tj. pokud to nebudou
<a href="c/promenne/konstanty.html">konstanty</a>). Obecně řečeno, na čím více místech je proměnná dostupná, tím složitější
je přemýšlení nad tím, jak přesně s ní pracovat, proto je lepší používat proměnné lokální, pokud to
jde. </p>
<p>Když je proměnná globální, tak je k ní přístup v podstatě odkudkoliv v programu. To sice zní
neškodně, ba i užitečně, nicméně přináší to s sebou značné nevýhody, pokud lze proměnnou zároveň
měnit. Jakmile totiž lze proměnnou odkudkoliv změnit, snadno se vám může stát, že nějaký kus programu
vám bude hodnotu takovéto proměnné měnit &quot;pod rukama&quot;, a bude obtížné najít kód, který danou proměnnou
změnil (a také důvod, proč ji změnil).</p>
<blockquote>
<p>Globální proměnné také mohou způsobovat problémy, pokud ve vašem problému<sup class='margin-toggle sidenote-number'>2</sup> budete využívat více jader
procesoru. Tzv. paralelní programy nicméně nebudeme v tomto předmětu řešit, více se o nich dozvíte
například v předmětu <a href="http://poli.cs.vsb.cz/edu/apps/">Architektury počítačů a paralelních systémů</a>.</p>
<span class='sidenote'><p><sup class='number'>2</sup>&quot;ve vasem programu?&quot;</p>
</span></blockquote>
<h1><a class="header" href="#konstanty" id="konstanty">Konstanty</a></h1>
<p>V určitých případech můžeme chtít mít proměnné s konstantní hodnotou, které by se neměly v průběhu
programu měnit. Takové proměnné se nazývají <strong>konstanty</strong> (<em>constants</em>).</p>
<p>Abychom zamezili nechtěné změně hodnoty konstanty, můžeme datový typ proměnné označit
<a href="c/promenne/../syntaxe.html#kl%C3%AD%C4%8Dov%C3%A1-slova">klíčovým slovem</a> <code>const</code>, který umístíme před<sup class='margin-toggle sidenote-number'>1</sup> název datového typu.
Pokud bychom se snažili o změnu proměnné s takovýmto datovým typem, překladač nám to nedovolí.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Modifikátor <code>const</code> lze umístit i za datový typ. Někteří programátoři o umístění tohoto
modifikátoru vedou
<a href="https://mariusbancila.ro/blog/2018/11/23/join-the-east-const-revolution">vášnivé diskuze</a>. Důležité
hlavně je, abyste ve volbě umístění modifikátorů byli konzistentní a používali je na všech místech
stejně.</p>
</span>
<pre><code class="language-c editable mainbody">int main() {
    const int a = 5;
    a += 1; // chyba

    return 0;
}
</code></pre>
<p>Použití konstant může mít několik důvodů:</p>
<ul>
<li>
<p>V programech někdy opakovaně použiváme konstantní hodnoty, které mají pevně danou hodnotu. Při
čtení zdrojového kódu nemusí být jasné, co takového hodnoty znamenají (v takovém případě se hanlivě
označují jako &quot;magické konstanty&quot;). Abychom takového hodnoty pojmenovali, můžeme je uložit do
konstantní proměnné. Při čtení programu pak bude zřejmé, co reprezentují. Porovnejte variantu
s nepopsanými číselnými hodnotami:</p>
<pre><code class="language-c">float vypocti_cenu(float cena) {
    return cena * (1 + 0.21);
}
float vypocti_odvod(float celkova_cena, bool dph) {
    if (dph) {
        return celkova_cena * 0.21;
    } else {
        return 0;
    }
}
</code></pre>
<p>s variantou využívající pojmenované konstanty:</p>
<pre><code class="language-c">const float DPH = 0.21f;

float vypocti_cenu(float cena) {
    return cena * (1 + DPH);
}
float vypocti_odvod(float celkova_cena, bool dph) {
    if (dph) {
        return celkova_cena * DPH;
    } else {
        return 0;
    }
}
</code></pre>
<p>Druhá varianta kódu je jistě čitelnější.</p>
</li>
<li>
<p>V určitých případech, například u konstantních <a href="c/promenne/../text/retezce.html">řetězců</a>, jsou data uložena v oblasti
paměti, kterou nelze měnit. Pomocí <code>const</code> si můžeme pohlídat, že se takováto paměť opravdu nezmění.</p>
</li>
</ul>
<h1><a class="header" href="#složený-zápis" id="složený-zápis">Složený zápis</a></h1>
<p>Často potřebujeme hodnotu proměnné pouze trochu poupravit, a ne do ní vyloženě zapsat novou hodnotu.
Běžná je například operace zvýšení hodnoty proměnné o <code>1</code> (tzv. <strong>inkrementace</strong> proměnné).
K tomu můžeme použít tento příkaz:</p>
<pre><code class="language-c">pocet = pocet + 1; // zvýšení hodnoty proměnné `pocet` o 1
</code></pre>
<p>nicméně to je docela zdlouhavé. Proto <em>C</em> nabízí tzv. operátory <strong>složeného zápisu</strong> (<em>compound
assignment</em>). Tyto operátory jsou spojené z normálního operátoru (např. <code>+</code>) a operátoru <code>=</code>, například:</p>
<ul>
<li><code>+=</code></li>
<li><code>-=</code></li>
<li><code>*=</code></li>
<li><code>/=</code></li>
</ul>
<p>Složený zápis</p>
<pre><code class="language-c">&lt;proměnná&gt; &lt;operátor&gt;= &lt;výraz&gt;;
</code></pre>
<p>je ekvivalentní příkazu</p>
<pre><code class="language-c">&lt;proměnná&gt; = &lt;proměnná&gt; &lt;operátor&gt; &lt;výraz&gt;;
</code></pre>
<p>Například:</p>
<pre><code class="language-c">int pocet = 0;
pocet += 1;   // stejné jako pocet = pocet + 1;
pocet *= 3;   // stejné jako pocet = pocet * 3; 
</code></pre>
<p>Stejně jako <a href="c/promenne/promenne.html#z%C3%A1pis">zápis</a> je složený zápis příkladem výrazu s
<a href="c/promenne/../prikazy_vyrazy.html#vedlej%C5%A1%C3%AD-efekty">vedlejším efektem</a>.</p>
<h3><a class="header" href="#inkrementace-a-dekrementace" id="inkrementace-a-dekrementace">Inkrementace a dekrementace</a></h3>
<p>Speciálním případem složeného zápisu je tzv. <strong>inkrementace</strong> (zvýšení hodnoty proměnné o jedničku)
a <strong>dekrementace</strong> (snížení hodnoty proměnné o jedničku). Tyto operace jsou tak časté, že <em>C</em> obsahuje
speciální &quot;zkratky&quot; pro jejich provedení. Aby to nebylo tak jednoduché, tak tyto zkratky
existují ve dvou variantách:</p>
<ul>
<li><em>Postfixová</em>: <code>&lt;proměnná&gt;++</code>. Tento výraz se nejprve vyhodnotí jako hodnota dané proměnné, a
<strong>poté</strong> (provede vedlejší efekt, který) zvýší hodnotu proměnné o jedničku. Zkuste uhodnout, co vypíše následující program:
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1;
    int b = a++;
    printf(&quot;%d\n&quot;, a);
    printf(&quot;%d\n&quot;, b);

    return 0;
}
</code></pre>
</li>
<li><em>Prefixová</em>: <code>++&lt;proměnná&gt;</code>. Tento výraz <strong>nejprve</strong> zvýší hodnotu proměnné, a až poté se vyhodnotí
jako (nová, již zvýšená) hodnota dané proměnné. Zkuste uhodnout, co vypíše následující program:
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1;
    int b = ++a;
    printf(&quot;%d\n&quot;, a);
    printf(&quot;%d\n&quot;, b);

    return 0;
}
</code></pre>
</li>
</ul>
<p>Dekrementace se chová totožně jako inkrementace, pouze s tím rozdílem, že snižuje hodnotu
proměnné o <code>1</code> a místo <code>++</code> používá <code>--</code>.</p>
<p>Inkrementace a dekrementace jsou opět příklady výrazů s vedlejším efektem.</p>
<blockquote>
<p>Tyto zkratky jsou sice užitečné, ale také můžou vyústit v překvapivé chování díky způsobu, kterým
jsou vyhodnocovány. Ze začátku je radši využívejte pouze v situacích, kdy budou použity jako příkaz,
který změní hodnotu proměnné (<code>i++;</code>). Jinak řečeno, raději se moc nespoléhejte na hodnotu, ve
kterou se inkrementace/dekrementace vyhodnotí.</p>
</blockquote>
<h1><a class="header" href="#pojmenovávání-proměnných" id="pojmenovávání-proměnných">Pojmenovávání proměnných</a></h1>
<p>V <em>C</em> existují určitá pravidla pro pojmenování proměnných:</p>
<ul>
<li>Proměnné se nesmí jmenovat stejně jako <a href="c/promenne/../syntaxe.html#kl%C3%AD%C4%8Dov%C3%A1-slova">klíčová slova</a>, jinak by
překladač neuměl rozlišit, co je název proměnné a co klíčové slovo (například <code>int int;</code>).</li>
<li>Název proměnné může obsahovat pouze malá (<code>a-z</code>) a velká (<code>A-Z</code>) písmena anglické abecedy, číslice
(<code>0-9</code>) a podtržítko (<code>_</code>).</li>
<li>Název proměnné nesmí začínat číslicí, tj. <code>5x</code> není validní název proměnné.</li>
</ul>
<p>V programech je nutné neustále přiřazovat něčemu název, což zdaleka není tak jednoduché, jak se
může na první pohled zdát. Kromě výše zmíněných pravidel je zároveň vhodné volit názvy tak, aby byly
přehledné pro vás (a ostatní programátory, kteří váš zdrojový kód budou číst). Názvy proměnných jako
<code>a</code> nebo <code>x</code> jsou nicneříkající a kód s podobnými názvy je pak složitější pochopit. Porovnejte
následující dva úseky kódu, které se liší pouze v použitých názvech proměnných:</p>
<pre><code class="language-c">int c = 1337;
int x = c - y;
int d = x * z;

// vs

int zakladni_cena = 1337;
int zlevnena_cena = zakladni_cena - sleva;
int finalni_cena = zlevnena_cena * dph;
</code></pre>
<p>I když je druhá varianta delší, tak jde okamžitě poznat, co program počítá, narozdíl od první varianty.</p>
<h3><a class="header" href="#víceslovné-názvy" id="víceslovné-názvy">Víceslovné názvy</a></h3>
<p>Existuje několik zaběhlých stylistických způsobů pro zápis názvů v <em>C</em>, které obsahují více slov. Zde
je seznam nejpoužívanějších konvencí:</p>
<ul>
<li><strong>Camel case</strong>: <code>mujUcet</code>, <code>prvniKlikUzivatele</code></li>
<li><strong>Pascal case</strong>: <code>MujUcet</code>, <code>PrvniKlikUzivatele</code></li>
<li><strong>Snake case</strong>: <code>muj_ucet</code>, <code>prvni_klik_uzivatele</code></li>
<li><strong>Screaming snake case</strong>: <code>MUJ_UCET</code>, <code>PRVNI_KLIK_UZIVATELE</code></li>
</ul>
<p>Různé konstrukce <em>C</em> můžou využívat různé styly, například častá konvence je použití <code>snake_case</code>
pro názvy <a href="c/promenne/promenne.html">proměnných</a> a <a href="c/promenne/../funkce/funkce.html">funkcí</a> a <code>PascalCase</code> pro názvy
<a href="c/promenne/../struktury/struktury.html">struktur</a>. Který styl budete používat záleží na vaší osobní preferenci,
nicméně důležité je zejména držet se jednotného stylu a nekombinovat různé styly (pro stejný
typ konstrukcí) v jednom programu.</p>
<h3><a class="header" href="#Čeština-nebo-angličtina" id="Čeština-nebo-angličtina">Čeština nebo angličtina?</a></h3>
<p>Pokud vám to přijde přehlednější, tak ze začátku můžete používat české názvy<sup class='margin-toggle sidenote-number'>1</sup> pro názvy proměnných
a dalších konstrukcí. Může tak pro vás být snadnější odlišit, kterou část kódu jste vytvořili vy (ta
bude mít český název), a co je naopak vestavěná součást <em>C</em> (např. <code>int</code>). </p>
<span class='sidenote'><p><sup class='number'>1</sup>Bez diakritiky.</p>
</span>
<p>Nicméně, jak už bylo naznačeno v <a href="c/promenne/../../uvod/uvod.html">úvodu</a>, primárním jazykem programování je
angličtina. Pokud byste se někdy setkali s cizím kódem a museli ho pochopit či upravit, určitě oceníte,
když bude v angličtině, než kdyby byl například ve finštině. Stejně tak pokud budete sdílet svůj
kód online, můžete s ním oslovit mnohem širší skupinu programátorů, když bude v angličtině, než kdyby
byl v češtině.</p>
<p>Jakmile se tedy v programování trochu aklimatizujete, používejte ve všech svých programech raději
anglické názvy.</p>
<h1><a class="header" href="#datové-typy-1" id="datové-typy-1">Datové typy</a></h1>
<p><a href="c/datove_typy/../../uvod/pamet.html">Paměť</a> počítače pracuje s jednotlivými <em>byty</em>, nicméně pro lidi
je žádoucí používat popis dat v paměti na mnohem vyšší úrovni abstrakce, aby se nám o datech
jednoduššeji přemýšlelo. Pokud programujeme textový editor, chceme se bavit o znacích, odstavcích,
fontech či barvách, pokud programujeme počítačovou hru, chceme se bavit o zbraních, brnění, kouzlech
či pixelech.</p>
<p>Přesně k tomu slouží <strong>datové typy</strong>, které popisují, jak budeme interpretovat konkrétní hodnoty
daného typu v paměti, kolik bytů budou zabírat a jaké operace nad nimi budeme moct provádět. Jazyk
<em>C</em> obsahuje několik vestavěných datových typů, <a href="c/datove_typy/../struktury/struktury.html">později</a> si ukážeme, jak
vytvořit své vlastní.</p>
<h1><a class="header" href="#celočíselné-datové-typy" id="celočíselné-datové-typy">Celočíselné datové typy</a></h1>
<p>Asi nejpřirozenějším a nejpoužívanějším datovým typem ve většině programovacích jazyků jsou (celá)
čísla. Tyto číselné datové typy nám umožňují pracovat s celými čísly, které mají typicky jednotky
(1 - 8) bytů<sup class='margin-toggle sidenote-number'>1</sup>. Počet bytů udává, jak velký rozsah mohou hodnoty daného typu obsahovat. Například
číslo s 2 byty (16 bity) bez znaménka může obsahovat hodnoty 0 až 2<sup>16</sup>-1. Čím více bytů,
tím více zabere hodnota daného typu místa v paměti.</p>
<span class='sidenote'><p><sup class='number'>1</sup>I když 8 bytů (64 bitů) může znít jako málo, tak pomocí takového čísla můžeme vyjádřit 2<sup>64</sup>
(neboli <code>18 446 744 073 709 551 616</code>) různých hodnot, což pro naprostou většinu běžného použití čísel
bohatě stačí.</p>
</span>
<p>U celých číselných typů se rozlišuje, zda jsou <strong>signed</strong> (se znaménkem) nebo <strong>unsigned</strong> (bez
znaménka, nezáporné). Tato vlastnost udává, jaké hodnoty může typ nabývat
(tj. jestli mohou být i záporné nebo ne). Například číslem o velikosti jednoho bytu můžeme
reprezentovat 256 různých hodnot:</p>
<ul>
<li>Pokud ho budeme interpretovat bez znaménka, tak může uchovávat hodnoty 0 až 255.</li>
<li>Pokud ho budeme interpretovat se znaménkem, tak může uchovávat hodnoty -128 až 127.</li>
</ul>
<p><em>C</em> obsahuje několik základních typů celočíselných proměnných, které se liší v tom, kolik mají bytů a
jestli jsou znaménkové nebo ne. Pokud před název typu napíšeme <code>signed</code>, bude se jednat o znaménkový
typ, pokud použijeme <code>unsigned</code>, tak použijeme typ bez znaménka. Většina typů je implicitně se
znaménkem, tj. <code>int</code> je to samé jako <code>signed int</code>. V následující tabulce je seznam nejčastějších
celočíselných typů<sup class='margin-toggle sidenote-number'>2</sup>:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Počet bytů (a znaménkovost u typu <code>char</code>) záleží na kombinaci použitého hardwaru,
operačního systému a překladače. Zde jsou uvedeny hodnoty, se kterými se můžete
nejčastěji setkat na 64-bitovém x86 Linuxovém systému s překladačem GCC při použití
<a href="https://cs.wikipedia.org/wiki/Dvojkov%C3%BD_dopln%C4%9Bk">dvojkového doplňku</a>.</p>
</span><table><thead><tr><th>Název</th><th align="center">Počet bytů</th><th align="center">Rozsah hodnot</th><th align="center">Se znaménkem</th></tr></thead><tbody>
<tr><td><code>char</code> nebo<br /><code>signed char</code></td><td align="center">1</td><td align="center">[-128; 127]</td><td align="center"><i class="fa fa-check"></i></td></tr>
<tr><td><code>unsigned char</code></td><td align="center">1</td><td align="center">[0; 255]</td><td align="center"><i class="fa fa-times"></i></td></tr>
<tr><td><code>short</code> nebo<br /><code>signed short</code></td><td align="center">2</td><td align="center">[-32 768; 32 767]</td><td align="center"><i class="fa fa-check"></i></td></tr>
<tr><td><code>unsigned short</code></td><td align="center">2</td><td align="center">[0; 65 535]</td><td align="center"><i class="fa fa-times"></i></td></tr>
<tr><td><strong><code>int</code></strong> nebo<br /><code>signed int</code></td><td align="center">4</td><td align="center">[-2 147 483 648; 2 147 483 647]</td><td align="center"><i class="fa fa-check"></i></td></tr>
<tr><td><code>unsigned int</code></td><td align="center">4</td><td align="center">[0; 4 294 967 295]</td><td align="center"><i class="fa fa-times"></i></td></tr>
<tr><td><code>long</code> nebo<br /><code>signed long</code></td><td align="center">8</td><td align="center">[-9 223 372 036 854 775 808;<br />9 223 372 036 854 775 807]</td><td align="center"><i class="fa fa-check"></i></td></tr>
<tr><td><code>unsigned long</code></td><td align="center">8</td><td align="center">[0; 18 446 744 073 709 551 615]</td><td align="center"><i class="fa fa-times"></i></td></tr>
</tbody></table>
<p>Každý vestavěný datový typ (<code>char</code>, <code>short</code>, <code>int</code>) a modifikátor znaménkovosti (<code>signed</code>, <code>unsigned</code>)
je zároveň klíčovým slovem.</p>
<p>Pokud ze začátku nebudete vědět, který typ zvolit, tak pro základní aritmetické operace používejte
ze začátku typy se znaménkem s 4 byty, tedy <code>int</code>. Tento typ je také implicitně použit, když v programu
použijete číselný výraz, například výraz <code>1</code> má datový typ <code>int</code><sup class='margin-toggle sidenote-number'>3</sup>.</p>
<span class='sidenote'><p><sup class='number'>3</sup>Pouze pokud by výraz nešel reprezentovat typem <code>int</code>, použije se číselný typ s více byty.</p>
</span>
<blockquote>
<p>Pokud ze začátku nebudete vědět, který typ zvolit, tak pro základní aritmetické operace používejte
typy se znaménkem s 4 byty, tedy <code>int</code>.</p>
</blockquote>
<blockquote>
<p>Typ <code>char</code> je speciální v tom, že zároveň běžně reprezentuje textové znaky v
<a href="https://www.asciitable.com/">ASCII</a> kódování. Více o reprezentaci textu v programech se dozvíte
v sekci o <a href="c/datove_typy/../text/retezce.html">řetězcích</a>.</p>
</blockquote>
<h3><a class="header" href="#operace-s-číselnými-typy" id="operace-s-číselnými-typy">Operace s číselnými typy</a></h3>
<p><em>C</em> umožňuje provádět operace nad vestavěnými datovými typy pomocí tzv. <strong>operátorů</strong>. Při práci s
výrazy celočíselných typů lze provádět běžné aritmetické operace <code>+</code>, <code>-</code>, <code>/</code>, <code>*</code> nebo <code>%</code> (zbytek
po dělení). Například <code>5 + 8</code> nebo <code>2 * 16</code> tak bude obvykle fungovat tak, jak byste očekávali. Je si
ale třeba dát pozor na několik zrádných věcí:</p>
<ul>
<li>Při dělení dvou celočíselných čísel pomocí operátoru <code>/</code> dochází k celočíselnému dělení, tj. například
výsledek výrazu <code>5 / 2</code> je <code>2</code>, a ne <code>2.5</code>. Pokud chcete provádět dělení desetinných čísel, musíte
použít <a href="c/datove_typy/desetinne_typy.html">odpovídající</a> datový typ. Zkuste si to:
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;
int main() {
    printf(&quot;%d\n&quot;, 5 / 2);
    return 0;
}
</code></pre>
</li>
<li>Jelikož mají čísla v počítači omezenou přesnost (typicky několik jednotek bytů), tak může při matematických
operacích dojít k tzv. <strong>přetečení</strong> (<em>overflow</em>). Například pokud vynásobíme jednobytové číslo <code>50</code>
hodnotou <code>10</code>, tak bychom očekávali výsledek <code>500</code>, nicméně tak velké číslo nelze v jednom bytu reprezentovat.
Výsledkem místo toho bude <code>244</code> (<code>500 % 256</code>), pokud se jedná o číslo bez znaménka, nebo <code>-12</code>, pokud
jde o číslo se znaménkem. Podobné výsledky jsou silně neintuitivní, pokud tedy váš program vrácí zvláštní
číselný výsledek, zkontrolujte si, jestli neprovádíte operace, při kterých mohlo dojít k přetečení.</li>
<li><em>C</em> provádí <a href="https://www.guru99.com/c-type-casting.html">implicitní konverze</a> mezi datovými typy,
které mohou změnit datový typ výrazů, které používáte, bez vašeho vědomí. Je tak (obzvláště ze začátku)
vhodné ujistit se, že provádíte operace mezi stejnými datovými typy.</li>
<li>Stejně jako v matematice, tak i v <em>C</em> záleží u operátorů na jejich prioritě a asociativitě.
Seznam všech operátorů spolu s jejich prioritiou naleznete <a href="https://en.cppreference.com/w/c/language/operator_precedence">zde</a>.
Například výsledek výrazu <code>1 + 2 * 3</code> je <code>7</code>, a ne <code>9</code>. Pokud budete chtít prioritu ovlivnit, můžete
výrazy <strong>uzávorkovat</strong>, abyste jim dali větší přednost: <code>(1 + 2) * 3</code> se vyhodnotí jako <code>9</code>.</li>
</ul>
<p>Kromě základních aritmetických operací <em>C</em> podporuje také <a href="https://cs.wikipedia.org/wiki/Bitov%C3%A1_operace">bitové operace</a>:</p>
<ul>
<li>AND: operátor <code>&amp;</code></li>
<li>OR: operátor <code>|</code></li>
<li>XOR: operátor <code>^</code></li>
</ul>
<hr />
<p><strong>Cvičení</strong>: Zkuste napsat jednoduchý program, který vypočítá různé matematické výrazy a vypíše
je na výstup. Vyhodnocování výrazů si můžete procvičit <a href="c/datove_typy/../../ruzne/vyhodnocovani_vyrazu.html">zde</a>
nebo <a href="c/datove_typy/../../ulohy/zaklady.html">zde</a>. </p>
<hr />
<h3><a class="header" href="#tabulka-aritmetických-operátorů" id="tabulka-aritmetických-operátorů">Tabulka aritmetických operátorů</a></h3>
<p>Zde je pro přehlednost tabulka se základními aritmetickými operátory.
Datový typ výsledku těchto operátorů záleží na datovém typu jejich parametrů.</p>
<table><thead><tr><th align="center">Operátor</th><th align="center">Popis</th><th align="center">Příklad</th></tr></thead><tbody>
<tr><td align="center"><code>+</code></td><td align="center">Sečtení</td><td align="center"><code>1 + 5</code></td></tr>
<tr><td align="center"><code>-</code></td><td align="center">Odečtení</td><td align="center"><code>2.3 - 4.8</code></td></tr>
<tr><td align="center"><code>*</code></td><td align="center">Násobení</td><td align="center"><code>3 * 8</code></td></tr>
<tr><td align="center"><code>/</code></td><td align="center">Dělení</td><td align="center"><code>4 / 2</code></td></tr>
<tr><td align="center"><code>%</code></td><td align="center">Zbytek po dělení (modulo)</td><td align="center"><code>5 % 2</code></td></tr>
<tr><td align="center"><code>&amp;</code></td><td align="center">Bitový součin</td><td align="center"><code>12 &amp; 4</code></td></tr>
<tr><td align="center"><code>|</code></td><td align="center">Bitový součet</td><td align="center"><code>12 | 4</code></td></tr>
<tr><td align="center"><code>~</code></td><td align="center">Bitová negace</td><td align="center"><code>~8</code></td></tr>
<tr><td align="center"><code>^</code></td><td align="center">Bitový XOR</td><td align="center"><code>14 ^ 18</code></td></tr>
<tr><td align="center"><code>&lt;&lt;</code></td><td align="center">Bitový posun doprava</td><td align="center"><code>137 &lt;&lt; 2</code></td></tr>
<tr><td align="center"><code>&gt;&gt;</code></td><td align="center">Bitový posun doleva</td><td align="center"><code>140 &gt;&gt; 3</code></td></tr>
</tbody></table>
<p>O dalších typech operátorů se postupně dozvíte během semestru.
Plný seznam <em>C</em> operátorů naleznete <a href="https://en.cppreference.com/w/c/language/operator_precedence">zde</a>.</p>
<h3><a class="header" href="#hexadecimální-a-oktální-zápis-čísel" id="hexadecimální-a-oktální-zápis-čísel">Hexadecimální a oktální zápis čísel</a></h3>
<p>V <em>C</em> můžete zapisovat číselné hodnoty také pomocí oktální (osmičkové) či hexadecimální (šestnáctkové)
soustavy. Čísla začínající na <code>0</code> budou interpretována jako osmičková soustava, čísla začínající na
<code>0x</code> budou interpretována jako šestnáctková soustava:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 13;     // hodnota 13
    int b = 015;    // hodnota 13
    int c = 0xD;    // hodnota 13
    printf(&quot;%d\n&quot;, a);
    printf(&quot;%d\n&quot;, b);
    printf(&quot;%d\n&quot;, c);

    return 0;
}
</code></pre>
<h1><a class="header" href="#desetinné-číselné-typy" id="desetinné-číselné-typy">Desetinné číselné typy</a></h1>
<p>Pokud budete chtít provádět výpočty s desetinnými čísly, tak můžete využít datové typy s tzv.
<strong>plovoucí řádovou čárkou</strong> (<em>floating point numbers</em>). Hodnoty těchto datových typů umožňují udržovat
čísla sestávající se z celé a z desetinné části. Díky
tomu, jak jsou <a href="https://cs.wikipedia.org/wiki/Pohybliv%C3%A1_%C5%99%C3%A1dov%C3%A1_%C4%8D%C3%A1rka">navržena</a>,
tato čísla dokáží reprezentovat jak velmi malé, tak velmi velké hodnoty (za cenu přesnosti desetinné části).</p>
<p>V <em>C</em> jsou dva základní vestavěné datové typy pro práci s desetinnými čísly, liší se pouze velikostí
(a tedy i tím, jak přesně dokáží desetinná čísla reprezentovat). Oba dva typy jsou znaménkové:</p>
<table><thead><tr><th>Název</th><th align="center">Počet bytů</th><th align="center">Rozsah hodnot</th><th align="center">Přesnost</th><th align="center">Se znaménkem</th></tr></thead><tbody>
<tr><td><code>float</code></td><td align="center">4</td><td align="center">[-3.4x10<sup>38</sup>; 3.4x10<sup>38</sup>]</td><td align="center">~7 des. míst</td><td align="center"><i class="fa fa-check"></i></td></tr>
<tr><td><code>double</code></td><td align="center">8</td><td align="center">[-1.7x10<sup>308</sup>; 1.7x10 <sup>308</sup>]</td><td align="center">~16 des. míst</td><td align="center"><i class="fa fa-check"></i></td></tr>
</tbody></table>
<p>Slovo <code>double</code> pochází z pojmu &quot;double precision&quot;, tedy dvojitá přesnost (typ <code>float</code> se také někdy
označuje pomocí &quot;single precision&quot;).</p>
<p>Pokud chcete v programu vytvořit výraz datového typu <code>double</code>, stačí napsat desetinné číslo (jako
desetinný oddělovač se používá tečka, ne čárka): <code>10.5</code>, <code>-0.73</code>. Pokud chcete vytvořit výraz typu
<code>float</code>, tak za toto číslo ještě přidejte znak <code>f</code>: <code>10.5f</code>, <code>-0.73f</code>.</p>
<p>Pokud chcete vytisknout na výstup hodnotu datového typu <code>float</code> nebo <code>double</code>, můžete použít
<a href="c/datove_typy/../prikazy_vyrazy.html#v%C3%BDpis-v%C3%BDraz%C5%AF">zástupný znak</a> <code>%f</code>:</p>
<pre><code class="language-c">printf(&quot;Desetinne cislo: %f\n&quot;, 1.0);
</code></pre>
<h3><a class="header" href="#přesnost-desetinných-čísel" id="přesnost-desetinných-čísel">Přesnost desetinných čísel</a></h3>
<p>Je třeba si uvědomit, že desetinná čísla v počítači mají pouze konečnou přesnost a jsou reprezentována
v dvojkové soustavě:</p>
<ul>
<li>V počítači nelze reprezentovat iracionální čísla s nekonečnou přesností. Pokud tedy chcete do paměti
uložit například hodnotu <code>π</code>, budete ji muset zaokrouhlit.</li>
<li>Kvůli použití dvojkové soustavy některé desetinné hodnoty nelze vyjádřit přesně. Například číslo
\( \frac{1}{3} \) lze v desítkové soustavě vyjádřit zlomkem, ale v dvojkové soustavě toto číslo
má nekonečný desetinný rozvoj (<code>0.010101…</code>) a opět tedy nelze vyjádřit přesně:
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;
int main() {
    printf(&quot;%f\n&quot;, 1.0 / 3.0);
    return 0;
}
</code></pre>
</li>
</ul>
<h3><a class="header" href="#konverze-na-celé-číslo" id="konverze-na-celé-číslo">Konverze na celé číslo</a></h3>
<p>Pokud budete konvertovat desetinné číslo na celé číslo, tak dojde k &quot;useknutí&quot; desetinné části:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;
int main() {
    printf(&quot;%d\n&quot;, (int) 1.6);
    printf(&quot;%d\n&quot;, (int) -1.6);
    return 0;
}
</code></pre>
<p>Toto chování odpovídá zaokrouhlení k nule, tj. kladná čísla se zaokrouhlí dolů a záporná čísla nahoru.</p>
<h1><a class="header" href="#pravdivostní-typy" id="pravdivostní-typy">Pravdivostní typy</a></h1>
<p>Posledním základním datovým typem, který si ukážeme, je pravdivostní typ
<strong><a href="https://cs.wikipedia.org/wiki/Boolean">Booleovské logiky</a></strong>. Hodnoty tohoto datového typu mají
pouze dvě možné varianty - <strong>pravda</strong> (<em>true</em>) nebo <strong>nepravda</strong> (<em>false</em>). Tento typ se hodí
zejména pro různé logické operace, například porovnávání hodnot (<code>Je a menší než b?</code> - <code>ano</code>/<code>ne</code>).</p>
<p>V <em>C</em> se Booleovský datový typ nazývá <code>_Bool</code>. Nicméně tento název je docela krkolomný, obvykle se
proto používá spíše název <code>bool</code>. Abyste ho mohli použít, tak na začátek programu musíte vložit řádek
<code>#include &lt;stdbool.h&gt;</code>. <a href="c/datove_typy/../preprocesor/vkladani_souboru.html">Později</a> si vysvětlíme, co tento řádek
dělá.</p>
<pre><code class="language-c editable mainbody">#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;

int main() {
    bool venku_je_hezky = true;
    bool upr_je_slozite = false;

    printf(&quot;%d\n&quot;, venku_je_hezky);
    printf(&quot;%d\n&quot;, upr_je_slozite);

    return 0;
}
</code></pre>
<p>Jak lze v ukázce výše vidět, <code>true</code> reprezentuje pravdivý Booleovský výraz a <code>false</code> nepravdivý
Booleovský výraz a <code>bool</code> hodnoty lze vytisknout na výstup stejným způsobem jako celočíselné hodnoty.<sup class='margin-toggle sidenote-number'>1</sup>
Hodnoty Booleovského typu obvykle zabírají v paměti jeden <em>byte</em>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Při výpisu dojde ke <a href="c/datove_typy/pravdivostni_typy.html#konverze">konverzi</a> <code>bool</code>u na celé číslo.</p>
</span>
<h3><a class="header" href="#logické-operace" id="logické-operace">Logické operace</a></h3>
<p>V (Booleovské) logice existují tři základní operátory:</p>
<ul>
<li><strong>logický součin</strong> (<em>AND</em>): <code>platí X a zároveň Y</code></li>
<li><strong>logický součet</strong> (<em>OR</em>): <code>platí X nebo Y</code></li>
<li><strong>logická negace</strong> (<em>NOT</em>): <code>neplatí X</code></li>
</ul>
<p>Tyto logické operace lze v <em>C</em> použít pomocí následujících operátorů:</p>
<ul>
<li><strong>AND</strong>: <code>&amp;&amp;</code></li>
<li><strong>OR</strong>: <code>||</code></li>
<li><strong>NOT</strong>: <code>!</code></li>
</ul>
<p>Tyto operátory můžete použít mezi dvěma výrazy datového typu <code>bool</code>. Například:</p>
<pre><code class="language-c">bool je_muz = true;
bool je_zena = false;
bool je_clovek = je_muz || je_zena; // true || false -&gt; true

bool je_rodic = true;
bool je_otec = je_rodic &amp;&amp; je_muz;  // true &amp;&amp; true -&gt; true
bool je_matka = je_rodic &amp;&amp; ~je_otec; // true &amp;&amp; ~true -&gt; true &amp;&amp; false -&gt; false
</code></pre>
<p>Pro připomenutí, zde je pravdivostní tabulka těchto logických operátorů:</p>
<table><thead><tr><th><code>X</code></th><th align="center"><code>Y</code></th><th align="center"><code>X &amp;&amp; Y</code></th><th align="center"><code>X || Y</code></th><th align="center"><code>~X</code></th></tr></thead><tbody>
<tr><td><code>false</code></td><td align="center"><code>false</code></td><td align="center"><code>false</code></td><td align="center"><code>false</code></td><td align="center"><code>true</code></td></tr>
<tr><td><code>false</code></td><td align="center"><code>true</code></td><td align="center"><code>false</code></td><td align="center"><code>true</code></td><td align="center"><code>true</code></td></tr>
<tr><td><code>true</code></td><td align="center"><code>false</code></td><td align="center"><code>false</code></td><td align="center"><code>true</code></td><td align="center"><code>false</code></td></tr>
<tr><td><code>true</code></td><td align="center"><code>true</code></td><td align="center"><code>true</code></td><td align="center"><code>true</code></td><td align="center"><code>false</code></td></tr>
</tbody></table>
<h3><a class="header" href="#porovnávání-hodnot" id="porovnávání-hodnot">Porovnávání hodnot</a></h3>
<p>Při programování často potřebujete porovnat hodnoty mezi sebou:</p>
<ul>
<li><code>Má Jarda více bodů než Kamil?</code></li>
<li><code>Má uživatelovo heslo více než 5 znaků?</code></li>
<li><code>Má Lenka na účtu alespoň 100 dolarů?</code></li>
</ul>
<p>K tomu slouží šest základních porovnávacích operátorů:</p>
<ul>
<li><strong>Rovná se</strong><sup class='margin-toggle sidenote-number'>2</sup>: <code>==</code><span class='sidenote'><p><sup class='number'>2</sup>Zde si dávejte velký pozor na rozdíl mezi <code>=</code> (přiřazení hodnoty) a <code>==</code> (porovnání dvou hodnot).
Záměna těchto dvou operátorů je častou <a href="c/datove_typy/../../caste_chyby/caste_chyby.html#z%C3%A1m%C4%9Bna--a-">začátečnickou chybou</a>
a vede k obtížně nalezitelným chybám.</p>
</span></li>
<li><strong>Nerovná se</strong>: <code>!=</code></li>
<li><strong>Větší</strong>: <code>&gt;</code></li>
<li><strong>Větší nebo rovno</strong>: <code>&gt;=</code></li>
<li><strong>Menší</strong>: <code>&lt;</code></li>
<li><strong>Menší nebo rovno</strong>: <code>&lt;=</code></li>
</ul>
<p>Porovnávat mezi sebou můžete libovolné hodnoty dvou stejných datových typů. Výsledkem porovnání
je výraz datového typu <code>bool</code>:</p>
<pre><code class="language-c">int jarda_body = 10;
int kamil_body = 13;

bool remiza = jarda_body == kamil_body; // false
bool vyhra_jardy = jarda_body &gt; kamil_body; // true

int delka_hesla = 8;
bool heslo_moc_kratke = delka_hesla &lt;= 5; // false
</code></pre>
<p>Dávejte si ovšem pozor na to, že pouze operátory <code>==</code> a <code>!=</code> lze použít univerzálně na všechny datové typy.
Například použít <code>&lt;</code> pro porovnání dvou Booleovských hodnot obvykle nedává valný smysl, operátory
<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> a <code>&gt;=</code> jsou obvykle využívány pouze pro porovnávání čísel.</p>
<p>Porovnávání hodnot můžete zkombinovat s logickými operátory pro vyhodnocení komplexních pravdivostních
výrazů:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;

int main() {
    int delka_hesla = 8;
    bool email_overen = false;
    int rok_narozeni = 1994;

    bool uzivatel_validni = delka_hesla &gt;= 9 &amp;&amp; (email_overen || rok_narozeni &gt; 1990); // false
    bool uzivatel_validni2 = delka_hesla &gt;= 9 &amp;&amp; email_overen || rok_narozeni &gt; 1990; // true

    printf(&quot;%d\n&quot;, uzivatel_validni);
    printf(&quot;%d\n&quot;, uzivatel_validni2);

    return 0;
}
</code></pre>
<p>Zde je opět třeba dávat si pozor na <a href="https://en.cppreference.com/w/c/language/operator_precedence">prioritu operátorů</a>
(například <code>&amp;&amp;</code> má větší prioritu než <code>||</code>) a v případě potřeby výrazy uzávorkovat. Pokud si zkusíte
přeložit tento program, tak vás dokonce překladač bude varovat před tím, že jste výraz neuzávorkovali a
může tak vracet jiný výsledek, než očekáváte.</p>
<h3><a class="header" href="#tabulka-logických-operátorů" id="tabulka-logických-operátorů">Tabulka logických operátorů</a></h3>
<p>Zde je pro přehlednost tabulka s logickými operátory.
Datový typ výsledku je u těchto operátorů vždy <code>bool</code>.</p>
<table><thead><tr><th align="center">Operátor</th><th align="center">Popis</th><th align="center">Příklad</th></tr></thead><tbody>
<tr><td align="center"><code>&amp;&amp;</code></td><td align="center">Logický součin (AND)</td><td align="center"><code>a == b &amp;&amp; c &gt;= d</code></td></tr>
<tr><td align="center"><code>||</code></td><td align="center">Logický součet (OR)</td><td align="center"><code>a &lt; b || c == d</code></td></tr>
<tr><td align="center"><code>!</code></td><td align="center">Logická negace (NOT)</td><td align="center"><code>!(a &gt; b &amp;&amp; c &lt; d)</code></td></tr>
<tr><td align="center"><code>==</code></td><td align="center">Rovná se</td><td align="center"><code>a == 5</code></td></tr>
<tr><td align="center"><code>!=</code></td><td align="center">Nerovná se</td><td align="center"><code>a != 5</code></td></tr>
<tr><td align="center"><code>&gt;</code></td><td align="center">Větší než</td><td align="center"><code>a &gt; 5</code></td></tr>
<tr><td align="center"><code>&gt;=</code></td><td align="center">Větší nebo rovno než</td><td align="center"><code>a &gt;= 5</code></td></tr>
<tr><td align="center"><code>&lt;</code></td><td align="center">Menší než</td><td align="center"><code>a &lt; 5</code></td></tr>
<tr><td align="center"><code>&lt;=</code></td><td align="center">Menší nebo rovno než</td><td align="center"><code>a &lt;= 5</code></td></tr>
</tbody></table>
<h3><a class="header" href="#zkrácené-vyhodnocování" id="zkrácené-vyhodnocování">Zkrácené vyhodnocování</a></h3>
<p>Při vyhodnocování Booleovských výrazů s logickými operátory se v <em>C</em> používá tzv. <strong>zkrácené vyhodnocování</strong>
(<em>short-circuit evaluation</em>). Například pokud se vyhodnocuje výraz <code>a || b</code>, tak může dojít k následující
situaci:</p>
<ul>
<li>Počítač vše provádí v sekvenčních krocích, tj. nejprve vyhodnotí <code>a</code>.</li>
<li>Pokud má výraz <code>a</code> hodnotu <code>true</code>, tak už je jasné, že celý výraz <code>a || b</code> bude mít hodnotu <code>true</code>.</li>
<li>K vyhodnocení výrazu <code>b</code> tak už nedojde, protože je to zbytečné.</li>
</ul>
<p>Toto chování může urychlit provádění programu, protože přeskakuje provádění zbytečných příkazů,
nicméně může také způsobit nečekané chyby. Pokud by například vyhodnocení výrazu <code>b</code> obsahovalo nějaké
<a href="c/datove_typy/../prikazy_vyrazy.html#vedlej%C5%A1%C3%AD-efekty">vedlejší efekty</a>, které se projeví při jeho provedení (například
změna hodnoty v paměti), tak může být problematické, pokud se vyhodnocení tohoto výrazu zcela
přeskočí. Pokud si pamatujete na <a href="c/datove_typy/../promenne/slozeny_zapis.html#inkrementace-a-dekrementace">inkrementaci</a>,
tak ta je jedním z případů výrazů, které mají vedlejší efekt (změnu hodnoty proměnné).</p>
<h3><a class="header" href="#konverze" id="konverze">Konverze</a></h3>
<p>Pokud se pokusíte o převod celého či desetinného čísla na <code>bool</code>, tak můžou nastat dvě varianty:</p>
<ul>
<li>Pokud je číslo nenulové, výsledkem bude <code>true</code>.</li>
<li>Pokud je číslo nula, výsledkem bude <code>false</code>.</li>
</ul>
<p>V opačném směru (konverze <code>bool</code> u na číslo) dojde k následující konverzi:</p>
<ul>
<li><code>true</code> se převede na <code>1</code></li>
<li><code>false</code> se převede na <code>0</code></li>
</ul>
<h1><a class="header" href="#explicitní-konverze" id="explicitní-konverze">(Explicitní) konverze</a></h1>
<p>Někdy potřebujete převést hodnoty mezi různými datovými typy. K tomu slouží <strong>operátor přetypování</strong>
(<em>cast operator</em>), který má syntaxi <code>(&lt;datový typ&gt;) &lt;výraz&gt;</code> a převede výraz na daný datový typ.
Například <code>(short) 1</code> převede výraz <code>1</code> z typu <code>int</code> na <code>short</code>. Je dobré si uvědomit, k čemu může
dojít při převodu mezi různými datovými typy:</p>
<ul>
<li>Pokud je cílový datový typ menší a převáděnou hodnotu v něm nelze reprezentovat, tak dojde k
oseknutí hodnoty. V důsledku způsobu reprezentace hodnot v počítači takováto operace odpovídá
zbytku po dělení:
<pre><code class="language-c">unsigned short a = 256;
(unsigned char) a // hodnota tohoto výrazu je 0 (256 % 256)
</code></pre>
</li>
<li>Pokud převádíte znaménkový typ na bezznaménkový a hodnota převáděného výrazu je záporná, tak nedojde
k intuitivnímu použití absolutní hodnoty<sup class='margin-toggle sidenote-number'>1</sup>. V důsledku způsobu reprezentace hodnot v počítači takováto
operace odpovídá přičtení dané hodnoty k maximální možné hodnotě cílového typu:
<pre><code class="language-c">signed char c = -50;
(unsigned char) c // hodnota tohoto výrazu je 206 (256 - 50)
</code></pre>
<span class='sidenote'><p><sup class='number'>1</sup>K tomu můžete použít například funkci <a href="https://devdocs.io/c/numeric/math/abs">abs</a>.</p>
</span></li>
</ul>
<p>Pokud se chcete dozvědět více o tom, proč konverze mezi typy fungují tak, jak fungují, tak se podívejte
na to, jak funguje <a href="https://cs.wikipedia.org/wiki/Dvojkov%C3%BD_dopln%C4%9Bk">dvojkový doplněk</a>.</p>
<h1><a class="header" href="#Řízení-toku" id="Řízení-toku">Řízení toku</a></h1>
<p>Pokud by počítače program vždy pouze vykonaly od začátku do konce a provedly pokaždé ty stejné
operace, tak by nebyly moc užitečné. Sice by zvládly něco rychle vypočítat, ale už ne se rozhodovat,
jakou operaci mají provést, nebo nějakou operaci provádět opakovaně, což jsou velmi užitečné vlastnosti.</p>
<p>Instrukce programu se běžně vykonávají (&quot;tečou&quot;) jedna po druhé (&quot;odshora dolů&quot;). <em>C</em> obsahuje příkazy
pro tzv. <strong>řízení toku</strong> (<em>control flow</em>), které můžou toto vykonávání instrukcí ovlivnit:</p>
<ul>
<li><a href="c/rizeni_toku/podminky.html">Podmínky</a> umožňují vykonat kus kódu, pouze pokud platí nějaký výraz (Booleovského typu).
Díky tomu se může program rozhodnout, zda má nějakou operaci provést, nebo ne, v závislosti na vstupu.</li>
<li><a href="c/rizeni_toku/cykly.html">Cykly</a> umožňují vykonávat kus kódu opakovaně. Díky tomu můžeme například provést nějakou
operaci pro všechny prvky ze vstupu programu anebo ji provádět, dokud nedojde ke splnění nějaké podmínky.</li>
</ul>
<blockquote>
<p>Ač se to možná nezdá, tak použití výrazů, proměnných, podmínek a cyklů bohatě stačí k tomu, abyste
byli schopni napsat libovolný počítačový program. Pomocí těchto tří jednoduchých konstrukcí byste
tak teoreticky mohli vytvořit třeba textový editor, hru nebo i celý operační systém. Nicméně, pokud
bychom využívali pouze tyto konstrukce, tak ve větších programech by bylo složité se zorientovat a
byly by také dost neefektivní. V následujících sekcích se tak dozvíteo několika dalších konstrukcích,
které vám můžou programování usnadnit.</p>
</blockquote>
<h1><a class="header" href="#podmínky" id="podmínky">Podmínky</a></h1>
<p>V programech se často potřebujeme rozhodnout, co by se mělo stát v závislosti na hodnotě nějakého
výrazu:</p>
<ul>
<li>Pokud uživatel nakoupil zboží v posledním týdnu, odešli mu e-mail.</li>
<li>Zadal uživatel správné heslo? Pokud ano, tak ho přesměruj na jeho profil. Pokud ne, tak zobraz chybovou hlášku.</li>
<li>Jaké má uživatel konto? Pokud kladné, tak ho vykresli zelenou barvou, pokud záporné, tak červenou a
pokud nulové, tak černou.</li>
</ul>
<p>V <em>C</em> můžeme provádět takováto rozhodnutí pomocí <strong>podmíněných příkazů</strong> (<em>conditional statements</em>)
<a href="c/rizeni_toku/if.html"><code>if</code></a> a <a href="c/rizeni_toku/switch.html"><code>switch</code></a>, případně pomocí <a href="c/rizeni_toku/ternarni_operator.html">ternárního operátoru</a>.</p>
<h1><a class="header" href="#příkaz-if" id="příkaz-if">Příkaz <code>if</code></a></h1>
<p>Základním příkazem pro tzv. <strong>podmíněné vykonání</strong> kódu je příkaz <code>if</code>:</p>
<pre><code class="language-c">if (&lt;výraz typu bool&gt;) {
    // blok kódu
}
</code></pre>
<p>Pokud se výraz předaný <code>if</code>u vyhodnotí jako <code>true</code> (pravda), tak se provede
<a href="c/rizeni_toku/../promenne/promenne.html#platnost">blok</a> kódu uvnitř <code>if</code>u tak, jak jste zvyklí, a program dále
bude pokračovat za příkazem <code>if</code>. Pokud se však výraz vyhodnotí jako <code>false</code> (nepravda), tak se blok kódu
uvnitř <code>if</code>u vůbec neprovede. V následujícím programu zkuste změnit výraz uvnitř závorek za <code>if</code> tak,
aby se blok v podmínce vykonal:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int delka_hesla = 5;

    printf(&quot;Kontroluji heslo...\n&quot;);
    if (delka_hesla &gt; 5) {
        printf(&quot;Heslo je dost dlouhe\n&quot;);
    }
    printf(&quot;Kontrola hesla dokoncena\n&quot;);

    return 0;
}
</code></pre>
<p>Booleovské výrazy použité v podmíněných příkazech se označují jako <strong>podmínky</strong> (<em>conditions</em>), protože
podmiňují vykonávání programu.</p>
<blockquote>
<p>Anglické slovo <code>if</code> znamená v češtině <code>Jestliže</code>. Všimněte si tak, že kód výše můžete přečíst jako
větu, která bude mít stejný význam jako uvedený <em>C</em> kód: <code>Jestliže je délka hesla větší než pět, tak (proveď kód v bloku)</code>.</p>
</blockquote>
<h3><a class="header" href="#provádění-alternativ" id="provádění-alternativ">Provádění alternativ</a></h3>
<p>Často v programu chceme provést <em>právě jednu</em> ze dvou (nebo více) alternativ, opět v závislosti na hodnotě
nějakého výrazu (podmínky). To sice můžeme provést pomocí několika <code>if</code> příkazů za sebou:</p>
<pre><code class="language-c">if (body &gt; 90) { znamka = 1; }
if (body &lt;= 90 &amp;&amp; body &gt; 80) { znamka = 2; }
if (body &lt;= 80 &amp;&amp; body &gt; 50) { znamka = 3; }
...
</code></pre>
<p>Nicméně to může být často dosti &quot;ukecané&quot;, protože se musíme v každé podmínce ujistit, že již nebyla
splněna předchozí podmínka, jinak by se mohla provést více než jedna alternativa.</p>
<p><em>C</em> tak umožňuje přidat k příkazu <code>if</code> další příkaz, který se provede pouze v případě, že podmínka &quot;<code>if</code>u&quot;
není splněna. Takto lze řetězit více podmínek za sebou, kdy v každé následující podmínce víme, že
žádná z předchozích nebyla splněna. Dosáhneme toho tak, že za blokem podmínky <code>if</code> použijeme klíčové
slovo <code>else</code> (&quot;v opačném případě&quot;):</p>
<pre><code class="language-c">if (&lt;výraz typu bool&gt;) {
    // blok kódu
} else ...
</code></pre>
<p>Pokud za blok podmínky <code>if</code> přidáte <code>else</code>, tak se program začne vykonávat za <code>else</code>, pokud výraz
podmínky není splněn. Za <code>else</code> pak může následovat:</p>
<ul>
<li>
<p>Blok kódu, který se rovnou provede:</p>
<pre><code class="language-c">if (body &gt; 90) {
    // blok A
} else {
    // blok B
}
// X
</code></pre>
<p>Pokud platí <code>body &gt; 90</code>, provede se blok A, pokud ne, tak se provede blok B. V obou případech
bude dále program vykonávat kód od bodu <code>X</code>.</p>
</li>
<li>
<p>Další <code>if</code> podmínka, která je opět vyhodnocena. Takovýchto podmínek může následovat libovolný počet:</p>
<pre><code class="language-c">if (body &gt; 90) {
    // blok A, více než 90 bodů
} else if (body &gt; 80) {
    // blok B, méně než 91 bodů, ale více než 80 bodů
} else if (body &gt; 70) {
    // blok C, méně než 81 bodů, ale více než 70 bodů
}
// X
</code></pre>
<p>Takovéto spojené podmínky se vyhodnocují postupně shora dolů. První podmínka <code>if</code>, jejíž výraz
je vyhodnocen jako <code>true</code>, způsobí, že se provede blok této podmínky, a následně program pokračuje
za celou spojenou podmínkou (bod <code>X</code>).</p>
<p>Na konec spojené podmínky můžete opět vložit i <code>else</code> s blokem bez podmínky. Tento blok se
provede pouze, pokud žádná z předchozích podmínek není splněna:</p>
<pre><code class="language-c">if (body &gt; 90) {
    // blok A, více než 90 bodů
} else if (body &gt; 80) {
    // blok B, méně než 90 bodů, ale více než 80 bodů
} else {
    // blok C, méně než 81 bodů
}
</code></pre>
<p>Všimněte si, že tento kód opět můžeme přečíst jako intuitivní větu. Pokud je počet
bodů vyšší, než 90, tak proveď A. V opačném případě, pokud je vyšší než 80, tak proveď B. Jinak
proveď C.</p>
</li>
</ul>
<hr />
<p><strong>Cvičení</strong>: Upravte následující program, aby vypsal:</p>
<ul>
<li><code>Student uspel s vyznamenanim</code>, pokud je hodnota proměnné <code>body</code> větší než <code>90</code>.</li>
<li><code>Student uspel</code>, pokud je hodnota proměnné <code>body</code> v (uzavřeném) intervalu <code>[51, 90]</code>.</li>
<li><code>Student neuspel</code>, pokud je hodnota proměnné <code>body</code> menší než <code>51</code>.</li>
</ul>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int body = 50;

    printf(&quot;Student uspel\n&quot;);

    return 0;
}
</code></pre>
<hr />
<h3><a class="header" href="#vnořování-podmínek" id="vnořování-podmínek">Vnořování podmínek</a></h3>
<p>Někdy potřebujeme vyhodnotit složitou podmínku (nebo sadu podmínek). Jelikož <code>if</code> je <em>příkaz</em>
a bloky kódu mohou obsahovat libovolné příkazy, tak vám nic nebrání v tom příkazy <code>if</code> <em>vnořovat</em>:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int delka_hesla = 4;
    int delka_jmena = 3;
    if (delka_hesla &gt; 5) {
        if (delka_jmena &gt; 3) {
            printf(&quot;Uzivatel byl zaregistrovan\n&quot;);
        } else {
            printf(&quot;Uzivatelske jmeno neni dostatecne dlouhe\n&quot;);
        }
    } else {
        printf(&quot;Heslo neni dostatecne dlouhe\n&quot;);
    }

    return 0;
}
</code></pre>
<hr />
<p><strong>Cvičení</strong>: Upravte hodnotu proměnných <code>delka_hesla</code> a <code>delka_jmena</code> v programu výše tak, aby program
vypsal <code>Uzivatel byl zaregistrovan</code>. Neměňte v programu nic jiného.</p>
<hr />
<h4><a class="header" href="#vynechání-složených-zárovek" id="vynechání-složených-zárovek">Vynechání složených zárovek</a></h4>
<p>Za <code>if</code> nebo <code>else</code> můžete vynechat složené závorky (<code>{</code>, <code>}</code>). V takovém případě se bude podmínka
vztahovat k (jednomu) příkazu následujícímu za <code>if/else</code>:</p>
<pre><code class="language-c">if (body &gt; 80) printf(&quot;Student uspel\n&quot;);
else printf(&quot;Student neuspel\n&quot;);
</code></pre>
<blockquote>
<p>Zejména ze začátku za podmínkami vždy však raději používejte složené závorky, abyste předešli případným
<a href="c/rizeni_toku/../../caste_chyby/caste_chyby.html#st%C5%99edn%C3%ADk-za-for-while-nebo-if">chybám</a> a učinili kód přehlednějším.</p>
</blockquote>
<h1><a class="header" href="#příkaz-switch" id="příkaz-switch">Příkaz <code>switch</code></a></h1>
<blockquote>
<p>🤓 Tato sekce obsahuje doplňující učivo. Pokud je toho na vás moc, můžete ji prozatím přeskočit
a vrátit se k ní později.</p>
</blockquote>
<p>V případě, že byste chtěli provést rozlišný kód v závislosti na hodnotě nějakého výrazu,
a tento výraz (např. hodnota proměnné) může nabývat většího množství různých hodnot, tak může být
zdlouhavé použít spoustu <code>if</code>ů:</p>
<pre><code class="language-c">if (a == 0) {
    ...
}
else if (a == 1) {
    ...
}
else if (a == 2) {
    ...
}
...
</code></pre>
<p>Jako jistá zkratka může sloužit příkaz <code>switch</code>. Ten má následující syntaxi:</p>
<pre><code class="language-c">switch (&lt;výraz&gt;) {
    case &lt;hodnota A&gt;: &lt;blok kódu&gt;
    case &lt;hodnota B&gt;: &lt;blok kódu&gt;
    case &lt;hodnota C&gt;: &lt;blok kódu&gt;
    ...
}
</code></pre>
<p>Tento příkaz vyhodnotí předaný výraz, a pokud se ve <code>switch</code>i nachází klíčové slovo <code>case</code> následované
hodnotou odpovídající hodnotě výrazu, tak program skočí na blok, který následuje za <code>case</code>. Dále se program
bude vykonávat sekvenčně až do konce <code>switch</code>e (při tomto vykonávání už se <code>case</code> ignoruje)<sup class='margin-toggle sidenote-number'>1</sup>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Toto chování se anglicky označuje jako <em>fallthrough</em>.</p>
</span>
<p>Tento program vypíše <code>52</code>, protože předaný výraz má hodnotu <code>5</code>, takže program skočí na blok za
<code>case 5</code> a dále pokračuje sekvenčně až do konce bloku <code>switch</code> příkazu.</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    switch (5) {
        case 0: printf(&quot;0&quot;);
        case 1: printf(&quot;1&quot;);
        case 5: printf(&quot;5&quot;);
        case 2: printf(&quot;2&quot;);
    }

    return 0;
}
</code></pre>
<h2><a class="header" href="#klíčové-slovo-default" id="klíčové-slovo-default">Klíčové slovo <code>default</code></a></h2>
<p>Do <code>switch</code>e lze předat i blok pojmenovaný <code>default</code>, na který program skočí v případě, že se
nenalezne žádný <code>case</code> s odpovídající hodnotou:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    switch (10) {
        case 0: printf(&quot;0&quot;);
        case 1: printf(&quot;1&quot;);
        case 5: printf(&quot;5&quot;);
        case 2: printf(&quot;2&quot;);
        default: printf(&quot;nenalezeno&quot;);
    }

    return 0;
}
</code></pre>
<h2><a class="header" href="#klíčové-slovo-break" id="klíčové-slovo-break">Klíčové slovo <code>break</code></a></h2>
<p>Velmi často chcete provést pouze jeden blok kódu u jednoho <code>case</code> a nepokračovat po něm až do konce
celého <code>switch</code> bloku. Běžně se tedy za každým <code>case</code> blokem používá příkaz <code>break</code>, který ukončí
provádějí celého <code>switch</code> příkazu:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    switch (1) {
        case 0: printf(&quot;0&quot;); break;
        case 1: printf(&quot;1&quot;); break;
        case 2: printf(&quot;2&quot;); break;
        default: printf(&quot;nenalezeno&quot;);
    }

    return 0;
}
</code></pre>
<h2><a class="header" href="#použití-příkazu-switch" id="použití-příkazu-switch">Použití příkazu <code>switch</code></a></h2>
<p>Příkaz <code>switch</code> lze použít pouze s vestavěnými datovými typy, zejména s čísly. Nelze jej použít např.
na porovnávání <a href="c/rizeni_toku/../struktury/struktury.html">struktur</a> či <a href="c/rizeni_toku/../text/retezce.html">řetězců</a>. Jeho chování
také může být ze začátku matoucí, pokud za jednotlivými <code>case</code> konstrukcemi nepoužijete příkaz <code>break</code>.
Proto tak doporučujeme ze začátku používat pro podmíněné vykonávání spíše příkaz <a href="c/rizeni_toku/if.html"><code>if</code></a>.</p>
<h1><a class="header" href="#ternární-operátor" id="ternární-operátor">Ternární operátor</a></h1>
<blockquote>
<p>🤓 Tato sekce obsahuje doplňující učivo. Pokud je toho na vás moc, můžete ji prozatím přeskočit
a vrátit se k ní později.</p>
</blockquote>
<p>Občas chcete použít jeden ze dvou výrazů v závislosti na hodnotě nějaké podmínky. Například pokud byste
chtěli přiřadit minimum ze dvou hodnot do proměnné:</p>
<pre><code class="language-c">int a = 1;
int b = 5;

int c = 0;
if (a &lt; b) {
    c = a;
} else {
    c = b;
}
</code></pre>
<p>Toto lze provést zkráceně pomocí výrazu <strong>ternárního operátoru</strong> (<em>ternary operator</em>). Tento výraz
má následující syntaxi:</p>
<pre><code class="language-c">&lt;výraz X typu bool&gt; ? &lt;výraz A&gt; : &lt;výraz B&gt;
</code></pre>
<p>Pokud je výraz <code>X</code> pravdivý, tak se ternární operátor vyhodnotí jako hodnota výrazu <code>A</code>, v opačném
případě se vyhodnotí jako hodnota výrazu <code>B</code>. Uhodnete, co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1;
    int b = 5;
    int c = (a &gt;= b) ? a - b : a + b;
    printf(&quot;%d\n&quot;, c);

    return 0;
}
</code></pre>
<h1><a class="header" href="#cykly" id="cykly">Cykly</a></h1>
<p>Ve svých programech budete často chtít provádět nějakou operaci opakovaně, například:</p>
<ul>
<li>Pro každý záznam v databázi vypiš řádek do souboru.</li>
<li>Pošli zprávu každému účastníkovi chatu.</li>
<li>Načítej řádky ze souboru, dokud nedojdeš na konec souboru.</li>
</ul>
<p>Pokud bychom používali pouze sekvenční zápis příkazů, tak bychom museli neustále kopírovat
(&quot;copy-pastovat&quot;) kód:</p>
<pre><code class="language-c">printf(&quot;0\n&quot;);
printf(&quot;1\n&quot;);
printf(&quot;2\n&quot;);
...
</code></pre>
<p>což by vedlo k nepřehledným programům<sup class='margin-toggle sidenote-number'>1</sup>. Pokud bychom navíc našli v programu chybu, museli bychom ji
opravit na všech místech, kam jsme kód zkopírovali.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Představte si, že chcete na výstup programu nebo do souboru vypsat třeba tisíc různých řádků textu.</p>
</span>
<p>Ani s kopírováním kódu bychom si však nevystačili, pokud bychom potřebovali provádět kód opakovaně
v závislosti na vstupu programu. Představte si situaci, kdy nám uživatel na vstup programu zadá číslo,
kolikrát má náš program vypsat nějaký řádek textu na výstup. Uživatel se při každém spuštění programu
může rozhodnout pro jiné číslo, <code>0</code>, <code>1</code>, <code>42</code>, <code>1000</code>. Program však zůstává stále stejný - při jeho
psaní se musíme rozhodnout, kolik příkazů pro výpis v něm použijeme, a už poté nemůžeme jednoduše
tuto volbu změnit, když program běží. Takovýto program bychom tedy zatím (pouze pomocí proměnných a
podmínek) neměli jak naprogramovat. </p>
<p>Proto programovací jazyky nabízí tzv. <strong>cykly</strong> (<em>loops</em>), pomocí kterých můžeme jednoduše říct
počítači, aby určitý blok kódu opakoval, kolikrát budeme chtít. Díky tomu může program i s pouze
několika málo řádky kódu říct počítači, aby provedl spoustu instrukcí. Jazyk <em>C</em> nabízí dva základní
typy cyklů, <a href="c/rizeni_toku/while.html">while</a> a <a href="c/rizeni_toku/for.html">for</a>.</p>
<blockquote>
<p>Další motivací pro využití cyklů je to, že moderní procesory počítačů mají běžně frekvence od
1 do 4 GHz, takže za vteřinu zvládnou provést několik miliard
<a href="https://cs.wikipedia.org/wiki/Hodinov%C3%BD_sign%C3%A1l">taktů</a> a během každého taktu navíc až
<a href="https://cs.wikipedia.org/wiki/Superskal%C3%A1rn%C3%AD_architektura">desítky</a> různých operací.
Jistě si dovedete představit, že s pouze sekvenčním zápisem kódu bychom tento potenciál nemohli
naplno využít. I když jeden řádek <em>C</em> kódu může být přeložen až na desítky procesorových instrukcí,
tak i kdybychom zvládli napsat program se stovkami milionů řádek, pořád bychom takovýmto programem
&quot;zabavili&quot; procesor na pouhou vteřinu. Běžící programy tak obvykle tráví většinu času právě
prováděním nějakého cyklu.</p>
</blockquote>
<h1><a class="header" href="#cyklus-while" id="cyklus-while">Cyklus <code>while</code></a></h1>
<p>Nejjednodušším cyklem v <em>C</em> je cyklus <code>while</code> (&quot;dokud&quot;):</p>
<pre><code class="language-c">while (&lt;výraz typu bool&gt;) {
    // blok cyklu
}
</code></pre>
<p>Funguje následovně:</p>
<ol>
<li>Nejprve se vyhodnotí (Booleovský) výraz v závorce za <code>while</code>.</li>
<li>Pokud:
<ul>
<li>Je výraz pravdivý, tak se provede blok<sup class='margin-toggle sidenote-number'>1</sup> cyklu a dále se pokračuje opět bodem 1.<span class='sidenote'><p><sup class='number'>1</sup><a href="c/rizeni_toku/../promenne/promenne.html#platnost">Blok</a> cyklu se také často nazývá jako <strong>tělo</strong> (<em>body</em>) cyklu.</p>
</span></li>
<li>Není výraz pravdivý, tak se provede bod 3.</li>
</ul>
</li>
<li>Program pokračuje za cyklem <code>while</code>.</li>
</ol>
<p>Jinak řečeno, dokud bude splněná podmínka za <code>while</code>, tak se bude opakovaně provádět tělo cyklu.
Vyzkoušejte si to na následujícím příkladu:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pocet = 0;
    while (pocet &lt; 5) {
        printf(&quot;Telo cyklu se provedlo, hodnota promenne pocet=%d\n&quot;, pocet);
        pocet = pocet + 1;
    }
    return 0;
}
</code></pre>
<p>Tento kód opět můžeme přečíst jako větu: <code>Dokud je hodnota proměnné pocet menší než pět, prováděj tělo cyklu</code>. Jedno vykonání těla cyklu se nazývá <strong>iterace</strong>. Cyklus v ukázce výše tedy provede pět iterací,
protože se tělo cyklu provede pětkrát.</p>
<p>Pokud výraz za <code>while</code> není vyhodnocen jako pravdivý v momentě, kdy se <code>while</code> začne vykonávat, tak
se tělo cyklu nemusí provést ani jednou (tj. bude mít nula iterací).</p>
<p>Je důležité dávat si pozor na to, aby cyklus, který použijeme, nebyl nechtěně <strong>nekonečný</strong>
(<em>infinite loop</em>), jinak by náš program nikdy neskončil. Zkuste v kódu výše zakomentovat nebo odstranit
řádek <code>pocet = pocet + 1;</code> a zkuste program spustit. Jelikož se hodnota proměnné <code>pocet</code> nebude nijak
měnit, tak výraz <code>pocet &lt; 5</code> bude stále pravdivý a cyklus se tak bude provádět neustále dokola.
Této situaci se lidově říká &quot;zacyklení&quot;<sup class='margin-toggle sidenote-number'>2</sup>.</p>
<span class='sidenote'><p><sup class='number'>2</sup>Pokud program spouštíte v terminálu a zacyklí se, můžete ho přerušit pomocí klávesové zkratky <code>Ctrl + C</code>.
Pokud jej spustíte v prohlížeči, tak poté radši restartujte tuto stránku pomocí <code>F5</code> :)</p>
</span>
<blockquote>
<p>Pokud se vám někdy stalo, že se program, který jste zrovna používali, &quot;zaseknul&quot; a přestal reagovat
na váš vstup, mohlo to být právě například tím, že v něm nechtěně došlo k provedení nekonečného
cyklu (došlo k tzv. &quot;zacyklení&quot;).</p>
</blockquote>
<h3><a class="header" href="#Řídící-proměnná" id="Řídící-proměnná">Řídící proměnná</a></h3>
<p>Často chceme provést v těle cyklu různé příkazy, v závislosti na tom, která iterace se zrovna vykonává.
K tomu obvykle slouží tzv. <strong>řídící proměnná</strong> (<em>index variable</em>), která udává, v jaké iteraci cyklu
se nacházíme, a podle ní se poté provede odpovídající operace. Například pokud chceme něco provést
pouze v první iteraci cyklu, můžeme použít <a href="c/rizeni_toku/podminky.html">podmínku</a>, ve které zkontrolujeme aktuální
hodnotu řídící proměnné:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int i = 0;
    while (i &lt; 5) {
        if (i == 0) {
            printf(&quot;Prvni iterace\n&quot;);
        }
        printf(&quot;Hodnota i=%d\n&quot;, i);
        i += 1;
    }
    return 0;
}
</code></pre>
<p>Řídící proměnná je zde <code>i</code> - tento název se pro řídící proměnné pro jednoduchost často používá.</p>
<hr/>
<p><strong>Cvičení</strong>: Upravte kód výše tak, aby program vypsal <code>Posledni iterace</code> při provádění poslední
iterace cyklu. Zkuste poté kód upravit tak, aby fungoval pro libovolný počet iterací (tj.
ať už bude počet iterací libovolný, kód samotného cyklu musí zůstat stejný).</p>
<hr/>
<h3><a class="header" href="#Řízení-toku-cyklu" id="Řízení-toku-cyklu">Řízení toku cyklu</a></h3>
<p>V cyklech můžete využít dva speciální příkazy, které fungují pouze uvnitř těla (bloku kódu) nějakého
cyklu:</p>
<ul>
<li>Příkaz <code>continue;</code> způsobí, že se přestane vykonávat tělo cyklu, a program bude pokračovat ve
vykonávání na začátku cyklu (tedy u <code>while</code> na vyhodnocení výrazu). <code>continue</code> lze chápat jako skok
na další iteraci cyklu. Zkuste uhodnout, co vypíše následující kód:
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pocet = 0;
    while (pocet &lt; 10) {
        pocet = pocet + 1;

        if (pocet &lt; 5) {
            continue;
        }

        printf(&quot;Hodnota: %d\n&quot;, pocet); 
    }

    return 0;
}
</code></pre>
</li>
<li>Příkaz <code>break;</code> způsobí, že se cyklus přestane vykonávat a program začne vykonávat kód, který
následuje za cyklem. Cyklus se tak zcela přeruší. Zkuste uhodnout, co vypíše následující kód:
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pocet = 0;
    while (pocet &lt; 10) {
        if (pocet * 2 &gt; 12) {
            break;
        }

        printf(&quot;Hodnota: %d\n&quot;, pocet);
        pocet = pocet + 1;
    }

    return 0;
}
</code></pre>
</li>
</ul>
<details>
<summary>Tip pro návrh cyklů while</summary>
<p>Příkaz <code>break</code> lze také někdy použít k usnadnění návrhu cyklů. Pokud potřebujete napsat <code>while</code> cyklus
s nějakou složitou podmínkou ukončení, ze které se vám motá hlava, zkuste nejprve vytvořit &quot;nekonečný&quot;
cyklus pomocí <code>while (true) { … }</code>, dále vytvořte tělo cyklu a až nakonec vymyslete podmínku,
která cyklus ukončí pomocí příkazu <code>break</code>:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pocet = 0;
    int pocet2 = 1;
    while (1) {
        printf(&quot;Hodnota: %d\n&quot;, pocet);
        pocet = pocet + 1;
        pocet2 += pocet * 2;

        if (pocet &gt; 10) break;
        if (pocet2 &gt; 64) break;
    }

    return 0;
}
</code></pre>
<p>Nemusíte tak hned ze začátku vymýšlet výraz pro <code>while</code>, na čemž byste se mohli zaseknout. </p>
<p>Místo <code>while (true)</code> můžete použít také <code>while (1)</code>, protože <code>1</code> se při převodu na <code>bool</code> převede
na <code>true</code>.</p>
</details>
<h3><a class="header" href="#vnořování-cyklů" id="vnořování-cyklů">Vnořování cyklů</a></h3>
<p>Stejně jako podmínky, i cykly jsou příkazy, a můžete je tak používat libovolně v blocích <em>C</em> kódu
a také je <a href="c/rizeni_toku/if.html#vno%C5%99ov%C3%A1n%C3%AD-podm%C3%ADnek">vnořovat</a>. Chování vnořených cyklů může být ze začátku
trochu neintuitivní, proto je dobré si je procvičit. Zkuste si pomocí
<a href="c/rizeni_toku/../../prostredi/ladeni.html#krokov%C3%A1n%C3%AD">debuggeru</a> krokovat následující kód, abyste pochopili, jak se
provádí, a zkuste odhadnout, jakých hodnot budou postupně nabývat proměnné <code>i</code> a <code>j</code>. Poté odkomentujte
výpisy <code>printf</code> a ověřte, jestli byl váš odhad správný:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int i = 0;
    while (i &lt; 3) {
        // printf(&quot;i: %d\n&quot;, i);
        int j = 0;
        while (j &lt; 4) {
            // printf(&quot;  j: %d\n&quot;, j);
            j = j + 1;
        }

        i = i + 1;
    }

    return 0;
}
</code></pre>
<p>Pro každou iteraci &quot;vnějšího&quot; <code>while</code> cyklu se provedou čtyři iterace &quot;vnitřního&quot; <code>while</code> cyklu.
Dohromady se tak provede celkem <code>3 * 4</code> iterací.</p>
<h3><a class="header" href="#cyklus-do-while" id="cyklus-do-while">Cyklus <code>do while</code></a></h3>
<p>Cyklus <code>while</code> má také alternativu zvanou <code>do while</code>. Tento cyklus má následující syntaxi:</p>
<pre><code class="language-c">do {
    // tělo cyklu
}
while (&lt;výraz typu bool&gt;);
</code></pre>
<p>Tento kód můžeme číst jako <code>Prováděj &lt;tělo cyklu&gt;, dokud platí &lt;výraz&gt;</code>.</p>
<p>Jediný rozdíl mezi <code>while</code> a <code>do while</code> je ten, že v cyklu <code>do while</code> se výraz, který určuje, jestli
se má provést další iterace cyklu, vyhodnocuje až na konci cyklu. Tělo cyklu tak bude pokaždé provedeno
alespoň jednou (i kdyby byl výraz od začátku nepravdivý).</p>
<p>Pokud pro to nemáte zvláštní důvod, asi není třeba tento typ cyklu používat.</p>
<h1><a class="header" href="#cyklus-for" id="cyklus-for">Cyklus <code>for</code></a></h1>
<p>V programech velmi často potřebujeme vykonat nějaký blok kódu přesně <code>n</code>-krát:</p>
<ul>
<li>Projdi <code>n</code> řádků ze vstupního souboru a sečti jejich hodnoty.</li>
<li>Pošli zprávu všem <code>n</code> účastníkům chatu.</li>
<li>Vystřel přesně třikrát ze zbraně.</li>
</ul>
<p>I když pomocí cyklu <code>while</code> můžeme vyjádřit provedení <code>n</code> iterací, je to relativně zdlouhavé,
protože je k tomu potřeba alespoň tří řádků kódu:</p>
<ul>
<li>Inicializace cyklu: vytvoření řídící proměnné, která se bude kontrolovat v cyklu</li>
<li>Kontrola výrazu: kontrola, jestli už proměnná dosáhla požadované hodnoty</li>
<li>Operace na konci cyklu: změna hodnoty řídící proměnné</li>
</ul>
<pre><code class="language-c">int i = 0; // inicializace
while (i &lt; 10) { // kontrola výrazu
    // tělo cyklu
    i += 1; // změna hodnoty řídící proměnné
}
</code></pre>
<p>Cyklus <code>for</code> existuje, aby tuto častou situaci zjednodušil. Kód výše by se dal pomocí cyklu <code>for</code>
přepsat takto:</p>
<pre><code class="language-c">for (int i = 0; i &lt; 10; i += 1) {
    // tělo cyklu
}
</code></pre>
<p>Jak lze vidět, <code>for</code> cyklus v sobě kombinuje inicializaci cyklu, kontrolu výrazu a provedení příkazu
po každé iteraci. Obecná syntaxe tohoto cyklu vypadá takto:</p>
<pre><code class="language-c">for (&lt;příkaz A&gt;; &lt;výraz typu bool&gt;; &lt;příkaz B&gt;) {
    // tělo cyklu
}
</code></pre>
<p>Takovýto cyklus se vykoná následovně:</p>
<ol>
<li>Jakmile se cyklus začne vykonávat, nejprve se provede příkaz <code>A</code>. Zde se typicky vytvoří
řídící proměnná s nějakou počáteční hodnotou.</li>
<li>Zkontroluje se výraz. Pokud není pravdivý, cyklus končí a program pokračuje za cyklem <code>for</code>.
Pokud je pravdivý, provede se tělo cyklu a program pokračuje bodem 3.</li>
<li>Provede se příkaz <code>B</code> a program pokračuje bodem 2.</li>
</ol>
<hr/>
<p><strong>Cvičení</strong>:</p>
<ul>
<li>Napište program, který pomocí cyklu <code>for</code> na výstup vypíše čísla od 0 do 9 (včetně).</li>
<li>Vypište na výstup řádek <code>Licha iterace</code> v každé liché iteraci cyklu a řádek <code>Suda iterace</code> v každé
sudé iteraci tohoto cyklu.</li>
</ul>
<hr/>
<h1><a class="header" href="#funkce" id="funkce">Funkce</a></h1>
<p>Zatím jsme veškerý kód psali pouze na jedno místo v programu, do <a href="c/funkce/../../ruzne/funkce_main.html">&quot;mainu&quot;</a>.
Jakmile programy začnou být větší a větší, tak začne také být neustále těžší a těžší se v nich zorientovat
a udržet je celé v hlavě, abychom nad nimi mohli přemýšlet. Zároveň se nám v programu brzy začnou
objevovat úseky kódu, které jsou téměř totožné, ale liší se v drobných detailech. Chtěli bychom tak
mít možnost takovýto kód napsat pouze jednou a tyto měnící se detaily do něj pouze &quot;dosadit&quot;.
K rozdělení kódu programu do sady ucelených částí a jejich parametrizaci slouží <strong>funkce</strong> (<em>functions</em>).</p>
<p>Funkce je pojmenovaný blok kódu, na který se můžeme odkázat v jiné části programu a vykonat tak
kód, který se ve funkci nachází. S jednou funkcí už jsme se setkali. Jedná se o funkci <code>main</code>, jejíž
kód je proveden při spuštění programu. My si nicméně můžeme vytvořit vlastní funkce. Zde je
příklad vytvoření, tj. <strong>definice</strong> (<em>definition</em>) jednoduché funkce s názvem<sup class='margin-toggle sidenote-number'>1</sup> <code>vypis_text</code>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Pravidla pro pojmenovávání funkcí jsou totožná s pravidly pro
<a href="c/funkce/../promenne/pojmenovavani.html">pojmenovávání proměnných</a>.</p>
</span>
<pre><code class="language-c">void vypis_text() {
    printf(&quot;Ahoj\n&quot;);
}
</code></pre>
<p>Před názvem funkce je nutné uvést datový typ (zde je uveden typ <code>void</code>). <a href="c/funkce/funkce.html#n%C3%A1vratov%C3%A1-hodnota-funkc%C3%AD">Níže</a>
bude vysvětleno, k čemu tento typ slouží.</p>
<p>Tento blok<sup class='margin-toggle sidenote-number'>2</sup> kódu se přeloží na instrukce a bude existovat v přeloženém programu stejně jako funkce
<code>main</code>, nicméně sám o sobě se nezačne provádět. Abychom kód této funkce provedli, musíme ji tzv.
<strong>zavolat</strong> (<em>call</em>). To provedeme tak, že napíšeme název této funkce a za něj dáme
závorky (<code>()</code>):</p>
<span class='sidenote'><p><sup class='number'>2</sup>Stejně jako u <a href="c/funkce/../rizeni_toku/while.html">cyklů</a> se bloku kódu funkce často říká <strong>tělo funkce</strong> (<em>function body</em>).</p>
</span>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

void vypis_text() {
    printf(&quot;Ahoj\n&quot;);
}
int main() {
    vypis_text(); // zavolání funkce vypis_text
    return 0;
}
</code></pre>
<p>Zavolání funkce je výraz, při jehož vyhodnocení dojde k provedení kódu funkce, která se volá.
Když se v programu nahoře ve funkci <code>main</code> vykoná řádek <code>vypis_text();</code>, tak se začne vykonávat kód
funkce <code>vypis_text</code>. Jakmile se příkazy z této funkce vykonají, tak program bude pokračovat ve funkci
<code>main</code>.</p>
<p>Pomocí volání funkcí můžeme mít kus kódu v programu zapsán pouze jednou ve funkci, a poté ho
můžeme spouštět z různých částí programu, podle toho, kdy se nám to zrovna bude hodit.</p>
<blockquote>
<p>Funkce <code>main</code> je zavolána při spuštění programu, čímž dojde k tomu, že se začnou vykonávat její
příkazy.</p>
</blockquote>
<h2><a class="header" href="#parametrizace-funkcí" id="parametrizace-funkcí">Parametrizace funkcí</a></h2>
<p>Funkcím můžeme přiřadit vstupy zvané <strong>parametry</strong> (<em>parameters</em>). Parametry jsou proměnné dostupné
uvnitř funkce, jejichž hodnotu nastavujeme při zavolání dané funkce. Například následující funkce
<code>vypis_cislo</code> má parametr <code>cislo</code> s datovým typem <code>int</code>.</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void vypis_cislo(int cislo) {
    printf(&quot;Cislo: %d\n&quot;, cislo);
}
int main() {
    vypis_cislo(5);
    return 0;
}
</code></pre>
<p>Při zavolání funkce musíme pro každý její parametr do závorek dát hodnotu odpovídajícího datového typu.
Zde je jediný parameter typu <code>int</code>, takže při zavolání této funkce musíme do závorek dát jednu hodnotu
datového typu <code>int</code>: <code>vypis_cislo(5)</code>. Před spuštěním příkazů ve funkci dojde k tomu, že se každý
parametr nastaví na hodnotu předanou při volání funkce<sup class='margin-toggle sidenote-number'>3</sup>. Při zavolání <code>vypis_cislo(5)</code> si tak můžete
představit, že se vykoná následující kód:</p>
<span class='sidenote'><p><sup class='number'>3</sup>Hodnoty (výrazy) předávané při volání funkce se nazývají <strong>argumenty</strong> (<em>arguments</em>). Při
volání <code>vypis_cislo(5)</code> se tedy do parametru <code>cislo</code> nastaví hodnota argumentu <code>5</code>.</p>
</span>
<pre><code class="language-c">{
    // nastavení hodnot parametrů
    int cislo = 5;

    // tělo funkce
    printf(&quot;Cislo: %d\n&quot;, cislo); 
}
</code></pre>
<p>Je důležité si uvědomit, že při každém zavolání funkce můžeme použít různé hodnoty argumentů:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void vypis_cislo(int cislo) {
    printf(&quot;Cislo: %d\n&quot;, cislo);
    if (cislo &lt; 0) {
        printf(&quot;Predane cislo je zaporne\n&quot;);
    } else {
        printf(&quot;Predane cislo je nezaporne\n&quot;);
    }
}
int main() {
    vypis_cislo(5);
    vypis_cislo(1 + 8);

    int x = -10;
    vypis_cislo(x);

    return 0;
}
</code></pre>
<p>Parametrů mohou funkce brát libovolný počet, nicméně obvykle se používají jednotky (maximálně cca 5)
parametrů, aby funkce a její používání (volání) nebylo příliš složité. Jednotlivé parametry jsou
odděleny v definici funkce i v jejím volání čárkami:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void vypis_cisla(int a, int b) {
    printf(&quot;Cislo a: %d\n&quot;, a);
    printf(&quot;Cislo b: %d\n&quot;, b);
}
int main() {
    vypis_cisla(5 + 5, 11 * 2);
    return 0;
}
</code></pre>
<p>Pomocí parametrů můžeme vytvořit kód, který není &quot;zadrátovaný&quot; na konkrétní hodnoty, ale umí pracovat
s libovolnou hodnotou vstupu. Díky toho lze takovou funkci využít v různých situacích bez toho, abychom
její kód museli kopírovat. Příklady použití parametrů funkcí:</p>
<ul>
<li>Funkci <code>vypis_ctverec</code>, která přijme jako parametr číslo <code>n</code> a vypíše na výstup čtverec tvořený
znaky <code>x</code> o straně <code>n</code>.</li>
<li>Funkci <code>vykresli_pixel</code>, která přijme jako parametry souřadnici na obrazovce a barvu a vykreslí
na obrazovce na dané pozici pixel s odpovídající barvou.</li>
</ul>
<hr />
<p><strong>Cvičení</strong>: Zkuste naprogramovat funkci <code>vypis_ctverec</code>. Další zadání jednoduchých funkcí naleznete
<a href="c/funkce/../../ulohy/zaklady.html#fibonacciho-%C4%8D%C3%ADslo">zde</a>.</p>
<hr />
<h2><a class="header" href="#návratová-hodnota-funkcí" id="návratová-hodnota-funkcí">Návratová hodnota funkcí</a></h2>
<p>Nejenom, že funkce mohou přijímat vstup, ale umí také vracet výstup. Datový typ uvedený před názvem
funkce udává, jakého typu bude tzv. <strong>návratová hodnota</strong> (<em>return value</em>) dané funkce. V příkladech
výše jsme viděli datový typ <code>void</code>. Tento datový typ je speciální, protože říká, že funkce nebude
vracet <em>nic</em>. Pokud funkce má návratový typ <code>void</code>, tak nevrací žádnou hodnotu - pokud zavoláme
takovouto funkci, tak se sice provede její kód, ale výraz zavolání nevrátí žádnou hodnotu:</p>
<pre><code class="language-c editable">void funkce() {}

int main() {
    // chyba při překladu, funkce nic nevrací
    int x = funkce();
    return 0;
}
</code></pre>
<p>Často bychom nicméně chtěli funkci, která přijme nějaké hodnoty (parametry), vypočte nějakou hodnotu
a poté ji vrátí. Toho můžeme dosáhnout tak, že funkci dáme návratový typ jiný než <code>void</code> a poté
ve funkci použijeme příkaz <code>return &lt;výraz&gt;;</code>. Při provedení tohoto výrazu
se přestane funkce vykonávat a její volání se vyhodnotí hodnotou předaného výrazu. Zde je příklad
funkce, která bere jako vstup jedno číslo a spočítá jeho třetí mocninu:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int treti_mocnina(int cislo) {
   return cislo * cislo * cislo;
}
int main() {
   printf(&quot;%d\n&quot;, treti_mocnina(5 + 1));
   return 0;
}
</code></pre>
<blockquote>
<p>Jak probíhá vyhodnocování funkcí si můžete procvičit <a href="c/funkce/../../ruzne/vyhodnocovani_vyrazu.html">zde</a>.</p>
</blockquote>
<p>Příkazů <code>return</code> může být ve funkci více:</p>
<pre><code class="language-c">int absolutni_hodnota(int cislo) {
    if (cislo &gt;= 0) {
        return cislo;
    }
    return -cislo;
}
</code></pre>
<p>Nicméně je důležité si uvědomit, že po provedení příkazu <code>return</code> už funkce dále nebude pokračovat:</p>
<pre><code class="language-c">int zvetsi(int cislo) {
    return cislo + 1;
    printf(&quot;Provadi se funkce zvetsi\n&quot;); // tento řádek se nikdy neprovede
}
</code></pre>
<blockquote>
<p>Pokud má funkce jakýkoliv jiný návratový typ než <code>void</code>, tak v ní musí být vždy proveden příkaz
<code>return</code>! Pokud k tomu nedojde, tak program může začít vykazovat <a href="c/funkce/../promenne/promenne.html#v%C5%BEdy-inicializujte-prom%C4%9Bnn%C3%A9">nedefinované chování</a>
💣 a může se tak chovat nepředvídatelně. Například následující funkce je špatně, protože pokud hodnota
parametru <code>cislo</code> bude nezáporná, tak se ve funkci neprovede příkaz <code>return</code>:</p>
<pre><code class="language-c">int absolutni_hodnota(int cislo) {
    if (cislo &lt; 0) {
      return -cislo;
    }
}
</code></pre>
</blockquote>
<p>Pokud má funkce návratový typ <code>void</code>, tak její provádění můžeme ukončit pomocí příkazu <code>return;</code>
(zde nepředáváme žádný výraz, protože funkce nic nevrací).</p>
<h2><a class="header" href="#syntaxe" id="syntaxe">Syntaxe</a></h2>
<p>Syntaxe funkcí v <em>C</em> vypadá takto:</p>
<pre><code class="language-c">&lt;datový typ&gt; &lt;název funkce&gt;(&lt;dat. typ par. 1&gt; &lt;název par. 1&gt;, &lt;dat. typ par. 2&gt; &lt;název par. 2&gt;, …) {
    // blok kódu
} 
</code></pre>
<p>Datovému typu, názvu funkce a jejím parametrům se dohromady říká <strong>signatura</strong> (<em>signature</em>) funkce.
Abychom věděli, jak s danou funkcí pracovat (jak ji volat), tak nám stačí znát její signaturu,
nemusíme nutné znát obsah jejího těla.<sup class='margin-toggle sidenote-number'>4</sup></p>
<span class='sidenote'><p><sup class='number'>4</sup>Tento fakt bude důležitý <a href="c/funkce/../modularizace/pouzivani_kodu_z_jinych_souboru.html#deklarace-vs-definice">později</a>.</p>
</span>
<h2><a class="header" href="#výhody-funkcí" id="výhody-funkcí">Výhody funkcí</a></h2>
<p>Zde je pro zopakování uveden přehled výhod používání funkcí:</p>
<ul>
<li><strong>Znovupoužitelnost kódu</strong> Pokud chcete stejný kód použít na více místech programu, nemusíte ho
&quot;copy-pastovat&quot;. Stačí ho vložit do funkce a tu poté opakovaně volat.</li>
<li><strong>Parametrizace kódu</strong> Pokud chcete spouštět stejný kód s různými vstupními hodnotami, stačí udělat
funkci, která dané hodnoty přijme jako parametry (a případně vrátí výsledek výpočtu jako svou
návratovou hodnotu).</li>
<li><strong>Abstrakce</strong> Když rozdělíte logiku programu do sady funkcí, tak si značně usnadníte přemýšlení nad
celým programem. Jednotlivé funkce budete moct testovat a přemýšlet nad nimi separátně, nezávisle na
zbytku programu. Pomocí používání funkcí také bude mnohem přehlednější čtení programu, protože bude
stačit číst, co se provádí (která funkce se volá) a ne jak se to provádí (jaké příkazy jsou v těle
funkce). Takovýhle kód pak lze číst téměř jako větu v přirozeném jazyce:
<pre><code class="language-c">int zivot = vrat_zivoty_hrace(id_hrace);
zivot = zivot - vypocti_zraneni_prisery(id_prisery);
nastav_zivoty_hrace(id_hrace, zivot);
</code></pre>
</li>
<li><strong>Sdílení kódu</strong> Pokud budete chtít použít kód, který napsal někdo jiný, tak toho můžete dosáhnout
právě používáním funkcí, které vám někdo <a href="c/funkce/../modularizace/knihovny.html">nasdílí</a>.</li>
</ul>
<h2><a class="header" href="#umístění-funkcí" id="umístění-funkcí">Umístění funkcí</a></h2>
<p>Funkce v <em>C</em> musíme psát vždy na nejvyšší úrovni souboru. V <em>C</em> tedy například není možné definovat
funkci uvnitř jiné funkce:</p>
<pre><code class="language-c editable readonly">int main() {
    int test() { }
}
</code></pre>
<h2><a class="header" href="#proč-název-funkce" id="proč-název-funkce">Proč název &quot;funkce&quot;?</a></h2>
<p>Možná vás napadlo, že název funkce zní podobně jako <a href="https://matematika.cz/co-je-to-funkce">funkce</a>
v matematice. Není to náhoda, funkce v programech se tak opravdu dají částečně chápat – berou nějaký
vstup (parametry) a vracejí výstup (návratovou hodnotu). Například následující matematickou funkci:</p>
<p>\( f(x) = 2 * x \)</p>
<p>můžeme v <em>C</em> naprogramovat takto:</p>
<pre><code class="language-c">int f(int x) {
    return 2 * x;
}
</code></pre>
<p>Aby ale funkce v <em>C</em> splňovala požadavky matematické funkce, musí být splněno několik podmínek:</p>
<ul>
<li>Funkce nesmí mít žádné <a href="c/funkce/../prikazy_vyrazy.html#vedlej%C5%A1%C3%AD-efekty">vedlejší efekty</a>. To znamená, že by
měla pouze provést výpočet na základě vstupních parametrů a vrátit vypočtenou hodnotu. Neměla by
číst ani modifikovat <a href="c/funkce/../promenne/globalni_promenne.html">globální proměnné</a> nebo například pracovat
se soubory na disku či komunikovat po síti.</li>
<li>Funkce musí mít návratový typ jiný než <code>void</code>, aby vracela nějakou hodnotu. Z toho také vyplývá,
že funkce s návratovým typem <code>void</code> by měla mít nějaké vedlejší efekty, jinak by totiž nemělo
smysl ji volat (protože nic nevrací).</li>
<li>Pokud je funkce zavolána se stejnými hodnotami parametrů, musí vždy vrátit stejnou návratovou
hodnotu. Této vlastnosti se říká <em>idempotence</em>. Jelikož jsou počítače deterministické, tato
vlastnost by měla být triviálně splněna, pokud funkce neobsahuje žádné vedlejší efekty.</li>
</ul>
<p>Funkce splňující tyto vlastnosti se nazývají <em>čisté</em> (<em>pure</em>). S takovýmito funkcemi je jednodušší
pracovat a přemýšlet nad tím, co dělají, protože si můžeme být jistí, že nemodifikují okolní stav
programu a pouze spočítají výsledek v závislosti na svých parametrech. Pokud to tedy jde, snažte se
funkce psát tímto stylem (samozřejmě ne vždy je to možné).</p>
<p>V předmětu
<a href="http://behalek.cs.vsb.cz/wiki/index.php/Functional_programming/cs">Funkcionální programování</a>
budete pracovat s funkcionálními programovacími jazyky, ve kterých je právě většina funkcí čistých.</p>
<h1><a class="header" href="#rekurze" id="rekurze">Rekurze</a></h1>
<p>Pokud funkce obsahuje volání sama sebe, tak tuto situaci nazýváme <strong>rekurzí</strong> (<em>recursion</em>).
Pro řešení některých problémů může být přirozené rozdělovat je na čím dál tím menší podproblémy,
dokud se nedostaneme k podproblému, který je dostatečně jednoduchý, abychom ho vyřešili rovnou.
Toto můžeme modelovat právě rekurzí, kdy voláme stejnou funkci s různými argumenty, dokud se
nedostaneme k hodnotám, pro které umíme problém vyřešit jednoduše, a v ten moment rekurzi ukončíme.</p>
<p>Jedním z jednoduchých problémů, na kterém můžeme rekurzi demonstrovat, je výpočet
<a href="https://cs.wikipedia.org/wiki/Faktori%C3%A1l">faktoriálu</a>. Faktoriál lze nadefinovat například takto:</p>
<p>\(n! = n * (n - 1)!\)</p>
<p>Vidíme, že tato samotná definice je &quot;rekurzivní&quot;: pro výpočet faktoriálu <code>n</code> musíme znát hodnotu
faktoriálu <code>n - 1</code>. Výpočet faktoriálu můžeme provést například následující funkcí:</p>
<pre><code class="language-c">int faktorial(int n) {
    if (n &lt;= 1) return 1;
    return n * faktorial(n - 1);
}
</code></pre>
<p>Pokud je parametr <code>n</code> menší než <code>1</code>, umíme faktoriál vypočítat triviálně. Pokud ne, tak spočteme
faktoriál <code>n - 1</code> a vynásobíme ho hodnotou <code>n</code>. Je důležité si uvědomit, v jakém pořadí zde probíhá
výpočet. Například při volání <code>factorial(4)</code>:</p>
<ol>
<li>Zavolá se <code>factorial(4)</code>.</li>
<li><code>factorial(4)</code> zavolá <code>factorial(3)</code>.</li>
<li><code>factorial(3)</code> zavolá <code>factorial(2)</code>.</li>
<li><code>factorial(2)</code> zavolá <code>factorial(1)</code>.</li>
<li><code>factorial(1)</code> vrátí <code>1</code>.</li>
<li><code>factorial(2)</code> vrátí <code>2 * 1</code>.</li>
<li><code>factorial(3)</code> vrátí <code>3 * 2 * 1</code>.</li>
<li><code>factorial(4)</code> vrátí <code>4 * 3 * 2 * 1</code>.</li>
</ol>
<p>Nejprve tak dojde k vypočtení <code>factorial(1)</code>, poté <code>factorial(2)</code> atd. Výpočet je tak v jistém
smyslu &quot;otočen&quot;. Zkuste si výpočet faktoriálu <a href="c/funkce/../../prostredi/ladeni.html#krokov%C3%A1n%C3%AD">odkrokovat</a>, abyste
si ujasnili, jak výpočet probíhá.</p>
<h2><a class="header" href="#přetečení-zásobníku" id="přetečení-zásobníku">Přetečení zásobníku</a></h2>
<p>Je důležité dávat si pozor na to, abychom vždy ve funkci měli podmínku, která rekurzi ukončí.
Jinak by se funkce volala &quot;donekonečna&quot;, dokud by nakonec nedošlo k
<a href="c/funkce/../../caste_chyby/pametove_chyby.html#stack-overflow">přetečení zásobníku</a>.</p>
<h1><a class="header" href="#funkce-standardní-knihovny" id="funkce-standardní-knihovny">Funkce standardní knihovny</a></h1>
<p>Když už nyní víme, co jsou to <a href="c/funkce/funkce.html">funkce</a>, tak si můžeme vysvětlit, odkud
se berou některé funkce, které jsme doposud používali, i když jsme je sami nenapsali.</p>
<p>Například výraz <code>printf(&quot;…&quot;)</code> je volání funkce s názvem <code>printf</code>. Tato funkce pochází ze
<strong>standardní knihovny C</strong> (<em>C standard library</em>). Jedná se o sadu užitečných funkcí, které jsou tak
často využívané, že jsou implicitně překladačem přidány k vašemu programu, abyste je mohli jednoduše
využívat a nemuseli ztrácet čas jejich psaním v každém programu od nuly.</p>
<p>Tyto funkce se starají například o následující oblasti:</p>
<ul>
<li>Čtení ze vstupu programu a zápis na výstup programu (například funkce <code>printf</code>)</li>
<li><a href="c/funkce/../prace_s_pameti/dynamicka_pamet.html">Dynamická alokace</a> paměti</li>
<li>Čtení a zápis <a href="c/funkce/../soubory/soubory.html">souborů</a> na disku</li>
<li><a href="c/funkce/../../ruzne/nahodna_cisla.html">Generování náhodných čísel</a></li>
<li><a href="c/funkce/../text/text.html">Práce s textem</a></li>
<li><a href="https://devdocs.io/c/chrono">Práce s časem a datem</a></li>
</ul>
<p>a mnoho dalších.</p>
<p>Abychom mohli tyto funkce používat, potřebujeme do našich programů vložit kód, který obsahuje
signatury těchto funkcí. Toho dosáhneme pomocí použití <a href="c/funkce/../preprocesor/preprocesor.html">preprocesoru</a>
– zde se dozvíte, jak funguje příkaz <code>#include &lt;…&gt;</code>, který jsme doposud používali jako &quot;black box&quot;.</p>
<p>Seznam funkcí dostupných v standardní knihovně můžete naleznout například
<a href="https://devdocs.io/c/">zde</a>.</p>
<p>Jak je standardní knihovna <em>C</em> připojena k vašim programům a jak si vytvořit vlastní knihovnu se
dozvíme později v sekci o <a href="c/funkce/../modularizace/knihovny.html">knihovnách</a>.</p>
<h1><a class="header" href="#preprocesor" id="preprocesor">Preprocesor</a></h1>
<p>Než je váš zdrojový soubor přeložen na strojové instrukce, tak jej
<a href="c/preprocesor/../../prostredi/preklad_programu.html">překladač</a> nejprve prožene tzv. <strong>preprocesorem</strong>
(<em>preprocessor</em>). Tento program nedělá nic jiného, než že projde váš zdrojový kód a zpracuje řádky
se speciálními příkazy začínajícími na <code>#</code>.</p>
<p>Ukážeme si dva typy příkazů, které preprocesor umí zpracovávat:</p>
<ul>
<li><a href="c/preprocesor/vkladani_souboru.html">Vkládání souborů</a> do vašeho kódu (<code>#include</code>)</li>
<li>Vytváření <a href="c/preprocesor/makra.html">maker</a> (<code>#define</code>)</li>
</ul>
<p>Pokud si chcete ověřit, jak vypadá váš zdrojový soubor poté, co jej zpracuje preprocesor, ale předtím,
než je přeložen na strojové instrukce, můžete k tomu použít tento příkaz:</p>
<pre><code class="language-bash">$ gcc -P -E main.c
</code></pre>
<h1><a class="header" href="#vkládání-souborů" id="vkládání-souborů">Vkládání souborů</a></h1>
<p>Příkaz <code>#include</code> slouží ke vložení obsahu jiného souboru do vašeho zdrojového kódu. Tento příkaz
existuje ve dvou variantách:</p>
<pre><code class="language-c">#include &lt;cesta k souboru&gt;
#include &quot;cesta k souboru&quot;
</code></pre>
<p>Rozdíl mezi nimi je popsán <a href="c/preprocesor/vkladani_souboru.html#rozd%C3%ADl-mezi-include--a-include-">níže</a>.</p>
<p>Jakmile preprocesor narazí na tento příkaz, tak se pokusí najít soubor na uvedené cestě, zpracuje
jeho obsah (tj. vyhodnotí případné další příkazy jako <code>#include</code>, které v něm mohou být) a poté jeho
obsah vloží na místo, kde je <code>#include</code> použit. Jedná se o prosté textové nahrazení (<code>Ctrl+C -&gt; Ctrl+V</code>).</p>
<p>Tento příkaz slouží k tomu, abychom mohli používat stejný kód ve více souborech bez toho, abychom
jej museli neustále ručně kopírovat. Prozatím budeme vkládat do našeho kódu zejména soubory
obsahující různé funkce <a href="c/preprocesor/../funkce/stdlib.html">standardní knihovny <em>C</em></a>. Později si ukážeme, jak
vytvořit vlastní soubory, které lze vkládat, a vytvářet tak <em>C</em> programy sestávající se z
<a href="c/preprocesor/../modularizace/modularizace.html">více zdrojových souborů</a>.</p>
<p>Zkuste si například tento zdrojový soubor pojmenovat jako <code>main.c</code> a pomocí příkazu <code>gcc -P -E main.c</code>
v terminálu zjistit, jak vypadá poté, co na něj byl aplikován preprocesor:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main() {
    printf(&quot;Hello world\n&quot;);
    return 0;
}
</code></pre>
<details>
<summary>Výstup může vypadat například takto</summary>
<pre><code class="language-c">typedef long unsigned int size_t;
typedef __builtin_va_list __gnuc_va_list;
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;
typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;
typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;
typedef int __daddr_t;
typedef int __key_t;
typedef int __clockid_t;
typedef void * __timer_t;
typedef long int __blksize_t;
typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;
typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;
typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;
typedef long int __fsword_t;
typedef long int __ssize_t;
typedef long int __syscall_slong_t;
typedef unsigned long int __syscall_ulong_t;
typedef __off64_t __loff_t;
typedef char *__caddr_t;
typedef long int __intptr_t;
typedef unsigned int __socklen_t;
typedef int __sig_atomic_t;
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
struct _IO_FILE;
typedef struct _IO_FILE __FILE;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;
typedef void _IO_lock_t;
struct _IO_FILE
{
  int _flags;
  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;
  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;
  struct _IO_marker *_markers;
  struct _IO_FILE *_chain;
  int _fileno;
  int _flags2;
  __off_t _old_offset;
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];
  _IO_lock_t *_lock;
  __off64_t _offset;
  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;
  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
typedef __gnuc_va_list va_list;
typedef __off_t off_t;
typedef __ssize_t ssize_t;
typedef __fpos_t fpos_t;
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;
extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));
extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));
extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));
extern FILE *tmpfile (void) ;
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;
extern int fclose (FILE *__stream);
extern int fflush (FILE *__stream);
extern int fflush_unlocked (FILE *__stream);
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;
extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;
extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;
extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));
extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));
extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));
extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);
extern int printf (const char *__restrict __format, ...);
extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));
extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);
extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);
extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));
extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));
extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));
extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));
extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;
extern int scanf (const char *__restrict __format, ...) ;
extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ (&quot;&quot; &quot;__isoc99_fscanf&quot;) ;
extern int scanf (const char *__restrict __format, ...) __asm__ (&quot;&quot; &quot;__isoc99_scanf&quot;) ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ (&quot;&quot; &quot;__isoc99_sscanf&quot;) __attribute__ ((__nothrow__ , __leaf__));
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ (&quot;&quot; &quot;__isoc99_vfscanf&quot;)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ (&quot;&quot; &quot;__isoc99_vscanf&quot;)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ (&quot;&quot; &quot;__isoc99_vsscanf&quot;) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__format__ (__scanf__, 2, 0)));
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);
extern int getchar (void);
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
extern int fgetc_unlocked (FILE *__stream);
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);
extern int putchar (int __c);
extern int fputc_unlocked (int __c, FILE *__stream);
extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);
extern int getw (FILE *__stream);
extern int putw (int __w, FILE *__stream);
extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __attribute__ ((__access__ (__write_only__, 1, 2)));
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;
extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;
extern int fputs (const char *__restrict __s, FILE *__restrict __stream);
extern int puts (const char *__s);
extern int ungetc (int __c, FILE *__stream);
extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);
extern int fseek (FILE *__stream, long int __off, int __whence);
extern long int ftell (FILE *__stream) ;
extern void rewind (FILE *__stream);
extern int fseeko (FILE *__stream, __off_t __off, int __whence);
extern __off_t ftello (FILE *__stream) ;
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);
extern int fsetpos (FILE *__stream, const fpos_t *__pos);
extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void perror (const char *__s);
extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern FILE *popen (const char *__command, const char *__modes) ;
extern int pclose (FILE *__stream);
extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);

int main() {
    printf(&quot;Hello world\n&quot;);
    return 0;
}
</code></pre>
</details>
<p>Asi je zřejmé, že by nebylo praktické kopírovat ručně všechen tento kód pokaždé, když bychom chtěli
něco vytisknout na výstup programu.</p>
<h2><a class="header" href="#relativní-cesta" id="relativní-cesta">Relativní cesta</a></h2>
<p>Cesta k souboru zadávaná v <code>#include</code> by měla být relativní, tj. není dobrý nápad používat něco
podobného:</p>
<pre><code class="language-c">#include &quot;C:/Users/Kamil/Desktop/upr/muj_soubor.h&quot;
</code></pre>
<p>Takovýto program by totiž jistě nefungoval na jiném než vašem počítači. Z kterého adresáře se tato
relativní cesta vyhodnotí je popsáno níže.</p>
<h2><a class="header" href="#rozdíl-mezi-include--a-include-" id="rozdíl-mezi-include--a-include-">Rozdíl mezi <code>#include &lt;…&gt;</code> a <code>#include &quot;…&quot;</code></a></h2>
<p>Rozdíl mezi těmito variantami není pevně definován, nicméně většina preprocesorů (resp. překladačů)
funguje takto:</p>
<ul>
<li>
<p><code>#include &lt;…&gt;</code> nejprve vyhledá zadanou cestu v tzv. systémových cestách. Jedná se o známé adresáře,
ve kterých jsou uloženy jak soubory standardní knihovny <em>C</em>, tak i dalších knihoven, které máte
v systému nainstalované. Pouze pokud se zde daný soubor nenalezne, tak se cesta vyhodnotí relativně
k zdrojovému souboru, ve kterém byl <code>#include</code> použit.</p>
<p>Seznam systémových cest si můžete vypsat pomocí příkazu <code>echo | gcc -E -Wp,-v -</code> v Linuxovém
terminálu. Do tohoto seznamu můžete také přidat dodatečné adresáře, když <code>gcc</code> předáte parametr
<code>-I</code>. Více se dozvíte v sekci o <a href="c/preprocesor/../modularizace/knihovny.html">knihovnách</a>.</p>
<p>Pokud soubor, který chcete do vašeho kódu vložit, se nachází v externí knihovně, která nepatří
do vašeho projektu, je běžné používat právě <code>#include &lt;&gt;</code>.</p>
</li>
<li>
<p><code>#include &quot;…&quot;</code> se nedívá do systémových cest, ale rovnou hledá zadanou cestu relativně k souboru,
ve kterém byl <code>#include</code> použit. Tuto formu používejte, pokud budete vkládat soubory z vašeho
projektu.</p>
</li>
</ul>
<h1><a class="header" href="#makra" id="makra">Makra</a></h1>
<blockquote>
<p>🤓 Tato sekce obsahuje doplňující učivo. Pokud je toho na vás moc, můžete ji prozatím přeskočit
a vrátit se k ní později.</p>
</blockquote>
<p>Občas můžeme chtít v programech použít stejnou hodnotu na více místech. V takovém případě se hodí
danou hodnotu pojmenovat, aby bylo zřejmé, co reprezentuje. Zároveň by bylo užitečné ji nadefinovat
pouze na jednom místě, abychom její hodnotu mohli jednoduše upravit bez toho, abychom při tom
museli upravovat všechna místa, kde danou hodnotu používáme.</p>
<p>Pomocí příkazu <code>#define &lt;název&gt; &lt;hodnota&gt;</code> můžeme vytvořit <strong>makro</strong> (<em>macro</em>) s daným názvem a
hodnotou. Pokud preprocesor v kódu od řádku s <code>#define</code> do konce zdrojového souboru narazí na název
makra, tak tento název nahradí hodnotou makra (opět se jedná o prosté textové nahrazení, tedy
<code>Ctrl+C -&gt; Ctrl+V</code>). Zkuste si například, co vypíše tento program:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

#define CENA 25

int main() {
    printf(&quot;Cena je %d\n&quot;, CENA);
    printf(&quot;Dvojnasobek ceny je %d\n&quot;, CENA * 2);

    return 0;
}
</code></pre>
<p>Představte si, že hodnotu tohoto makra používáme v programu na stovkách míst. Pokud bychom ji
potřebovali změnit, tak stačí změnit jeden řádek s <code>#define</code> a preprocesor se poté postará o to,
že se hodnota aktualizuje na všech použitých místech.</p>
<p>Makra jsou dle konvence obvykle pojmenována s &quot;caps-lockem&quot;, tedy velkými písmeny (respektive stylem
<a href="c/preprocesor/../promenne/pojmenovavani.html#v%C3%ADceslovn%C3%A9-n%C3%A1zvy">screaming snake case</a>).</p>
<p>Je třeba brát na vědomí, že preprocesor opravdu dělá pouhé textové nahrazení. Například následující
kód tak nedává smysl:</p>
<pre><code class="language-c">#define CENA 25
int main() {
    CENA = 0;
    return 0;
}
</code></pre>
<p>protože po spuštění preprocesoru se z něj stane tento (nesmyslný) kód:</p>
<pre><code class="language-c">int main() {
    25 = 0;
    return 0;
}
</code></pre>
<h2><a class="header" href="#makra-s-parametry" id="makra-s-parametry">Makra s parametry</a></h2>
<p>Makra mohou také obsahovat parametry:</p>
<pre><code class="language-c">#define &lt;název_makra&gt;(&lt;param1&gt;, &lt;param2&gt;, …) &lt;hodnota_makra&gt;
</code></pre>
<p>Tyto parametry můžete použít pro definici hodnoty. Nicméně je opět třeba dát pozor na to, že
preprocesor pracuje pouze s textem, nerozumí jazyku <em>C</em>. Parametry tak jsou předávány čistě jako
text, je tak potřeba dávat si pozor na několik věcí:</p>
<ul>
<li>
<p><strong>Priorita operátorů</strong> Pokud bychom chtěli vytvořit například makro pro výpočet druhé mocniny,
můžeme ho napsat takto:</p>
<pre><code class="language-c">#define MOCNINA(a) a * a
</code></pre>
<p>Pokud však takovéto makro použijeme s nějakým komplexním výrazem, nemusíme dosáhnout kýženého
výsledku kvůli priority operátorů:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

#define MOCNINA(a) a * a

int main() {
    printf(&quot;%d\n&quot;, MOCNINA(1 + 1));
    return 0;
}
</code></pre>
<p>Řádek s <code>printf</code> totiž preprocesor změní na <code>printf(&quot;%d\n&quot;, 1 + 1 * 1 + 1);</code>, což jistě není to,
co jsme chtěli. Proto je dobré při použití maker s parametry obalovat jednotlivé parametry
závorkami:</p>
<pre><code class="language-c">#define MOCNINA(a) (a) * (a)
</code></pre>
<p>Pak by zde již došlo k úpravě na <code>printf(&quot;%d\n&quot;, (1 + 1) * (1 + 1));</code>, což vrátí druhou mocninu
hodnoty <code>1 + 1</code>, tedy <code>4</code>.</p>
</li>
<li>
<p><strong>Vedlejší efekty</strong> Pokud mají argumenty předávané do makra nějaké
<a href="c/preprocesor/../prikazy_vyrazy.html#vedlej%C5%A1%C3%AD-efekty">vedlejší efekty</a>, je třeba si dávat pozor na to, že makro může
jednoduše takovýto argument rozkopírovat a tím pádem vedlejší efekt provést vícekrát. Například při
použití makra <code>MOCNINA</code> výše by zde došlo k dvojnásobné inkrementaci proměnné <code>x</code>:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

#define MOCNINA(a) a * a

int main() {
    int x = 0;
    int mocnina = MOCNINA(x++);
    printf(&quot;x=%d, mocnina=%d\n&quot;, x, mocnina);

    return 0;
}
</code></pre>
<p>Do maker tak radši nedávejte argumenty, které způsobují vedlejší efekty.</p>
<hr />
<p><strong>Cvičení</strong>: Zamyslete se nad tím, jaké hodnoty vypsal program s makrem s vedlejšími efekty výše.
Zkuste si rozepsat makro a odsimulovat v hlavě běh programu. Dojdete ke stejnému výsledku?</p>
<hr />
</li>
</ul>
<h2><a class="header" href="#makra-vs-globální-proměnné" id="makra-vs-globální-proměnné">Makra vs globální proměnné</a></h2>
<p><a href="c/preprocesor/../promenne/globalni_promenne.html">Globální proměnné</a> jsou také pojmenované hodnoty definované na
jednom místě, proč tedy potřebujeme makra? Je to z několika důvodů:</p>
<ul>
<li>Makra s parametry umožňují definici hodnot či textu závislou na použitých parametrech, což
globální proměnné neumožňují.</li>
<li>Konstantní globální proměnné nelze použít například pro určení velikosti statických
<a href="c/preprocesor/../pole/pole.html">polí</a>.</li>
<li>Globální proměnné zabírají místo v paměti programu a zároveň zvyšují velikost spustitelného
souboru, protože v něm musí být uložena jejich iniciální hodnota
(pokud to tedy <a href="c/preprocesor/../promenne/globalni_promenne.html#inici%C3%A1ln%C3%AD-hodnota">není <code>0</code></a>). Makra se pouze textově
nahradí během překladu programu, takže samy o sobě žádnou paměť nezabírají.</li>
</ul>
<p>Nicméně, makra jsou občas problémová kvůli toho, že se nahrazují čistě jako text. <strong>Pokud je to tedy
možné, zkuste raději použít pro definici konstant v kódu konstantní globální proměnné.</strong></p>
<h2><a class="header" href="#podmíněný-překlad" id="podmíněný-překlad">Podmíněný překlad</a></h2>
<p>Makra mohou také být použity k tzv. <strong>podmíněnému překladu</strong> (<em>conditional compilation</em>). Pomocí
příkazů preprocesoru jako <code>#ifdef</code> nebo <code>#if</code> můžete přeložit kus kódu pouze, pokud je nadefinované
určité makro (popřípadě pouze pokud má určitou hodnotu). Toho se běžně využívá například pro tvorbu
programů, které jsou kompatibilní s více operačními systémy (např. jedna funkce může mít jinou
implementaci pro Linux a jinou pro Windows).</p>
<p>V UPR se s podmíněným překladem nesetkáme, více se o něm můžete dozvědět například
<a href="https://docs.microsoft.com/en-us/cpp/preprocessor/hash-if-hash-elif-hash-else-and-hash-endif-directives-c-cpp">zde</a>.</p>
<h1><a class="header" href="#práce-s-pamětí" id="práce-s-pamětí">Práce s pamětí</a></h1>
<p>V sekci o <a href="c/prace_s_pameti/../../uvod/pamet.html">paměti</a> jsme se dozvěděli, že operační paměť počítače lze adresovat
pomocí číselných adres. Prozatím jsme nicméně v našich programech s žádnými adresami explicitně
nepracovali, pouze jsme vytvářeli proměnné, jejichž paměť byla spravována automaticky. V této sekci
se dozvíte základy toho, jak tzv. <strong>správa paměti</strong> (<em>memory management</em>) funguje.</p>
<h2><a class="header" href="#adresní-prostor-programu" id="adresní-prostor-programu">Adresní prostor programu</a></h2>
<p>Když spustíte svůj program, tak pro něj operační systém vytvoří tzv. <strong>adresní prostor</strong>
(<em>address space</em>), což je oblast paměti, se kterou program může pracovat.<sup class='margin-toggle sidenote-number'>1</sup> Tato oblast je typicky
rozdělena na několik částí, z nichž každá slouží pro různé typy dat:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Díky mechanismu
<a href="https://cs.wikipedia.org/wiki/Virtu%C3%A1ln%C3%AD_pam%C4%9B%C5%A5">virtuální paměti</a> je tento
prostor soukromý pro váš běžící program - ostatní běžící programy do něj nemají přístup, pokud jim
to explicitně nepovolíte.</p>
</span><div style="display: flex; justify-content: center;">
    <img src="c/prace_s_pameti/../../static/img/address_space.png" alt="Adresní prostor běžícího programu" width="300px" />
</div>
<ul>
<li><strong>Zásobník</strong> Tato část uchovává automaticky spravovaná data, zejména lokální proměnné a parametry
funkcí. Tuto oblast popisuje sekce o <a href="c/prace_s_pameti/automaticka_pamet.html">automatické paměti</a>.</li>
<li><strong>Halda</strong> Tuto část můžete využít k dynamické alokaci paměti. To nám umožňují
<a href="c/prace_s_pameti/ukazatele.html">ukazatele</a>, díky kterým můžeme explicitně pracovat s adresami v paměti. Tuto oblast
adresního prostoru popisuje sekce o <a href="c/prace_s_pameti/dynamicka_pamet.html">dynamické paměti</a>.</li>
<li><strong>Globální data</strong> Tato část obsahuje <a href="c/prace_s_pameti/../promenne/globalni_promenne.html">globální proměnné</a>,
které žijí po celou dobu běhu programu.</li>
<li><strong>Instrukce programu</strong> Do této části paměti se při spuštění programu zkopírují jeho instrukce
ze spustitelného souboru na disku. Procesor poté čte instrukce, které má vykonat, právě z této části
paměti. Tato paměť je obvykle chráněna proti zápisu a slouží pouze pro čtení.</li>
</ul>
<h1><a class="header" href="#automatická-paměť" id="automatická-paměť">Automatická paměť</a></h1>
<p>Zatím jsme používali (lokální) proměnné, které vznikají a zanikají uvnitř funkcí. Nemuseli jsme se
tedy nijak starat o to, kde existují v paměti. Lokální proměnné se ukládají do oblasti v paměti,
kterou nazýváme <strong>zásobník</strong> (<em>stack</em>). Každý běžící program má vyhrazen určitou oblast
adresovatelné paměti, která je použita právě jako zásobník.</p>
<p>Při každém zavolání funkce vznikne na zásobníku tzv. <strong>zásobníkový rámec</strong> (<em>stack frame</em>).
V tomto rámci je vyhrazena paměť pro lokální proměnné volané funkce a také pro její
<a href="c/prace_s_pameti/../funkce/funkce.html#parametrizace-funkc%C3%AD">parametry</a>. Rámec vzniká při každém zavolání funkce, v
jednu chvíli tak na zásobníku může existovat více rámců (s různými hodnotami proměnných a parametrů)
pro stejnou funkci. Rámce vznikají v paměti za sebou, a jsou uvolněny v momentě, kdy se jejich
funkce dokončí.<sup class='margin-toggle sidenote-number'>1</sup></p>
<span class='sidenote'><p><sup class='number'>1</sup>Rámce tak mohou vznikat nebo zanikat pouze na konci zásobníku, ne uprostřed. Proto se tato
oblast nazývá zásobník, podle
<a href="https://cs.wikipedia.org/wiki/Z%C3%A1sobn%C3%ADk_(datov%C3%A1_struktura)">datové struktury</a>, která
má tuto vlastnost.</p>
</span>
<p>Při zavolání funkce se do paměti určené pro jednotlivé parametry v rámci nakopírují hodnoty argumentů
předaných při volání funkce. Jakmile funkce skončí, tak je rámec, spolu s pamětí lokálních
proměnných, uvolněn<sup class='margin-toggle sidenote-number'>2</sup>.</p>
<span class='sidenote'><p><sup class='number'>2</sup>Uvolnění zde znamená pouze to, že program bude pokládat danou paměť za volnou k dalšímu použití.
Pokud tak například funkce bude mít lokální proměnnou s hodnotou <code>5</code> a vykonání funkce skončí, tato
hodnota v paměti zůstane, dokud nebude přepsána příštím zavoláním funkce.</p>
</span>
<p>V následující animaci můžete vidět sekvenci volání funkcí. Ve sloupci vpravo je zobrazen stav
zásobníku při provádění tohoto programu. Modře jsou v něm znázorněny hodnoty parametrů a červeně
hodnoty lokálních proměnných. Můžete si všimnout, že lokální proměnné mají
<a href="c/prace_s_pameti/../promenne/promenne.html#v%C5%BEdy-inicializujte-prom%C4%9Bnn%C3%A9">nedefinovanou hodnotu</a>, dokud do nich není
nějaká hodnota zapsána, nicméně paměť pro ně již existuje od začátku provádění funkce.</p>
<div style="height: 450px">
    <upr-slideshow src="../../static/animations/stack/stack-" to="15" extension="png"></upr-slideshow>
</div>
<p>V animaci si můžete všimnout, že rámce vždy vznikají a zanikají pouze na konci zásobníku.<sup class='margin-toggle sidenote-number'>3</sup>
Uhodnete, jaké číslo tento program vypíše?</p>
<span class='sidenote'><p><sup class='number'>3</sup>Z <a href="https://stackoverflow.com/questions/2035568/why-do-stacks-typically-grow-downwards">historických</a>
důvodů zásobník roste &quot;dolů&quot;, tj. nové rámce se vytvářejí na nižší adrese v paměti.</p>
</span>
<h2><a class="header" href="#výhody-automatické-paměti" id="výhody-automatické-paměti">Výhody automatické paměti</a></h2>
<p>Používání automatické paměti má značné výhody:</p>
<ul>
<li>Nemusíme se starat o to, jak je paměť alokována a uvolňována, vše za nás řeší překladač, který
generuje instrukce pro vytváření a uvolňování rámců při volání/dokončení provádění funkce.</li>
<li>Alokace i uvolnění paměti je velmi rychlá. Jde v podstatě o provedení jediné instrukce, která si
pamatuje, kde zrovna zásobník &quot;končí&quot; v paměti.</li>
</ul>
<p>Pokud tedy nepotřebujete žádnou složitější funkcionalitu, první volbou by mělo být právě použití
automatické paměti (tedy lokálních proměnných).</p>
<h2><a class="header" href="#nevýhody-automatické-paměti" id="nevýhody-automatické-paměti">Nevýhody automatické paměti</a></h2>
<p>Automatická paměť je sice velmi užitečná, nicméně někdy potřebujeme použít i jiné typy paměti,
protože automatická paměť má i určité nedostatky:</p>
<ul>
<li>Maximální velikost zásobníku je omezena<sup class='margin-toggle sidenote-number'>4</sup>. Nemůžeme tak na něm naalokovat větší množství paměti.<span class='sidenote'><p><sup class='number'>4</sup>Obvykle jde o jednotky KiB nebo MiB.</p>
</span></li>
<li>Počet a velikost lokálních proměnných je &quot;zadrátována&quot; do programu během jeho překladu. Nemůžeme
tak naalokovat paměť s velikostí závislou na vstupu programu. Například pokud uživatel zadá
číslo <code>n</code> a my bychom chtěli vytvořit paměť pro <code>n</code> čísel, tak nestačí použití zásobníku.</li>
<li>Paměť lokálních proměnných a parametrů je uvolněna při dokončení provádění funkce. Jediným způsobem,
jak předat hodnotu z volání funkce, je pomocí návratové hodnoty. Takto lze vrátit pouze jednu
hodnotu a nelze jednoduše sdílet paměť mezi funkcemi, protože paměť lokálních proměnných je po dokončení
volání funkce uvolněna a nelze ji tak použít z volající funkce.</li>
<li>Argumenty předávané do funkcí se kopírují do zásobníkového rámce volané funkce a návratová hodnota
se zase kopíruje zpět do rámce volající funkce. Toto kopírování může být zbytečně pomalé pro hodnoty
zabírající velký počet bytů. </li>
</ul>
<p>Abychom mohli alokovat větší množství paměti či jednoduššeji sdílet hodnoty proměnných mezi funkcemi,
tak musíme mít možnost alokovat a uvolňovat paměť manuálně. K tomu ale nejprve potřebujeme vědět,
jak pracovat přímo s adresami v paměti, k čemuž slouží <a href="c/prace_s_pameti/ukazatele.html">ukazatele</a>.</p>
<h1><a class="header" href="#ukazatele" id="ukazatele">Ukazatele</a></h1>
<p>Abychom v <em>C</em> mohli manuálně pracovat s pamětí, potřebujeme mít možnost odkazovat se na jednotlivé
hodnoty v paměti pomocí <a href="c/prace_s_pameti/../../uvod/pamet.html#adresov%C3%A1n%C3%AD-pam%C4%9Bti">adres</a>. Adresa je číslo, takže
bychom mohli pro popis adres používat například datový typ <code>unsigned int</code><sup class='margin-toggle sidenote-number'>1</sup>. To by ale nebyl dobrý
nápad, protože tento datový typ neumožňuje provádět operace, které bychom s adresami chtěli dělat
(načíst hodnotu z adresy či zapsat hodnotu na adresu), a naopak umožňuje provádět operace, které s
adresami dělat nechceme (například násobení či dělení adres obvykle nedává valný smysl).</p>
<span class='sidenote'><p><sup class='number'>1</sup>Nejnižší možná adresa je <code>0</code>, takže záporné hodnoty nemá cenu reprezentovat.</p>
</span>
<p>Z tohoto důvodu <em>C</em> obsahuje datový typ, který je interpretován jako adresa v paměti běžícího
programu. Nazývá se <strong>ukazatel</strong> (<em>pointer</em>). Kromě toho, že reprezentuje adresu, tak každý datový
typ ukazatele také obsahuje informaci o tom, jaký typ hodnoty je uložen v paměti na adrese obsažené
v ukazateli. Poté říkáme, že ukazatel &quot;ukazuje na&quot; daný datový typ.</p>
<p>Abychom vytvořili datový typ ukazatele, vezmeme datový typ, na který bude ukazovat, a přidáme za něj
hvezdičku (<code>*</code>). Takto například vypadá proměnná datového typu &quot;ukazatel na <code>int</code>&quot;<sup class='margin-toggle sidenote-number'>2</sup>:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Je jedno, jestli hvězdičku napíšete k datovému typu (<code>int* p</code>) anebo k názvu proměnné
(<code>int *p</code>), bílé znaky jsou zde ignorovány. Pozor však na vytváření více ukazatelů na
<a href="c/prace_s_pameti/ukazatele.html#definice-v%C3%ADce-ukazatel%C5%AF-najednou">jednom řádku</a>.</p>
</span>
<pre><code class="language-c">int* ukazatel;
</code></pre>
<p>Je důležité si uvědomit, co tato proměnná reprezentuje. Datový typ <code>int*</code> zde říká, že v proměnné
<code>ukazatel</code> bude uloženo číslo, které budeme interpretovat jako adresu. V paměti na této adrese poté
bude ležet číslo, které budeme interpretovat jako datový typ <code>int</code> (celé číslo se znaménkem).</p>
<p>Ukazatele lze libovolně &quot;vnořovat&quot;, tj. můžeme mít například &quot;ukazatel na ukazatel na celé číslo&quot;
(<code>int**</code>). Ukazatel ale i tehdy bude prostě číslo, akorát ho budeme interpretovat jako adresu jiné
adresy. Pro procvičení je níže uvedeno několik datových typů spolu s tím, jak je interpretujeme.</p>
<ul>
<li><code>int</code> - interpretujeme jako celé číslo</li>
<li><code>int*</code> - interpretujeme jako adresu, na které je uloženo celé číslo</li>
<li><code>float*</code> - interpretujeme jako adresu, na které je uloženo desetinné číslo</li>
<li><code>int**</code> - interpretujeme jako adresu, na které je uložena adresa, na které je uloženo celé číslo</li>
</ul>
<p>Někdy chceme použít &quot;univerzální&quot; ukazatel, který prostě obsahuje adresu, bez toho, abychom striktně
určovali, jaká hodnota na dané adrese bude uložena. V tom případě můžeme použít datový typ <code>void*</code>.</p>
<blockquote>
<p>Velikost všech ukazatelů v programu je stejná a je dána použitým operačním systémem a překladačem.
Ukazatele musí být dostatečně velké, aby zvládly reprezentovat libovolnou adresu, která se v programu
může vyskytnout. Na vašem počítači to bude nejspíše <strong>8 bytů</strong>, protože pravděpodobně používáte
64-bitový systém.</p>
</blockquote>
<h2><a class="header" href="#inicializace-ukazatele" id="inicializace-ukazatele">Inicializace ukazatele</a></h2>
<p>Jelikož před spuštěním programu nevíme, na jaké adrese budou uloženy hodnoty, které nás budou
zajímat, tak obvykle nedává smysl inicializovat ukazatel na konkrétní adresu (např. <code>int* p = 5;</code>).
Pro inicializaci ukazatele tak existuje několik standardních možností:</p>
<ul>
<li>
<p><strong>Inicializace na nulu</strong> Pokud chceme vytvořit &quot;prázdný&quot; ukazatel, který zatím neukazuje na
žádnou validní adresu, tak se dle konvence inicializuje na hodnotu <code>0</code>. Takovému ukazateli se pak
říká <strong>nulový ukazatel</strong> (<em>null pointer</em>). Jelikož datový typ výrazu <code>0</code> je <code>int</code>, tak před
přiřazením této hodnoty do ukazatele jej musíme
<a href="c/prace_s_pameti/../datove_typy/konverze.html">přetypovat</a> na datový typ cílového
ukazatele:</p>
<pre><code class="language-c">float* p = (float*) 0;
</code></pre>
<p>Jelikož tento typ inicializace je velmi častý, <a href="c/prace_s_pameti/../funkce/stdlib.html">standardní knihovna <em>C</em></a>
obsahuje <a href="c/prace_s_pameti/../preprocesor/makra.html">makro</a> <code>NULL</code>, které konverzi nuly na ukazatel provede za
vás. Můžete jej najít například v souboru <code>stdlib.h</code>:</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
// ...
float* p = NULL;
</code></pre>
</li>
<li>
<p><strong>Využití alokační funkce</strong> Pokud budete alokovat paměť <a href="c/prace_s_pameti/dynamicka_pamet.html">manuálně</a>, tak
použijete funkce, které vám vrátí adresu jako svou návratovou hodnotu.</p>
</li>
<li>
<p><strong>Využití operátoru adresy</strong> Pokud chcete ukazatel nastavit na adresu již existující hodnoty v
paměti, můžete použít <strong>operátor adresy</strong> (<em>address-of operator</em>). Ten má syntaxi <code>&amp;&lt;proměnná&gt;</code>.
Tento operátor se vyhodnotí jako adresa předané proměnné<sup class='margin-toggle sidenote-number'>3</sup>:</p>
<span class='sidenote'><p><sup class='number'>3</sup>Všimněte si, že pro výpis ukazatelů ve funkci <code>printf</code> se používá <code>%p</code> místo <code>%d</code>.</p>
</span>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int x = 1;
    int* p = &amp;x;

    printf(&quot;%d\n&quot;, x);  // hodnota proměnné x
    printf(&quot;%p\n&quot;, p);  // adresa v paměti, kde je uložena proměnná x

    return 0;
}
</code></pre>
<p>Výraz předaný operátoru <code>&amp;</code> se musí vyhodnotit na něco, co má adresu v paměti (většinou to bude
<a href="c/prace_s_pameti/../promenne/promenne.html">proměnná</a>). Nedává tedy smysl použít něco jako <code>&amp;5</code>, protože 5 je
číslo, které nemá samo o sobě žádnou adresu v paměti.</p>
<p>Při použití tohoto operátoru je také třeba dávat si pozor na to, aby hodnota v paměti, jejíž
adresu použitím <code>&amp;</code> získáme, stále existovala, když se budeme později snažit k této adrese
pomocí ukazatele přistoupit. V opačném případu by mohlo dojít k
<a href="c/prace_s_pameti/../../caste_chyby/pametove_chyby.html#segmentation-fault">paměťové chybě</a> 💣.</p>
</li>
</ul>
<h2><a class="header" href="#přístup-k-paměti-pomocí-ukazatele" id="přístup-k-paměti-pomocí-ukazatele">Přístup k paměti pomocí ukazatele</a></h2>
<p>Když už máme v ukazateli uloženou nějakou (validní) adresu v paměti, tak k této paměti můžeme
přistoupit pomocí operátoru <strong>dereference</strong>. Ten má syntaxi <code>*&lt;výraz typu ukazatel&gt;</code>. Při použití
tohoto operátoru na ukazateli program přečte adresu v ukazateli, podívá se do paměti a načte hodnotu
uloženou na této adrese. Podle toho, na jaký datový typ ukazatel ukazuje, se načte odpovídající
počet bytů z paměti:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int cislo = 1;
    int* ukazatel = &amp;cislo;

    printf(&quot;%p\n&quot;, ukazatel);
    printf(&quot;%d\n&quot;, *ukazatel);
    printf(&quot;%d\n&quot;, cislo);

    return 0;
}
</code></pre>
<p>V tomto programu se do proměnné <code>ukazatel</code> uloží adresa proměnné <code>cislo</code>, a poté dojde k načtení
hodnoty (<code>*ukazatel</code>) této proměnné z paměti přes adresu uloženou v ukazateli.</p>
<details>
  <summary>Interaktivní vizualizace kódu</summary>
<iframe width="750" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=%23include%20%3Cstdio.h%3E%0A%0Aint%20main%28%29%20%7B%0A%20%20%20%20int%20cislo%20%3D%201%3B%0A%20%20%20%20int*%20ukazatel%20%3D%20%26cislo%3B%0A%0A%20%20%20%20printf%28%22%25p%5Cn%22,%20ukazatel%29%3B%0A%20%20%20%20printf%28%22%25d%5Cn%22,%20*ukazatel%29%3B%0A%20%20%20%20printf%28%22%25d%5Cn%22,%20cislo%29%3B%0A%0A%20%20%20%20return%200%3B%0A%7D%0A&codeDivHeight=400&codeDivWidth=350&curInstr=5&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D"> </iframe>
</details>
<p>Pokud chceme do adresy uložené v ukazateli naopak nějakou hodnotu zapsat, tak můžeme operátor
dereference použít také na levé straně operátoru <a href="c/prace_s_pameti/../promenne/promenne.html#z%C3%A1pis">zápisu</a>.
Uhodnete, co vypíše tento program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int cislo = 1;
    int* ukazatel = &amp;cislo;
    *ukazatel = 5;

    printf(&quot;%d\n&quot;, cislo);

    return 0;
}
</code></pre>
<details>
  <summary>Interaktivní vizualizace kódu</summary>
<iframe width="750" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=%23include%20%3Cstdio.h%3E%0A%0Aint%20main%28%29%20%7B%0A%20%20%20%20int%20cislo%20%3D%201%3B%0A%20%20%20%20int*%20ukazatel%20%3D%20%26cislo%3B%0A%20%20%20%20*ukazatel%20%3D%205%3B%0A%0A%20%20%20%20printf%28%22%25d%5Cn%22,%20cislo%29%3B%0A%0A%20%20%20%20return%200%3B%0A%7D&codeDivHeight=400&codeDivWidth=350&curInstr=0&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D"> </iframe>
</details>
<p>Pokud provádíte operace s přímo s proměnnou ukazatele, budete vždy pracovat &quot;pouze&quot; s adresou,
která je v něm uložena. Pokud chcete načíst nebo změnit hodnotu, která v paměti leží na adrese
uložené v ukazateli, musíte použít operátor dereference.</p>
<blockquote>
<p>Pozor na rozdíl mezi <code>*</code> používanou pro deklaraci datového typu ukazatel, operátorem dereference
a operátorem násobení. Všechny tyto věci sice používají hvězdičku, ale jinak spolu nesouvisí.
Vždy záleží na kontextu, kde jsou tyto znaky použity:</p>
<pre><code class="language-c">// hvězdička říká, že datový typ proměnné `p` je ukazatel na `int`
int* p;

// hvězdička provede dereferenci návratové hodnoty funkce `vrat_ukazatel`
int x = *vrat_ukazatel();

// hvězdička provede násobení dvou čísel
int a = 5 * 6;
</code></pre>
</blockquote>
<h2><a class="header" href="#aritmetika-s-ukazateli" id="aritmetika-s-ukazateli">Aritmetika s ukazateli</a></h2>
<p>Abychom se mohli v paměti &quot;posouvat&quot; o určitý kus dopředu či dozadu (relativně k nějaké adrese),
můžeme k ukazatelům přičítat či odčítat čísla. Toto se označuje jako <strong>aritmetika s ukazateli</strong>
(<em>pointer arithmetic</em>). Tato aritmetika má důležité pravidlo – pokud k ukazateli na konkrétní datový
typ přičteme hodnotu <code>n</code>, tak se adresa v ukazateli zvýší o <code>n</code>-násobek velikosti datového typu,
na který ukazatel ukazuje. Při aritmetice s ukazateli se tak neposouváme po jednotlivých bytech,
ale po celých hodnotách daného datového typu<sup class='margin-toggle sidenote-number'>4</sup>.</p>
<span class='sidenote'><p><sup class='number'>4</sup>Z toho vyplývá, že aritmetiku nemůžeme provádět nad ukazateli typu <code>void*</code>, protože ty neukazují
na žádný konkrétní datový typ.</p>
</span>
<p>Například, pokud bychom měli ukazatel <code>int* p</code> s hodnotou <code>16</code> (tj. &quot;ukazuje&quot; na adresu <code>16</code>) a
velikost <code>int</code>u by byla <code>4</code>, tak výraz <code>p + 1</code> bude ukazatel s hodnotou <code>20</code>, výraz <code>p + 2</code> bude
ukazatel s adresou <code>24</code> atd.</p>
<p>Je důležité <a href="c/prace_s_pameti/../../caste_chyby/caste_chyby.html#%C5%A0patn%C3%A1-pr%C3%A1ce-s-ukazatelem">rozlišovat</a>, jestli při
použití sčítání/odčítání pracujeme s hodnotou ukazatele anebo s hodnotou na adrese, která je v
ukazateli uložena:</p>
<pre><code class="language-c">int x = 1;
int* p = &amp;x;

*p += 1;    // zvýšili jsme hodnotu na adrese v `p` (tj. proměnnou `x`) o `1`
p += 1;     // zvýšili jsme adresu v `p` o `4` (tj. p nyní už neukazuje na `x`)
</code></pre>
<blockquote>
<p>K čemu je aritmetika s ukazateli užitečná se dozvíte v sekci o práci s
<a href="c/prace_s_pameti/../pole/staticke_pole.html#p%C5%99%C3%ADstup-k-prvk%C5%AFm-pole">více proměnnými zároveň</a>.</p>
</blockquote>
<p>Kromě dereference a aritmetiky lze s ukazateli provádět také porovnávání (klasicky pomocí operátoru
<code>==</code>). Díky tomu můžeme zjistit, jestli se dvě adresy rovnají.</p>
<h2><a class="header" href="#využití-ukazatelů" id="využití-ukazatelů">Využití ukazatelů</a></h2>
<p>Jak se dozvíte v <a href="c/prace_s_pameti/dynamicka_pamet.html">následující sekci</a>, ukazatele jsou nezbytné pro
dynamickou alokaci paměti. Hodí se také při práci s <a href="c/prace_s_pameti/../pole/pole.html">více proměnnými</a> zároveň. Kromě
toho je ale lze použít také například v následujících situacích, které všechny souvisí s předáváním
adres (ukazatelů) do funkcí:</p>
<ul>
<li>
<p><strong>Změna vnějších hodnot zevnitř funkce</strong> Hodnoty argumentů předávaných při
<a href="c/prace_s_pameti/../funkce/funkce.html#parametrizace-funkc%C3%AD">volání funkcí</a> se do funkce kopírují, nelze tak jednoduše
zevnitř funkce měnit hodnoty proměnných, které existují mimo danou funkci. To je sice samo o sobě
vhodná vlastnost, protože pokud bude funkce měnit pouze své lokální proměnné, případně parametry,
tak bude jednodušší se v ní vyznat. Nicméně, někdy opravdu chceme ve funkci změnit hodnoty externích
proměnných.</p>
<p>Toho můžeme dosáhnout tak, že si do funkce místo hodnoty proměnné pošleme její adresu v
ukazateli, a pomocí této adresy pak hodnotu proměnné změníme. Takto například můžeme vytvořit funkci,
která vezme adresy dvou proměnných a prohodí jejich hodnoty:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
void vymen(int* a, int* b) {
    int docasna_hodnota = *a;
    *a = *b;
    *b = docasna_hodnota;
}
int main() {
    int x = 5;
    int y = 10;
    vymen(&amp;x, &amp;y);
    printf(&quot;Po prehozeni: x=%d, y=%d\n&quot;, x, y);
    return 0;
}
</code></pre>
<details>
  <summary>Interaktivní vizualizace kódu</summary>
<iframe width="750" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=%23include%20%3Cstdio.h%3E%0Avoid%20vymen%28int*%20a,%20int*%20b%29%20%7B%0A%20%20%20%20int%20docasna_hodnota%20%3D%20*a%3B%0A%20%20%20%20*a%20%3D%20*b%3B%0A%20%20%20%20*b%20%3D%20docasna_hodnota%3B%0A%7D%0Aint%20main%28%29%20%7B%0A%20%20%20%20int%20x%20%3D%205%3B%0A%20%20%20%20int%20y%20%3D%2010%3B%0A%20%20%20%20vymen%28%26x,%20%26y%29%3B%0A%20%20%20%20printf%28%22Po%20prehozeni%3A%20x%3D%25d,%20y%3D%25d%5Cn%22,%20x,%20y%29%3B%0A%20%20%20%20return%200%3B%0A%7D&codeDivHeight=400&codeDivWidth=350&curInstr=12&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D"> </iframe>
</details>
</li>
<li>
<p><strong>Vrácení více návratových hodnot</strong> Posílání adres proměnných do funkce můžeme využít také k
tomu, abychom z funkce vrátili více než jednu návratovou hodnotu (do adres uložených v parametrech
totiž můžeme zapsat &quot;návratové&quot; hodnoty). Toho bychom však měli využívat pouze, pokud je to opravdu
nezbytné. Takovéto funkce je totiž složitější volat a nejsou
<a href="c/prace_s_pameti/../funkce/funkce.html#pro%C4%8D-n%C3%A1zev-funkce">čisté</a>, protože obsahují vedlejší efekt - mění externí stav
programu.</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void vrat_dve_hodnoty(int* a, int* b) {
    *a = 5;
    *b = 6;
}

int main() {
    int a = 0;
    int b = 0;
    vrat_dve_hodnoty(&amp;a, &amp;b);

    printf(&quot;a=%d, b=%d\n&quot;, a, b);

    return 0;
}
</code></pre>
</li>
<li>
<p><strong>Sdílení hodnot bez kopírování</strong> Pokud bychom měli proměnné, které v paměti zabírají velké
množství bytů (například <a href="c/prace_s_pameti/../struktury/struktury.html">struktury</a>), a předávali je jako argumenty
funkci, tak může být zbytečně pomalé je pokaždé kopírovat. Pokud do funkce pouze předáme jejich
adresu, tak dojde ke kopii pouze jednoho čísla s adresou, nezávisle na tom, jak velká je proměnná,
která je na dané adrese uložena. Ukazatele tak můžeme použít ke sdílení hodnot v paměti mezi funkcemi
bez toho, abychom je kopírovali.</p>
</li>
</ul>
<h2><a class="header" href="#konstantní-ukazatele" id="konstantní-ukazatele">Konstantní ukazatele</a></h2>
<p>Pokud použijeme klíčové slovo <a href="c/prace_s_pameti/../promenne/konstanty.html"><code>const</code></a> v kombinaci s ukazateli, je
potřeba si dávat pozor na to, k čemu se tohle klíčové slovo váže. To závisí na tom, zda je <code>const</code>
v datovém typu před nebo za hvězdičkou. Zde jsou možné kombinace, které můžou vzniknout u
jednoduchého ukazatele:</p>
<ul>
<li><code>int*</code> - ukazatel na celé číslo. Adresu v ukazateli lze měnit, hodnotu čísla na adrese v ukazateli
také lze měnit.</li>
<li><code>const int*</code> - ukazatel na konstantní celé číslo. Adresu v ukazateli lze měnit, hodnotu čísla na
adrese v ukazateli nikoliv.</li>
<li><code>int const *</code> - konstantní ukazatel na celé číslo. Adresu v ukazateli nelze měnit, hodnotu čísla na
adrese v ukazateli lze měnit.</li>
<li><code>const int const *</code> - konstantní ukazatel na konstantní celé číslo. Adresu v ukazateli nelze měnit,
hodnotu čísla na adrese v ukazateli také nelze měnit.</li>
</ul>
<h2><a class="header" href="#definice-více-ukazatelů-najednou" id="definice-více-ukazatelů-najednou">Definice více ukazatelů najednou</a></h2>
<p>Pokud byste chtěli vytvořit více ukazatelů
<a href="c/prace_s_pameti/../promenne/promenne.html#definice-v%C3%ADce-prom%C4%9Bnn%C3%BDch-najednou">najednou</a>, musíte si dát pozor na to, že
v tomto případě se hvězdička vztahuje pouze k jednomu následujícímu názvu proměnné. Tento kód tak
vytvoří ukazatel s názvem <code>x</code>, a dvě celá čísla s názvy <code>y</code> a <code>z</code>:</p>
<pre><code class="language-c">int* x, y, z;
</code></pre>
<p>Pokud byste chtěli vytvořit tři ukazatele, musíte dát hvězdičku před každý název proměnné:</p>
<pre><code class="language-c">int* x, *y, *z;
</code></pre>
<h1><a class="header" href="#ukazatele-na-funkce" id="ukazatele-na-funkce">Ukazatele na funkce</a></h1>
<blockquote>
<p>🤓 Tato sekce obsahuje doplňující učivo. Pokud je toho na vás moc, můžete ji prozatím přeskočit
a vrátit se k ní později.</p>
</blockquote>
<p>Ve funkcionálních jazycích<sup class='margin-toggle sidenote-number'>1</sup> můžeme <a href="c/prace_s_pameti/../funkce/funkce.html">funkce</a> používat jako kterékoliv jiné
hodnoty a provádět tak s nimi operace jako je uložení funkce do proměnné, předání funkce jako
argument jiné funkci, vrácení funkce jako návratové hodnoty z jiné funkce atd. V <em>C</em> tyto operace
s funkcemi přímo provádět nemůžeme, nicméně toto omezení lze alespoň částečně obejít použitím
<strong>ukazatele na funkci</strong> (<em>function pointer</em>).</p>
<span class='sidenote'><p><sup class='number'>1</sup>Jako je např. <a href="https://www.haskell.org/">Haskell</a>.</p>
</span>
<p>Ukazatel na funkci je číslo, které neinterpretujeme jako adresu nějaké hodnoty, ale jako
adresu kódu (tedy přeložených instrukcí) funkce v paměti běžícího programu. Tyto ukazatele se od
běžných ukazatelů liší tím, že používají jinou syntaxi a také umožňují zavolat funkci, jejíž adresa
je v ukazateli uložena.</p>
<h2><a class="header" href="#syntaxe-1" id="syntaxe-1">Syntaxe</a></h2>
<p>Syntaxe datového typu ukazatele na funkci vychází ze syntaxe <a href="c/prace_s_pameti/../funkce/funkce.html#syntaxe">signatury funkce</a>
a vypadá takto:</p>
<pre><code class="language-c">&lt;datový typ&gt; (*)(&lt;parametr 1&gt;, &lt;parametr 2&gt;, ...)
</code></pre>
<p>Zde je několik ukázek:</p>
<ul>
<li>Ukazatel na funkci, která vrací <code>int</code> a bere parametr <code>int</code>: <code>int (*)(int)</code></li>
<li>Ukazatel na funkci, která vrací <code>int</code> a bere parametry <code>int</code> a <code>bool</code>: <code>int (*)(int, bool)</code></li>
<li>Ukazatel na funkci, která nic nevrací a nemá žádné parametry: <code>void (*)()</code></li>
</ul>
<p>Ukazatel na funkci tak v podstatě odpovídá signatuře funkce, na kterou ukazuje, s tím rozdílem,
že místo názvu funkce obsahuje znaky <code>(*)</code>.</p>
<p>Jelikož v definici ukazatele na funkci jsou důležité hlavně datové typy parametrů, nemusíte jednotlivé
parametry pojmenovávat. Pokud ale chcete kód učinit přehlednější, můžete jim dát jména:</p>
<pre><code class="language-c">int (*)(int mocnina, int mocnitel); 
</code></pre>
<h2><a class="header" href="#použití-v-proměnné" id="použití-v-proměnné">Použití v proměnné</a></h2>
<p>Pokud chcete vytvořit promměnou (či parametr) datového typu ukazatel na funkce, tak musíte použít
speciální syntaxi. Běžně při vytváření proměnné nejprve napíšeme její datový typ a poté její název.
U ukazatele na funkci se však název proměnné nepíše až za datový typ, ale dovnitř závorek s hvězdičkou.
Takto lze vytvořit proměnnou s názvem <code>ukazatel1</code>, do které půjde uložit adresu funkcí, které vrací <code>int</code>
a berou dva parametry, oba typu <code>int</code>:</p>
<pre><code class="language-c">int (*ukazatel1)(int, int);
</code></pre>
<h2><a class="header" href="#inicializace-a-volání-funkce" id="inicializace-a-volání-funkce">Inicializace a volání funkce</a></h2>
<p>Pokud chcete nastavit do ukazatele na funkci nějakou hodnotu, stačí do něj přiřadit název existující
funkce.</p>
<pre><code class="language-c">int funkce(int x) {
    return x + 1;
}

int main() {
    int (*ukazatel)(int) = funkce;

    return 0;
}
</code></pre>
<p>Signature přiřazené funkce musí odpovídat datovému typu ukazatele, nelze tak například přiřadit
funkci, která nic nevrací, do ukazatele, který má signaturu <code>int (*)()</code>.</p>
<p>Jakmile máme v proměnné ukazatele na funkci uloženou adresu nějaké funkce, můžeme pomocí názvu této
proměnné danou funkci zavolat.</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int funkce(int x) {
    printf(&quot;Funkce zavolana s parametrem %d\n&quot;, x);
    return x + 1;
}

int main() {
    int (*ukazatel)(int) = funkce;
    
    int ret = ukazatel(1);
    printf(&quot;Funkce vratila %d\n&quot;, ret);

    return 0;
}
</code></pre>
<h2><a class="header" href="#případy-použití" id="případy-použití">Případy použití</a></h2>
<p>K čemu vlastně ukazatel na funkce může sloužit? Už víme, že pomocí funkcí můžeme
<a href="c/prace_s_pameti/../funkce/funkce.html#parametrizace-funkc%C3%AD">parametrizovat</a> kód, což nám umožňuje používat identický
kód nad různými vstupními hodnotami bez toho, abychom tento kód museli neustále duplikovat.</p>
<p>Prozatím jsme pro parametrizaci používali pouze jednoduché hodnoty, jako čísla nebo pravdivostní
hodnoty. Pomocí ukazatelů na funkce však můžeme parametrizovat samotný kód, který se má uvnitř
nějaké funkce provést.</p>
<p>Představte si například, že chcete vytvořit funkci, která provede nějakou operaci (např. přičtení
konstanty, vynásobení konstantou nebo vypsání na výstup) s číslem, ale pouze v případě, že toto číslo
je kladné. V opačném případě by měla funkce toto číslo pouze vrátit, bez jakékoliv změny. Jak byste
tuto funkci napsali, bez toho, abyste ji duplikovali pro každou operaci, která se má s kladným číslem
provést?</p>
<p>První řešení by mohlo vypadat například takto:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int proved_pro_kladne(int cislo, int operace) {
    if (cislo &lt;= 0) return cislo;
    
    if (operace == 0) {
        return cislo * 3;
    } else if (operace == 1) {
        return cislo + 1;
    } else {
        printf(&quot;Cislo: %d\n&quot;, cislo);
        return cislo;
    }
}

int main() {
    printf(&quot;%d\n&quot;, proved_pro_kladne(-1, 0));
    printf(&quot;%d\n&quot;, proved_pro_kladne(1, 0));
    printf(&quot;%d\n&quot;, proved_pro_kladne(1, 1));
    printf(&quot;%d\n&quot;, proved_pro_kladne(1, 2));

    return 0;
}
</code></pre>
<p>Toto řešení jistě bude fungovat, nicméně je dost nepraktické, protože musíme ve funkci
<code>proved_pro_kladne</code> dopředu vyjmenovat všechny možné operace, které lze s číslem provést. Pokud
bychom tak chtěli přidat novou operaci, budeme muset tuto funkci upravit. Zároveň je také dost
nepřehledné předávat funkci informaci o tom, jaká operace se má provést, pomocí proměnné typu <code>int</code>
(parametr <code>operace</code>).</p>
<p>Pomocí ukazatele na funkci můžeme funkci <code>proved_pro_kladne</code> předat kód<sup class='margin-toggle sidenote-number'>2</sup>, který se má provést,
pokud je předané číslo kladné. Pomocí toho můžeme od sebe oddělit logiku naší funkce (kontrola,
jestli je číslo kladné či ne) a samotnou operaci, která se má provést s kladným číslem.
Pokud tak vytvoříme novou operaci, nemusíme funkci <code>proved_pro_kladne</code> jakkoliv upravovat, stačí
ji zavolat s jiným argumentem.</p>
<span class='sidenote'><p><sup class='number'>2</sup>Ve formě adresy funkce.</p>
</span>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int proved_pro_kladne(int cislo, int(*operace)(int)) {
    if (cislo &lt;= 0) return cislo;
    return operace(cislo);
}

int vynasob_dvema(int cislo) { return cislo * 2; }
int pricti_jednicku(int cislo) { return cislo + 1; }
int vypis(int cislo) {
    printf(&quot;Cislo: %d\n&quot;, cislo);
    return cislo;
}

int main() {
    printf(&quot;%d\n&quot;, proved_pro_kladne(-1, vynasob_dvema));
    printf(&quot;%d\n&quot;, proved_pro_kladne(1, vynasob_dvema));
    printf(&quot;%d\n&quot;, proved_pro_kladne(1, pricti_jednicku));
    printf(&quot;%d\n&quot;, proved_pro_kladne(1, vypis));

    return 0;
}
</code></pre>
<p>Ukazatele na funkce nám umožňují vytvářet kód, který je více <em>composable</em>, jinak řečeno lze do
sebe skládat jako kostky Lega a nenutí nás zadrátovat možné způsoby použití dopředu (jako tomu bylo
v prvním řešení s parametrem <code>int operace</code>).</p>
<p>Ještě užitečnější jsou ukazatele na funkci v kombinacemi se zpracováním více hodnot pomocí
<a href="c/prace_s_pameti/../pole/pole.html">polí</a>, kdy můžeme napsat obecnou funkci, která nějak zpracovává pole, a předat jí
například ukazatel na funkci, která se má zavolat nad každým prvkem v poli. Hodí se také při práci
se <a href="c/prace_s_pameti/../struktury/struktury.html">strukturami</a>, kdy můžeme do atributu struktury uložit ukazatel na
funkci a přidat tak individuální chování k různým hodnotám struktur.</p>
<h1><a class="header" href="#dynamická-paměť" id="dynamická-paměť">Dynamická paměť</a></h1>
<p>Už víme, že pomocí <a href="c/prace_s_pameti/automaticka_pamet.html">automatické paměti</a> na zásobníku nemůžeme alokovat
velké množství paměti a nemůžeme ani alokovat paměť s dynamickou velikostí (závislou na velikosti
vstupu programu). Abychom tohoto dosáhli, tak musíme použít jiný mechanismus alokace paměti, ve
kterém paměť alokujeme i uvolňujeme manuálně.</p>
<p>Tento mechanismus se nazývá <strong>dynamická alokace paměti</strong> (<em>dynamic memory allocation</em>). Pomocí několika
funkcí standardní knihovny <em>C</em> můžeme naalokovat paměť s libovolnou velikosti. Tato paměť je
alokována v oblasti paměti zvané <strong>halda</strong> (<em>heap</em>). Narozdíl od zásobníku, prvky na haldě neleží
striktně za sebou, a lze je tak uvolňovat v libovolném pořadí. Můžeme tak naalokovat paměť libovolné
velikosti, která přežije i ukončení vykonávání funkce, díky čemuž tak můžeme sdílet (potenciálně velká)
data mezi funkcemi. Nicméně musíme také tuto paměť ručně uvolňovat, protože (narozdíl od zásobníku)
to za nás nikdo neudělá.</p>
<h2><a class="header" href="#alokace-paměti" id="alokace-paměti">Alokace paměti</a></h2>
<p>K naalokování paměti můžeme použít funkci <a href="https://devdocs.io/c/memory/malloc"><code>malloc</code></a> (<em>memory
alloc</em>), která je dostupná v souboru <code>stdlib.h</code> ze <a href="c/prace_s_pameti/../funkce/stdlib.html">standardní knihovny <em>C</em></a>.
Tato funkce má následující signaturu<sup class='margin-toggle sidenote-number'>1</sup>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Datový typ <a href="https://devdocs.io/c/types/size_t"><code>size_t</code></a> reprezentuje bezznaménkové
celé číslo, do kterého by měla jít uložit velikost největší možné hodnoty libovolného typu. Často
se používá pro indexaci <a href="c/prace_s_pameti/../pole/pole.html">polí</a>.</p>
</span>
<pre><code class="language-c">void* malloc(size_t size);
</code></pre>
<h3><a class="header" href="#velikost-alokované-paměti" id="velikost-alokované-paměti">Velikost alokované paměti</a></h3>
<p>Parametr <code>size</code> udává, kolik bytů paměti se má naalokovat. Tuto velikost můžeme &quot;tipnout&quot;
manuálně, nicméně to není moc dobrý nápad, protože bychom si museli pamatovat velikosti datových
typů (přičemž jejich velikost se může lišit v závislosti na použitém operačním systému či
překladači!). Abychom tomu předešli, tak můžeme použít operátor <code>sizeof</code>, kterému můžeme předat datový
typ<sup class='margin-toggle sidenote-number'>2</sup>. Tento výraz se poté vyhodnotí jako velikost daného datového typu:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Případně výraz, v tom případě si <code>sizeof</code> vezme jeho datový typ.</p>
</span>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;
int main() {
    printf(&quot;Velikost int je: %lu\n&quot;, sizeof(int));
    printf(&quot;Velikost int* je: %lu\n&quot;, sizeof(int*));
    return 0;
}
</code></pre>
<p>Návratový typ <code>void*</code> reprezentuje ukazatel na libovolná data. Funkce <code>malloc</code> musí fungovat pro
alokaci libovolného datového typu, proto musí mít jako návratový typ právě univerzální ukazatel
<code>void*</code>. Při zavolání funkce <code>malloc</code> bychom měli tento návratový typ
<a href="c/prace_s_pameti/../datove_typy/konverze.html">přetypovat</a> na ukazatel na datový typ, který alokujeme.</p>
<p>Při zavolání <code>malloc</code>u dojde k naalokování <code>size</code> bytů na haldě. Adresa prvního bytu této
naalokované paměti se poté vrátí jako návratová hodnota <code>malloc</code>u. Zde je ukázka programu, který
naalokuje paměť pro jeden <code>int</code> ve funkci, adresu naalokované paměti poté vrátí jako návratovou
hodnotu a naalokovaná paměť je poté přečtena ve funkci <code>main</code>:</p>
<pre><code class="language-c editable">#include &lt;stdlib.h&gt;

int* naalokuj_pamet() {
    int* pamet = (int*) malloc(sizeof(int));
    *pamet = 5;
    return pamet; 
}
int main() {
    int* pamet = naalokuj_pamet();
    printf(&quot;%d\n&quot;, *pamet);
    return 0;
}
</code></pre>
<details>
  <summary>Interaktivní vizualizace kódu</summary>
<iframe width="750" height="500" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=%23include%20%3Cstdlib.h%3E%0A%0Aint*%20naalokuj_pamet%28%29%20%7B%0A%20%20%20%20int*%20pamet%20%3D%20%28int*%29%20malloc%28sizeof%28int%29%29%3B%0A%20%20%20%20*pamet%20%3D%205%3B%0A%20%20%20%20return%20pamet%3B%20%0A%7D%0Aint%20main%28%29%20%7B%0A%20%20%20%20int*%20pamet%20%3D%20naalokuj_pamet%28%29%3B%0A%20%20%20%20printf%28%22%25d%5Cn%22,%20*pamet%29%3B%0A%20%20%20%20return%200%3B%0A%7D%0A&codeDivHeight=400&codeDivWidth=350&curInstr=8&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D"> </iframe>
</details>
<h3><a class="header" href="#iniciální-hodnota-paměti" id="iniciální-hodnota-paměti">Iniciální hodnota paměti</a></h3>
<p>Stejně jako u <a href="c/prace_s_pameti/../promenne/promenne.html#v%C5%BEdy-inicializujte-prom%C4%9Bnn%C3%A9">lokálních proměnných</a>, i u
dynamicky naalokované paměti platí, že její hodnota je zpočátku nedefinovaná. Než se tedy hodnotu
dané paměti pokusíte přečíst, musíte jí nainicializovat zápisem nějaké hodnoty! Jinak bude program
obsahovat nedefinované chování 💣.</p>
<p>Pokud byste chtěli, aby naalokovaná paměť byla rovnou při alokaci vynulována (všechny byty
nastavené na hodnotu <code>0</code>), můžete místo funkce <code>malloc</code> použít funkci
<a href="https://devdocs.io/c/memory/calloc"><code>calloc</code></a><sup class='margin-toggle sidenote-number'>3</sup>. Případně můžete použít užitečnou funkci
<a href="https://devdocs.io/c/string/byte/memset"><code>memset</code></a>, která vám vyplní blok paměti zadaným bytem.</p>
<span class='sidenote'><p><sup class='number'>3</sup>Pozor však na to, že tato funkce má jiné parametry než <code>malloc</code>. Očekává počet hodnot, které
se mají naalokovat, a velikost každé hodnoty.</p>
</span>
<h2><a class="header" href="#uvolnění-paměti" id="uvolnění-paměti">Uvolnění paměti</a></h2>
<p>S velkou mocí přichází i velká <a href="https://citaty.net/citaty/1957976-stan-lee-s-velkou-moci-prichazi-velka-odpovednost/">zodpovědnost</a>,
takže při použití dynamické paměti sice máme více možností než při použití automatické paměti
(resp. zásobníku), ale zároveň <strong>MUSÍME</strong> tuto paměť korektně uvolňovat (což se u automatické paměti
provádělo automaticky). Pokud bychom totiž paměť neustále pouze alokovali a neuvolňovali, tak by nám
<a href="c/prace_s_pameti/../../caste_chyby/pametove_chyby.html#memory-leak">brzy došla</a>.</p>
<p>Abychom paměť naalokovanou pomocí funkcí <code>malloc</code> či <code>calloc</code> uvolnili, tak musíme použít funkci
<a href="https://devdocs.io/c/memory/free"><code>free</code></a>:</p>
<pre><code class="language-c editable">#include &lt;stdlib.h&gt;

int main() {
    int* p = (int*) malloc(sizeof(int)); // alokace paměti
    *p = 0;                              // použití paměti
    free(p);                             // uvolnění paměti

    return 0;
}
</code></pre>
<p>Jako argument této funkci musíme předat ukazatel navrácený z volání <code>malloc</code>/<code>calloc</code>. Nic jiného
do této funkce nedávejte, uvolňovat můžeme pouze dynamicky alokovanou paměť! Nevolejte <code>free</code> s
adresami např. lokálních proměnných<sup class='margin-toggle sidenote-number'>4</sup>.</p>
<span class='sidenote'><p><sup class='number'>4</sup>Je však bezpečné uvolnit &quot;nulový ukazatel&quot;, tj. <code>free(NULL)</code> je validní (v tomto případě funkce nic neudělá).</p>
</span>
<p>Jakmile se paměť uvolní, tak už k této paměti nesmíte přistupovat! Pokud byste se pokusili přečíst
nebo zapsat uvolněnou paměť, tak dojde k nedefinovanému chování 💣. Nesmíte ani paměť uvolnit více
než jednou.</p>
<p>Při práci s dynamicky alokovanou pamětí tak dbejte zvýšené opatrnosti a ideálně používejte při
vývoji <a href="c/prace_s_pameti/../../prostredi/ladeni.html#address-sanitizer">Address sanitizer</a>. (Neúplný) seznam věcí,
které se můžou pokazit, pokud kombinaci dynamické alokace a uvolňování paměti pokazíte, naleznete
<a href="c/prace_s_pameti/../../caste_chyby/pametove_chyby.html">zde</a>.</p>
<h2><a class="header" href="#alokace-více-hodnot-zároveň" id="alokace-více-hodnot-zároveň">Alokace více hodnot zároveň</a></h2>
<p>Jak jste si mohli všimnout ze signatury funkce <code>malloc</code>, můžete jí dát libovolný počet bytů.
Nemusíte se tak omezovat velikostí základních datových typů, můžete například naalokovat paměť pro
5 <code>int</code>ů zároveň, které poté budou ležet za sebou v paměti a bude tak jednoduché k nim přistupovat
v cyklu. Jak tento koncept funguje se dozvíte v sekci o
<a href="c/prace_s_pameti/../pole/dynamicke_pole.html">dynamických polích</a>.</p>
<h1><a class="header" href="#globální-paměť" id="globální-paměť">Globální paměť</a></h1>
<p>Posledním základním typem paměti je tzv. globální (nazývaná také statická) paměť. Tato paměť je
specifická tím, že vzniká při spuštění programu a zaniká při jeho ukončení, lze ji tak používat
během celé délky běhu programu.</p>
<p><a href="c/prace_s_pameti/../promenne/globalni_promenne.html">Globální proměnné</a> jsou umístěny v globální paměti. Je dobré si
uvědomit, že tyto proměnné zároveň zabírají místo ve spustitelném souboru na disku, protože v něm
musí být uložena jejich iniciální hodnota<sup class='margin-toggle sidenote-number'>1</sup>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Pokud tedy nejsou
<a href="c/prace_s_pameti/../promenne/globalni_promenne.html#inici%C3%A1ln%C3%AD-hodnota">inicializované na nulu</a>).</p>
</span>
<p>V globální paměti také leží samotné instrukce programu, který právě běží. Jsou tam umístěné funkce,
které jste napsali a které poté byly přeloženy na strojové instrukce a uloženy ve spustitelném souboru.</p>
<h1><a class="header" href="#pole" id="pole">Pole</a></h1>
<p>Nyní už známe základy alokování paměti v jazyce <em>C</em>, zatím ale stále umíme pracovat pouze
s jednotkami proměnných. Počítače slouží k (rychlému) zpracování velkého objemu dat, a abychom je
tak naplno využili, chtěli bychom zpracovávat mnoho proměnných najednou. Například:</p>
<ul>
<li>V dokumentu otevřeném ve Wordu můžeme mít uložené tisíce různých znaků.</li>
<li>Na server v online hře může v danou chvíli být připojené velké množství hráčů a všem musíme
posílat informace o stavu hry.</li>
<li>Obrázky se běžně v programech reprezentují jako dvourozměrná mřížka pixelů. Například obrázek
ve stupních šedi s rozměry <code>1024x1024</code> vyžaduje držet v paměti <code>1048576</code> bytů (čísel) reprezentujících
jednotlivé pixely.</li>
</ul>
<p>Asi si dovedete představit, že například pro reprezentaci obrázku bychom si s proměnnými, které jsme
používali doposud, nevystačili. Pokud bychom po jedné vytvářeli proměnné <code>pixel1</code>, <code>pixel2</code>,
<code>pixel3</code>, tak by jednak byl náš zdrojový kód obrovský a nedalo by se v něm vyznat, a také bychom
nemohli mít velikost obrázku závislou na vstupu programu, protože počet proměnných by byl
&quot;zadrátovaný&quot; ve zdrojovém kódu programu. Chtěli bychom tak mít možnost napsat kód, který bude umět
zpracovat 1, 2, 100 nebo třeba 1000 hodnot bez toho, abychom tento kód museli jakkoliv měnit.</p>
<p>Asi nejběžnějším a nejjednodušším způsobem, jak v paměti počítače uchovávat větší množství hodnot,
je uložit všechny hodnoty jednu po druhé za sebou v paměti. Tento koncept uložení dat se nazývá
<strong>pole</strong> (<em>array</em>)<sup class='margin-toggle sidenote-number'>1</sup> a je tak běžný, že ho programovací jazyky obvykle přímo podporují ve své syntaxi,
a jazyk <em>C</em> není výjimkou.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Způsoby, jak v paměti počítače uchovávat komplexní a rozsáhlá data, se nazývají
<a href="https://cs.wikipedia.org/wiki/Datov%C3%A1_struktura">datové struktury</a>. Pole je jednou z
nejjednodušších datových struktur.</p>
</span>
<p>V následujících sekcích se dozvíte, jak s poli pracovat, jak je vytvořit v
<a href="c/pole/staticke_pole.html">automatické</a> a <a href="c/pole/dynamicke_pole.html">dynamické paměti</a> a jak lze v počítači
reprezentovat <a href="c/pole/vicerozmerne_pole.html">vícerozměrná pole</a>.</p>
<h1><a class="header" href="#statické-pole" id="statické-pole">Statické pole</a></h1>
<p>Pole v <a href="c/pole/../prace_s_pameti/automaticka_pamet.html">automatické paměti</a><sup class='margin-toggle sidenote-number'>1</sup> (na zásobníku) se označují
jako <strong>statická pole</strong> (<em>static arrays</em>). Můžeme je vytvořit tak, že za název proměnné přidáme
hranaté závorky s číslem udávající počet prvků v poli. Takto například vytvoříme pole celých čísel
s třemi prvky:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Pole můžete tímto způsobem vytvořit také v
<a href="c/pole/../prace_s_pameti/globalni_pamet.html">globální paměti</a>, pokud vytvoříte
<a href="c/pole/../promenne/globalni_promenne.html">globální proměnnou</a> datového typu pole.</p>
</span>
<pre><code class="language-c">int pole[3];
</code></pre>
<p>Takováto proměnná bude obsahovat paměť pro 3 celá čísla (tedy nejspíše na vašem počítači dohromady
12 bytů). Počet prvků v poli se označuje jako jeho <strong>velikost</strong> (<em>size</em>).</p>
<blockquote>
<p>Pozor na to, že hranaté závorky se udávají za název proměnné, a ne za název datového typu.
<code>int[3] pole;</code> je tedy špatně.</p>
</blockquote>
<p>Čísla takového pole budou v paměti uložena jeden za druhým<sup class='margin-toggle sidenote-number'>2</sup>:
<upr-container>
<upr-array array='[0, 0, 0]'></upr-array>
</upr-container></p>
<span class='sidenote'><p><sup class='number'>2</sup>Každý zelený čtverec na tomto obrázku reprezentuje 4 byty v paměti (velikost jednoho <code>int</code>u).</p>
</span>
<p>V jistém smyslu je tak pole pouze zobecněním normální proměnné. Pokud totiž vytvoříte pole o
velikosti jedna (<code>int a[1]</code>), tak v paměti bude reprezentováno úplně stejně jako klasická proměnná
(<code>int a</code>).</p>
<blockquote>
<p>Pole lze vytvořit také na haldě pomocí <a href="c/pole/dynamicke_pole.html">dynamické alokace paměti</a>. Všechny níže
popsané koncepty jsou platné i pro dynamická pole, nicméně budeme je demonstrovat na statických
polích, protože ty je jednodušší vytvořit.</p>
</blockquote>
<h3><a class="header" href="#konstantní-velikost-statického-pole" id="konstantní-velikost-statického-pole">Konstantní velikost statického pole</a></h3>
<p>Hodnota zadaná v hranatých závorkách by měla být konstantní (tj. buď přímo číselná hodnota anebo
<a href="c/pole/../promenne/konstanty.html">konstantní proměnná</a>). Pokud budete potřebovat pole dynamické velikosti,
tak byste měli použít <a href="c/pole/dynamicke_pole.html">dynamickou alokaci paměti</a>.</p>
<p>Jazyk <em>C</em> od verze <a href="https://en.wikipedia.org/wiki/C99"><em>C99</em></a> již sice povoluje dávat do hranatých
závorek i &quot;dynamické&quot; hodnoty, tj. výrazy, jejichž hodnota nemusí být známa v době překladu:</p>
<pre><code class="language-c">int velikost = ...; // velikost se načte např. ze souboru
int pole[velikost];
</code></pre>
<p>Nicméně tuto <a href="https://en.wikipedia.org/wiki/Variable-length_array">funkcionalitu</a> raději nepoužívejte.
Zásobník má značně <a href="c/pole/../prace_s_pameti/automaticka_pamet.html#nev%C3%BDhody-automatick%C3%A9-pam%C4%9Bti">omezenou velikost</a>
a není určen pro alokaci velkého množství paměti<sup class='margin-toggle sidenote-number'>3</sup>. Pokud navíc velikost takovéhoto pole může ovlivnit
uživatel programu (např. zadáním vstupu), může váš program jednoduše &quot;shodit&quot;, pokud by zadal velké
číslo a došlo by k pokusu o vytvoření velkého pole na zásobníku. Zkuste se tak vyvarovat používání
dynamických hodnot při vytváření polí na zásobníku.</p>
<span class='sidenote'><p><sup class='number'>3</sup>Můžete si například zkusit přeložit následující program:</p>
<pre><code class="language-c">int main() {
    int pole[10000000];
    return 0;
}
</code></pre>
<p>Při spuštění by měl program selhat na
<a href="c/pole/../../caste_chyby/pametove_chyby.html#segmentation-fault">paměťovou chybu</a>, i když váš počítač má
pravděpodobně více než <code>10000000 * 4</code> (cca <code>38</code> MiB) paměti. Pokud chcete alokovat více než několik
stovek bytů, použijte raději <a href="c/pole/dynamicke_pole.html">dynamickou alokaci</a> na haldě.</p>
</span>
<h2><a class="header" href="#počítání-od-nuly" id="počítání-od-nuly">Počítání od nuly</a></h2>
<p>Pozice jednotlivých prvků v poli se označují jako jejich <strong>indexy</strong> (<em>array indices</em>). Tyto pozice
se číslují od hodnoty <code>0</code> (tedy ne od jedničky, jak můžete být jinak zvyklí). První prvek pole je
tedy ve skutečnosti na nulté pozici (indexu), druhý na první pozici atd. (viz obrázek nahoře).
<strong>Počítání od nuly</strong> (<em>zero-based indexing</em>) je ve světě programování běžné a budete si na něj
muset zvyknout. Jeden z důvodů, proč se prvky počítají právě od nuly, se dozvíte
<a href="c/pole/staticke_pole.html#p%C5%99%C3%ADstup-k-prvk%C5%AFm-pole">níže</a>.</p>
<p>Z tohoto vyplývá jedna důležitá vlastnost - poslední prvek pole je vždy na indexu
<code>&lt;velikost pole&gt; - 1</code>! Pokud byste se pokusili přistoupit k prvku na indexu <code>&lt;velikost pole&gt;</code>,
budete přistupovat mimo paměť pole, což pravděpodobně způsobí
<a href="c/pole/../../caste_chyby/pametove_chyby.html">paměťovou chybu</a>.</p>
<h2><a class="header" href="#inicializace-pole" id="inicializace-pole">Inicializace pole</a></h2>
<p>Stejně jako u normálních lokálních proměnných
<a href="c/pole/../promenne/promenne.html#v%C5%BEdy-inicializujte-prom%C4%9Bnn%C3%A9">platí</a>, že pokud pole nenainicializujete,
tak bude obsahovat nedefinované hodnoty. V takovém případě nesmíte hodnoty v poli jakkoliv číst,
jinak by došlo k nedefinovanému chování 💣! K inicializaci pole můžete použít složené závorky se
seznamem hodnot oddělených čárkou, které budou do pole uloženy. Pokud nezadáte dostatek hodnot
pro vyplnění celého pole, tak zbytek hodnot bude nastaveno na nulu.</p>
<pre><code class="language-c">int a[3];               // pole bez definované hodnoty, nepoužívat!
int b[3] = {};          // pole s hodnotami 0, 0, 0
int c[4] = { 1 };       // pole s hodnotami 1, 0, 0, 0
int d[2] = { 2, 3 };    // pole s hodnotami 2, 3
</code></pre>
<p>Hodnot samozřemě nemůžete zadat více, než je velikost pole.</p>
<p>Pokud využijete inicializaci statického pole, můžete vynechat velikost pole v hranatých závorkách.
Překladač v tomto případě dopočítá velikost za vás:</p>
<pre><code class="language-c">int p[] = { 1, 2, 3 }; // p je pole s třemi čísly, překladač si odvodí int p[3]
</code></pre>
<h2><a class="header" href="#přístup-k-prvkům-pole" id="přístup-k-prvkům-pole">Přístup k prvkům pole</a></h2>
<p>Abychom využili toho, že nám pole umožňují vytvořit větší množství paměti najednou, musíme mít
možnost přistupovat k jednotlivým prvkům v poli. K tomu můžeme využít
<a href="c/pole/../prace_s_pameti/ukazatele.html">ukazatelů</a>. Proměnná pole se totiž chová jako ukazatel na první
prvek (prvek na nultém indexu!) daného pole, pomocí operátoru
<a href="c/pole/../prace_s_pameti/ukazatele.html#p%C5%99%C3%ADstup-k-pam%C4%9Bti-pomoc%C3%AD-ukazatele">dereference</a> tak k tomutu prvku
můžeme jednoduše přistoupit:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pole[3] = { 1, 2, 3 };
    printf(&quot;%d\n&quot;, *pole);
    return 0;
}
</code></pre>
<p>Abychom přistoupili i k dalším prvkům v poli, tak můžeme využít
<a href="c/pole/../prace_s_pameti/ukazatele.html#aritmetika-s-ukazateli">aritmetiky s ukazateli</a>. Pokud chceme
získat adresu prvku na <code>i</code>-tém indexu, stačí k ukazateli na první prvek přičíst <code>i</code><sup class='margin-toggle sidenote-number'>4</sup>:</p>
<span class='sidenote'><p><sup class='number'>4</sup>Všimněte si, že při použití operátoru dereference zde používáme závorky. Je to z důvodu
<a href="https://en.cppreference.com/w/c/language/operator_precedence">priority operátorů</a>. Výraz <code>*pole + 2</code>
by se vyhodnotil jako první prvek z pole <code>pole</code> plus <code>2</code>, protože <code>*</code> (dereference) má větší
prioritu než sčítání. </p>
</span>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pole[3] = { 1, 2, 3 };
    printf(&quot;%d\n&quot;, *(pole + 0));   // první prvek pole
    printf(&quot;%d\n&quot;, *(pole + 1));   // druhý prvek pole
    printf(&quot;%d\n&quot;, *(pole + 2));   // třetí prvek pole
    return 0;
}
</code></pre>
<p>Nyní už možná tušíte, proč se při práci s poli vyplatí počítat od nuly. Prvek na nultém indexu je
totiž vzdálen nula prvků od začátku pole. Prvek na prvním indexu je vzdálen jeden prvek od začátku
pole atd. Pokud bychom indexovali od jedničky, museli bychom při výpočtu adresy relativně k ukazateli
na začátek pole vždy odečíst jedničku, což by bylo nepraktické.</p>
<blockquote>
<p>Přistupování k prvkům pole se běžně označuje pojmem <strong>indexování pole</strong>.</p>
</blockquote>
<h2><a class="header" href="#operátor-přístupu-k-poli" id="operátor-přístupu-k-poli">Operátor přístupu k poli</a></h2>
<p>Jelikož je operace přístupu k poli (&quot;posunutí&quot; ukazatele a jeho dereference) velmi
běžná (a zároveň relativně krkolomná), <em>C</em> obsahuje speciální operátor, který ji zjednodušuje.
Tento operátor se nazývá <em>array subscription operator</em> a má syntaxi</p>
<p><code>&lt;výraz a&gt;[&lt;výraz b&gt;]</code></p>
<p>Slouží jako zkratka<sup class='margin-toggle sidenote-number'>5</sup> za výraz</p>
<span class='sidenote'><p><sup class='number'>5</sup>Takovéto &quot;zkratky&quot;, které v programovacím jazyku nepřináší novou funkcionalitu, pouze zkracují
či zjednoduššují často používané kombinace příkazů, se označují jako
<a href="https://en.wikipedia.org/wiki/Syntactic_sugar"><strong>syntactic sugar</strong></a>.</p>
</span>
<p><code>*(&lt;výraz a&gt; + &lt;výraz b&gt;)</code></p>
<p>Příklad:</p>
<ul>
<li><code>pole[0]</code> je ekvivalentní výrazu <code>*(pole + 0)</code></li>
<li><code>pole[5]</code> je ekvivalentní výrazu <code>*(pole + 5)</code></li>
</ul>
<pre><code class="language-c">int pole[3] = { 1, 2, 3 };
pole[0] = 5;       // nastavili jsme první prvek pole na hodnotu `5`
int c = pole[2];   // nastavili jsme `c` na hodnotu posledního (třetího) prvku pole
</code></pre>
<p>Jelikož je používání hranatých závorek přehlednější než používání závorek a hvězdiček, doporučujeme
je používat pro přistupování k prvkům pole, pokud to půjde.</p>
<blockquote>
<p>Pozor na rozdíl mezi tímto operátorem a definicí pole. Obojí sice používá hranaté závorky, ale
jinak spolu tyto dvě věci nesouvisejí. Podobně jako se <code>*</code> používá pro definici datového typu
ukazatele a <a href="c/pole/../prace_s_pameti/ukazatele.html#p%C5%99%C3%ADstup-k-pam%C4%9Bti-pomoc%C3%AD-ukazatele">zároveň</a>
jako operátor dereference (navíc i jako operátor pro násobení). Vždy záleží na kontextu, kde jsou
tyto znaky použity.</p>
</blockquote>
<h2><a class="header" href="#použití-polí-s-cykly" id="použití-polí-s-cykly">Použití polí s cykly</a></h2>
<p>Pokud bychom k polím přistupovali po individuálních prvcích, tak bychom nemohli využít jejich plný
potenciál. I když umíme jedním řádkem kódu vytvořit například 100 různých hodnot (<code>int pole[100];</code>),
pokud bychom museli psát <code>pole[0]</code>, <code>pole[1]</code> atd. pro přístup k jednotlivým prvkům, tak bychom
nemohli s polem efektivně pracovat. Smyslem polí je umožnit zpracování velkého množství dat jednotným
způsobem pomocí krátkého kusu kódu. Jinak řečeno, chtěli bychom mít stejný kód, který umí zpracovat
pole o velikosti <code>2</code> i <code>1000</code>. K tomu můžeme efektivně využít <a href="c/pole/../rizeni_toku/cykly.html">cykly</a>.</p>
<p>Často je praktické použít <a href="c/pole/../rizeni_toku/while.html#%C5%98%C3%ADd%C3%ADc%C3%AD-prom%C4%9Bnn%C3%A1">řídící proměnnou</a> cyklu k tomu,
abychom pomocí ní indexovali pole. Například, pokud bychom měli pole s velikostí <code>10</code>, tak ho můžeme
&quot;projít&quot;<sup class='margin-toggle sidenote-number'>6</sup> pomocí cyklu <code>for</code>:</p>
<span class='sidenote'><p><sup class='number'>6</sup>Používá se také pojem <em>proiterovat</em>.</p>
</span>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int pole[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    for (int i = 0; i &lt; 10; i++) {
        printf(&quot;%d &quot;, pole[i]);
    }
    return 0;
}
</code></pre>
<p>Situace, kdy pomocí cyklu projdeme pole, je velmi častá a určitě se s ní mnohokrát setkáte a
využijete ji. Zkuste si to procvičit například pomocí
<a href="c/pole/../../ulohy/pole.html#minim%C3%A1ln%C3%AD-hodnota-v-poli">těchto úloh</a>.</p>
<h2><a class="header" href="#předávání-pole-do-funkcí" id="předávání-pole-do-funkcí">Předávání pole do funkcí</a></h2>
<p>Pole můžeme (stejně jako hodnoty jiných datových typů) předávat jako argumenty do funkcí.
Musíme si při tom však dávat pozor zejména na dvě věci.</p>
<h3><a class="header" href="#převod-pole-na-ukazatel" id="převod-pole-na-ukazatel">Převod pole na ukazatel</a></h3>
<p>Už víme, že když předáváme <a href="c/pole/../funkce/funkce.html#parametrizace-funkc%C3%AD">argumenty</a> do funkcí, tak se
jejich hodnota zkopíruje. U statických polí tomu tak ovšem není, protože pole můžou být potenciálně
velmi velká a provádění kopií polí by tak potenciálně mohlo brzdit provádění programu. Když tak
použijeme proměnnou pole jako argument při volání funkce, dojde k tzv. <strong>konverzi pole na ukazatel</strong>
(<em>array to pointer decay</em>). Pole se tak vždy předá jako ukazatel na jeho první prvek:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void vypis_pole(int* pole) {
    printf(&quot;%d\n&quot;, pole[0]);
}

int main() {
    int pole[3] = { 1, 2, 3 };
    vypis_pole(pole);
    return 0;
}
</code></pre>
<p>Pro parametry sice můžete použít datový typ pole:</p>
<pre><code class="language-c">void vypis_pole(int pole[3]) { ... }
</code></pre>
<p>nicméně i v tomto případě se bude takovýto parametr chovat stejně jako ukazatel (v tomto případě
tedy <code>int*</code>). Navíc překladač ani nebude kontrolovat, jestli do takového parametru opravdu dáváme
pole se správnou velikostí. Pro parametry reprezentující pole tak raději rovnou používejte ukazatel.</p>
<h3><a class="header" href="#předávání-velikosti-pole" id="předávání-velikosti-pole">Předávání velikosti pole</a></h3>
<p>Když ve funkci přijmeme jako parametr ukazatel na pole, tak nevíme, kolik prvků v tomto poli je.
Tato informace je ale stěžejní, bez ní totiž nevíme, ke kolika prvkům pole si můžeme dovolit
přistupovat. Pokud tedy ukazatel na pole předáváme do funkce, je obvykle potřeba zároveň s ním
předat i délku daného pole:</p>
<pre><code class="language-c">int secti_pole(int* pole, int velikost) {
    int soucet = 0;
    for (int i = 0; i &lt; velikost; i++) {
        soucet += pole[i];
    }
    return soucet;
}
</code></pre>
<h4><a class="header" href="#výpočet-velikosti-pole" id="výpočet-velikosti-pole">Výpočet velikosti pole</a></h4>
<p>Abyste při změně velikosti statického pole nemuseli ručně jeho velikost upravovat na více místech v
kódu, tak můžete ve funkci, kde definujete statické pole, vypočítat jeho velikost pomocí operátoru
<code>sizeof</code>:</p>
<pre><code class="language-c">int pole[3] = { 1, 2, 3 };
printf(&quot;Velikost pole v bytech: %lu\n&quot;, sizeof(pole));
</code></pre>
<p>Abyste zjistili počet prvků ve statickém poli, můžete velikost v bytech vydělit velikostí každého
prvku v poli:</p>
<pre><code class="language-c">int pole[3] = { 1, 2, 3 };
printf(&quot;Pocet prvku v poli: %lu\n&quot;, sizeof(pole) / sizeof(pole[0]));
</code></pre>
<blockquote>
<p>Operátor <code>sizeof</code> bude pro toto použití fungovat pouze pro statické pole a pouze ve funkci, ve které
statické pole vytváříte! Pokud pole pošlete do jiné funkce, už z něj bude pouze ukazatel, pro který
<code>sizeof</code> vrátí velikost ukazatele (což bude na vašem PC nejspíše <code>8</code> bytů).</p>
</blockquote>
<h1><a class="header" href="#dynamické-pole" id="dynamické-pole">Dynamické pole</a></h1>
<p>Pole alokovaná na zásobníku by měly mít velikost danou při překladu programu, často ale potřebujeme
vytvářet pole v závislosti na vstupu programu (například když načítáme soubor, tak dopředu nevíme,
kolik bude mít řádků). Ze sekce o <a href="c/pole/../prace_s_pameti/dynamicka_pamet.html">dynamické paměti</a> již víme,
jak alokovat libovolné množství paměti na haldě pomocí funkce <code>malloc</code>. Pro vytvoření
<strong>dynamického pole</strong> (<em>dynamic array</em>) tak stačí použít funkci <code>malloc</code>. Například pro vytvoření
dynamického pole pro <code>5</code> celých čísel potřebujeme naalokovat <code>5 * sizeof(int)</code> bytů:</p>
<pre><code class="language-c">int* pole = (int*) malloc(5 * sizeof(int));
</code></pre>
<p>S takovouto pamětí pak můžeme pracovat jako s polem <code>int</code>ů o velikosti <code>5</code>. Jakmile již takovéto
pole nepotřebujeme, nesmíme jej samozřejmě zapomenout
<a href="c/pole/../prace_s_pameti/dynamicka_pamet.html#uvoln%C4%9Bn%C3%AD-pam%C4%9Bti">uvolnit</a>.</p>
<h2><a class="header" href="#změna-velikosti-pole" id="změna-velikosti-pole">Změna velikosti pole</a></h2>
<p>Občas potřebujeme velikost dynamického pole změnit (obvykle zvětšit). Například pokud vám
uživatel zadává na vstupu seznam čísel, na začátku můžete vytvořit paměť pro 10 čísel, ale při
zadání 11. čísla musíte tuto paměť zvětšit, jinak byste neměli nové číslo kam zapsat. Tento proces
se nazývá <strong>realokace</strong> (<em>reallocation</em>) a lze jej provést například následujícím způsobem:</p>
<ol>
<li>Naalokujeme nové dynamické pole o požadované velikosti</li>
<li>Zkopírujeme obsah původního pole do nového pole </li>
<li>Uvolníme paměť původního pole</li>
<li>Upravíme odpovídající ukazatel(e) v programu, aby ukazoval(y) na nově naalokované pole</li>
</ol>
<p>Pokud se vám toto nechce programovat ručně, tak můžete také použít funkci
<a href="https://devdocs.io/c/memory/realloc"><code>realloc</code></a> ze standardní knihovny <em>C</em>, která to udělá za vás.
Tato funkce očekává původní adresu alokace z <code>malloc</code>/<code>calloc</code> a počet bytů nové alokace.</p>
<hr />
<p><strong>Cvičení</strong>: Zkuste naprogramovat funkci <code>realokace</code>, která obdrží dynamicky naalokované pole
(tedy ukazatel), jeho původní velikost a novou velikost. Funkce realokuje pole na novou velikost a
vrátí ukazatel na nově naalokované pole.</p>
<hr />
<h1><a class="header" href="#vícerozměrné-pole" id="vícerozměrné-pole">Vícerozměrné pole</a></h1>
<p>Někdy potřebujeme v programech reprezentovat věci, které jsou přirozeně vícerozměrné. Typickým
příkladem jsou obrázky, které lze reprezentovat jako dvourozměrnou mřížku pixelů (jeden rozměr udává
řádky a druhý sloupce).</p>
<p><a href="c/pole/../../uvod/pamet.html">Paměťové adresy</a> však mají pouze jeden rozměr, jelikož jsou reprezentovány
jedním číslem. Jak tedy můžeme do jednorozměrné paměti uložit vícerozměrnou hodnotu? Způsobů je více,
nicméně asi nejjednodušší je prostě &quot;vyskládat&quot; jednotlivé rozměry (dimenze) v paměti za sebou,
jeden rozměr za druhým. Pokud bychom například měli dvojrozměrnou mřížku<sup class='margin-toggle sidenote-number'>1</sup> s rozměry <code>5x5</code>,
můžeme ji reprezentovat tak, že nejprve do paměti uložíme první řádek, poté druhý řádek atd.: </p>
<span class='sidenote'><p><sup class='number'>1</sup>Reprezentující například obrázek či <a href="https://matematika.cz/matice">matici</a>.</p>
</span>
<p><img src="c/pole/../../static/img/2d_array.svg" alt="2D pole" /></p>
<p>Tento koncept se označuje jako <strong>vícerozměrné pole</strong> (<em>multidimensional array</em>).</p>
<h2><a class="header" href="#způsob-vyskládání-dimenzí" id="způsob-vyskládání-dimenzí">Způsob vyskládání dimenzí</a></h2>
<p>Je na nás, v jakém pořadí jednotlivé dimenze do paměti uložíme. Pokud bychom se bavili o 2D poli,
tak můžeme do paměti uložit řádek po řádku (viz obrázek výše), což se označuje jako
<strong>row major ordering</strong>. Můžeme ale také do paměti vyskládat sloupec po sloupci, což se nazývá
<strong>column major ordering</strong>. Je víceméně jedno, který způsob použijeme, je ale důležité se držet
jednoho přístupu, jinak může dojít k záměně indexů. Indexování totiž záleží na tom, jaký způsob
vyskládání použijeme. Níže předpokládáme pořadí <em>row major</em>.</p>
<h2><a class="header" href="#indexování" id="indexování">Indexování</a></h2>
<p>Při práci s dvourozměrným polem bychom chtěli pracovat s dvourozměrným indexem (řádek <code>i</code>, sloupec
<code>j</code>), nicméně při samotném přístupu do paměti pak musíme tento vícerozměrný index převést na 1D
index. A naopak, z 1D indexu bychom chtěli mít možnost získat zpět 2D index. Pro výpočet indexů 2D
pole s <code>vyska</code> řádky a <code>sirka</code> sloupci můžeme použít tyto jednoduché vzorce:</p>
<ul>
<li><strong>Převod z 2D do 1D</strong> - abychom se dostali na cílovou pozici, musíme přeskočit <code>radek</code> řádků, kde
každý řádek má <code>sirka</code> prvků, a poté ještě musíme přičíst pozici sloupce (<code>sloupec</code>).
<pre><code class="language-c">int index_2d_na_1d(int radek, int sloupec, int sirka) {
    return radek * sirka + sloupec;
}
</code></pre>
</li>
<li><strong>Převod z 1D do 2D</strong> - pro převod z 1D indexu zpět na 2D index stačí aplikovat opačný postup.
Nejprve vydělíme 1D index počtem sloupců, abychom zjistili, na jakém jsme řádku, a poté použijeme
zbytek po dělení, abychom zjistili, na jakém jsme sloupci.
<pre><code class="language-c">void index_1d_na_2d(int index, int sirka, int* radek, int* sloupec) {
    *radek = index / sirka;
    *sloupec = index % sloupec;
}
</code></pre>
</li>
</ul>
<p>Tento koncept lze zobecnit na libovolně rozměrné pole (3D, 4D, …).</p>
<h2><a class="header" href="#vícerozměrné-pole-v-c" id="vícerozměrné-pole-v-c">Vícerozměrné pole v <em>C</em></a></h2>
<p><em>C</em> obsahuje základní podporu pro vytváření vícerozměrných <a href="c/pole/staticke_pole.html">statických polí</a>. Při
vytváření pole stačí použít hranaté závorky pro každou dimenzi pole. Například takto lze vytvořit
2D pole s rozměry <code>3x3</code> na zásobníku:</p>
<pre><code class="language-c">int pole[3][3];
</code></pre>
<p>Výhoda takovýchto polí je, že překladač provede převod z 2D indexu na 1D index za vás, a můžete tak
toto pole přímo indexovat vícerozměrným indexem. Například první prvek pole z kódu výše lze nalézt
na pozici <code>pole[0][0]</code>, poslední na pozici <code>pole[2][2]</code>.</p>
<p>Takováto pole jsou v paměti vyskládána postupně dle jednotlivých dimenzí zleva. Nejprve tedy v
paměti leží prvek <code>pole[0][0]</code>, poté <code>pole[0][1]</code>, …, <code>pole[1][1]</code>, <code>pole[1][2]</code> atd. Pokud
bychom měli 2D pole a první index bychom pokládali za index řádku, tak toto vyskládání odpovídá
<em>row major</em> pořadí.</p>
<p>Vícerozměrná pole v <em>C</em> lze zobecnit do vyšších dimenzí (můžete tak použít například
<code>int pole[3][3][3]</code> atd.), nicméně je dobré to nepřehánět, aby kód zůstal přehledný.</p>
<h3><a class="header" href="#inicializace-vícerozměrných-polí" id="inicializace-vícerozměrných-polí">Inicializace vícerozměrných polí</a></h3>
<p>Vícerozměrné pole můžete nainicializovat <a href="c/pole/staticke_pole.html#inicializace-pole">stejně</a> jako klasické
pole. Pro zpřehlednění kódu však také můžete použít složené závorky pro oddělení jednotlivých
dimenzí:</p>
<pre><code class="language-c">int pole_2d[3][4] = {  
   {0, 1, 2, 3},    // hodnoty pro první řádek
   {4, 5, 6, 7},    // hodnoty pro druhý řádek
   {8, 9, 10, 11}   // hodnoty pro třetí řádek
};
</code></pre>
<h2><a class="header" href="#vícerozměrné-dynamické-pole" id="vícerozměrné-dynamické-pole">Vícerozměrné dynamické pole</a></h2>
<p>Pokud potřebujete vícerozměrné pole s <a href="c/pole/dynamicke_pole.html">dynamickou velikostí</a>, stačí při volání
funkce <code>malloc</code> vytvořit dostatek paměti pro všechny rozměry. Pokud bychom například chtěli
naalokovat paměť pro 2D obrázek s <code>vyska</code> řádky a <code>sirka</code> řádky, můžeme použít následující volání
funkce <code>malloc</code>:</p>
<pre><code class="language-c">int* pamet_obrazku = (int*) malloc(vyska * sirka * sizeof(int)));
</code></pre>
<h1><a class="header" href="#zubatá-pole" id="zubatá-pole">Zubatá pole</a></h1>
<blockquote>
<p>🤓 Tato sekce obsahuje doplňující učivo. Pokud je toho na vás moc, můžete ji prozatím přeskočit
a vrátit se k ní později.</p>
</blockquote>
<p>Občas můžete narazit na situaci, kdy potřebujete vytvořit vícerozměrné pole, kde některá z dimenzí
nemá fixní velikost. Například první řádek může mít dva sloupce, druhý řádek tři sloupce, třetí řádek
žádný sloupec atd.</p>
<p>V takovém případě můžete vytvořit tzv. <strong>zubaté pole</strong> (<em>jagged array</em> nebo také <em>ragged array</em>).
Zubaté pole je v podstatě &quot;pole polí&quot; - vytvoříte (dynamické)<sup class='margin-toggle sidenote-number'>1</sup> pole řádků, a každý řádek bude opět
dynamické pole sloupců. Kvůli tomuto vnoření polí je nutné jako datový typ použít ukazatel na ukazatel.
Následující kód vytvoří pole pěti studentů, a každému studentovi vytvoří pole s různým počtem ID předmětů,
které studuje:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Vnější pole řádků teoreticky nemusí být dynamické, ale pokud už potřebujete dynamické
počty sloupců, obvykle budete chtít i dynamický počet řádků. </p>
</span>
<pre><code class="language-c editable mainbody">#include &lt;stdlib.h&gt;

int main() {
    // Vytvoření pole studentů
    int** studenti = (int**) malloc(5 * sizeof(int*));

    for (int i = 0; i &lt; 5; i++) {
        // Vytvoření pole předmětů pro konkrétního studenta
        studenti[i] = (int*) malloc((i + 1) * sizeof(int));
    }

    // Druhý předmět třetího studenta bude mít ID 5
    studenti[2][1] = 5;

    for (int i = 0; i &lt; 5; i++) {
        // Uvolnění pole předmětů pro konkrétního studenta
        free(studenti[i]);
    }

    // Uvolnění pole studentů
    free(studenti);
    return 0;
}
</code></pre>
<p>Při přístupu k prvkům pole můžeme klasicky využít hranatých závorek. <code>studenti[2]</code> vrátí adresu
pole předmětů třetího studenta, a nad tímto polem (resp. ukazatelem) můžeme opět použít hranaté
závorky pro přístup k druhému předmětu. Zde se tak neprovádí žádný převod 2D na 1D indexy ani naopak,
protože jednotlivá pole v paměti nejsou uložena za sebou.</p>
<p>Všimněte si, že jednotlivé pole předmětů (&quot;řádky&quot; našeho vícerozměrného pole) musíme uvolňovat
zvlášť, a musíme je uvolnit dříve, než uvolníme samotné pole studentů (řádků), jinak bychom už k
adresám polí předmětů nesměli přistupovat.</p>
<blockquote>
<p>Pokud by zubaté pole mělo tři dimenze, typ &quot;vnějšího&quot; pole by byl <code>int***</code>, pokud čtyři dimenze,
tak <code>int****</code> atd.</p>
</blockquote>
<p>Vytváření a uvolňování zubatého pole je o dost náročnější než u klasického vícerozměrného pole. To
je totiž v paměti uloženo jako klasické 1D pole, které akorát indexujeme vícerozměrným indexem, kdežto
zubaté pole je opravdu pole polí (polí polí...). Někdy je ovšem nutné mít různou velikost jednotlivých
řádků, a tehdy zubatá pole přijdou vhod.</p>
<h1><a class="header" href="#text" id="text">Text</a></h1>
<p>Doposud jsme pracovali zejména s čísly, nyní se podíváme na to, jak můžeme v počítači reprezentovat
znaky a jak obecně pracovat s textem. Zpracování textu je obsaženo téměř v každém programu –
načítání konfiguračních souborů, zadávání příkazů z terminálu, práce s dokumenty či tabulkami,
komunikace po síti a mnoho dalších činností vyžaduje práci s textem.</p>
<p>Nejprve si ukážeme, jak v počítači reprezentovat jednotlivé <a href="c/text/znaky.html">znaky</a>, dále jak z nich
vytvořit delší <a href="c/text/retezce.html">sekvence textu</a> a poté jak text <a href="c/text/vstupavystup.html">načítat a vypisovat</a>.</p>
<h1><a class="header" href="#znaky" id="znaky">Znaky</a></h1>
<p>Už víme, že v paměti počítače je nakonec vše reprezentováno číslem, a ani textové znaky
nejsou výjimkou. Přirozeným způsobem, jak od sebe znaky odlišit, je přiřadit každému znaku jiné číslo,
například znak <code>A</code> můžeme reprezentovat číslem <code>0</code>, znak <code>B</code> číslem <code>1</code> atd. Kdyby si však každý
program(átor) definoval vlastní způsob, jak převádět znaky na čísla, tak by mezi sebou programy
nemohly rozumně komunikovat, protože by si nerozuměly.</p>
<p>Z toho důvodu vzniklo za poslední desítky let mnoho <strong>textových kódování</strong>
(<em>character encoding</em>), které definují, jaká čísla přiřadit jednotlivým znakům. Dnešním de-facto
standardem je kódování <a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a>, které obsahuje přes sto tisíc
různých znaků, od dávných hieroglyfů, přes českou či anglickou abecedu, až po všelijaké emoji.
Práce s kódováním Unicode však není v jazyce <em>C</em> přímočará, navíc pro naše potřeby vůbec není potřeba<sup class='margin-toggle sidenote-number'>1</sup>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Pokud byste se o kódování znaků a Unicode chtěli dozvědět více, přečtěte si tento
<a href="https://kunststube.net/encoding/">článek</a>. </p>
</span>
<p>V rámci předmětu UPR si tak vystačíme s kódováním <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a>
(American Standard Code for Information Interchange). Toto kódování sice obsahuje pouze 128 znaků
(číslice, malá a velká písmena anglické abecedy, interpunkce apod.), nicméně práce s ním je díky tomu
velmi jednoduchá. Je navíc podmnožinou Unicode, takže programy, které podporují Unicode kódování, si
s ASCII hravě poradí. Tabulku, která uvádí, jak ASCII mapuje jednotlivé znaky na čísla, naleznete např.
<a href="https://www.asciitable.com/">zde</a><sup class='margin-toggle sidenote-number'>2</sup>.</p>
<span class='sidenote'><p><sup class='number'>2</sup>V tabulce si můžete všimnout, že čísla nejsou znakům přiřazena
zcela náhodně, například znaky reprezentující číslice <code>0</code> až <code>9</code> mají přiřazena čísla ležící za sebou
(<code>48</code> - <code>57</code>), a stejně je tomu i u písmen anglické abecedy. Této vlastnosti můžeme využít pro
usnadnění některých textových <a href="c/text/../../ulohy/retezce.html#p%C5%99evod-textu-na-%C4%8D%C3%ADslo">operací</a>.</p>
</span>
<h2><a class="header" href="#ascii-znaky-v-c" id="ascii-znaky-v-c">ASCII znaky v <em>C</em></a></h2>
<p>Jelikož ASCII &quot;kóduje&quot; pouze 128 znaků, tak pro reprezentaci ASCII znaku by nám stačilo 7 bitů.
Nicméně pracovat se sedmibitovými hodnotami by bylo poněkud nepraktické, proto se běžně ASCII znak
ukládá do jednobytového (osmibitového) čísla. V <em>C</em> se pro reprezentaci jednoho ASCII znaku používá
datový typ <code>char</code><sup class='margin-toggle sidenote-number'>3</sup>, s kterým jsme se
<a href="c/text/../datove_typy/celociselne_typy.html">již setkali</a>.</p>
<span class='sidenote'><p><sup class='number'>3</sup><em>C</em> neobsahuje specializovaný typ pro jednobytové celé číslo, <code>char</code> tak reprezentuje jak
ASCII znak, tak i celé číslo s jedním bytem. Záleží pak na nás, jak budeme hodnotu v <code>char</code>u
interpretovat - jestli jako celé číslo nebo jako ASCII znak.</p>
</span>
<p>Pokud bychom chtěli do proměnné s typem <code>char</code> nějaký znak uložit, tak bychom mohli použít přímo
jeho číslo z ASCII <a href="https://www.asciitable.com/">tabulky</a>:</p>
<pre><code class="language-c">char znak = 65; // tento znak bude reprezentovat písmeno A
</code></pre>
<p>Nicméně takto by si každý programátor musel nazpaměť pamatovat ASCII tabulku, což je dost nepraktické.
<em>C</em> tak nabízí zkratku v podobě <strong>znakového literálu</strong> (<em>char literal</em>). Pokud napíšete jeden ASCII
znak do apostrofů (<code>'</code>), tento výraz se vyhodnotí jako ASCII číselná hodnota daného znaku s datovým
typem <code>char</code>. Obvykle tak znaky v programech zadáváme v apostrofech pro zjednodušení:</p>
<pre><code class="language-c">char znak = 'A'; // tento znak bude reprezentovat písmeno A
</code></pre>
<p>Pokud bychom si chtěli ověřit, že hodnota tohoto znaku je opravdu <code>65</code>, jak udává ASCII, můžeme
si ho vypsat na výstup programu jako číslo:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    char znak = 'A';
    printf(&quot;%d\n&quot;, (int) znak);
    return 0;
}
</code></pre>
<p>Do apostrofů nikdy nedávejte více než jeden znak! Překladač by se snažil takovýto zápis interpretovat
jako vícebytový znak, což téměř jistě není to, čeho chcete dosáhnout. Pro práci s textem (více znaky
najednou) slouží <a href="c/text/retezce.html">řetězce</a>. Jedinou výjimkou jsou speciální znaky, které se zapisují
pomocí zpětného lomítka, například:</p>
<ul>
<li><code>'\n'</code> reprezentuje znak <code>LF</code>, který udává, že má dojít k přechodu kurzoru na nový řádek.<sup class='margin-toggle sidenote-number'>4</sup><span class='sidenote'><p><sup class='number'>4</sup>Nepleťte si ho se znakem <code>'n'</code>, který reprezentuje klasické písmeno <code>n</code> z abecedy.</p>
</span></li>
<li><code>'\t'</code> reprezentuje znak <code>TAB</code>, který udává, že má dojít k výpisu delší mezery.</li>
<li><code>'\0'</code> reprezentuje znak <code>NUL</code> s číselnou hodnotou <code>0</code>.</li>
</ul>
<h3><a class="header" href="#Čísla-vs-znaky" id="Čísla-vs-znaky">Čísla vs znaky</a></h3>
<p>Při používání apostrofů je mimo jiné třeba si dávat pozor na to, jestli pracujeme s číselnou
hodnotou nebo se znakem, který reprezentuje nějakou číslici. Například zde:</p>
<pre><code class="language-c">char znak = 9;
</code></pre>
<p>Nedojde k uložení znaku <code>9</code> do proměnné. Bude do ní uložen znak <code>TAB</code>, který má v ASCII hodnotu <code>9</code>
a pomocí apostrofů ho lze zapsat jako <code>'\t'</code>. Pokud bychom do znaku chtěli zapsat znak reprezentující
číslici <code>9</code>, musíme použít buď literál <code>'9'</code> nebo číselnou hodnotu <code>57</code>, která devítku v ASCII
reprezentuje.</p>
<p>Pokud byste chtěli převést ASCII znak číslice na její číselnou hodnotu, stačí od něj odečíst hodnotu
<code>48</code>, neboli znak <code>'0'</code>. <code>'0' - '0'</code> je <code>0</code>, <code>'5' - '0'</code> je <code>5</code> atd. To je způsobeno tím, že číslice
mají v ASCII kódování přiřazeny sekvenční číselné hodnoty.</p>
<h1><a class="header" href="#Řetězce" id="Řetězce">Řetězce</a></h1>
<p>Nyní už víme, jak můžeme v <em>C</em> pracovat s jednotlivými (ASCII) znaky. Obvykle však chceme pracovat
s delšími sekvencemi textu - řádky, větami, odstavci atd. Sekvence textu se v programovacích jazycích
obvykle označují jako <strong>řetězce</strong> (<em>strings</em>).</p>
<p>Dobrá zpráva je, že pro použití řetězců v <em>C</em> už
známe vše potřebné – řetězce nejsou nic jiného než <a href="c/text/../pole/pole.html">pole</a> <a href="c/text/znaky.html">znaků</a>!</p>
<h2><a class="header" href="#Řetězce-v-c" id="Řetězce-v-c">Řetězce v <em>C</em></a></h2>
<p>Teoreticky bychom si mohli navrhnout vlastní způsob, jak řetězce v paměti reprezentovat a jak s nimi
pracovat. Nicméně zaběhlým způsobem, jak s ASCII textem v <em>C</em> pracovat, a pro který <em>C</em> nabízí různé
funkce a základní syntaktickou podporu, je použití takzvaných <strong>řetězců zakončených nulou</strong>
(<em>null-terminated strings</em>). Takto reprezentovaný řetězec není nic jiného než <a href="c/text/../pole/pole.html">pole</a>
<a href="c/text/znaky.html">znaků</a>, které obsahuje na svém posledním indexu znak <code>'\0'</code> (s číselnou hodnotou <code>0</code>),
který značí konec řetězce. Například řetězec <code>UPR</code> by tedy v paměti počítače byl reprezentovaný takto:
<upr-array array='["U", "P", "R", "\\0"]'></upr-array></p>
<h3><a class="header" href="#vytvoření-řetězce" id="vytvoření-řetězce">Vytvoření řetězce</a></h3>
<p>Pokud bychom chtěli vytvořit řetězec na zásobníku, můžeme vytvořit statické pole, umístit do něj
jednotlivé znaky řetězce a za ně přidat znak <code>'\0</code><sup class='margin-toggle sidenote-number'>1</sup>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Pro <a href="c/text/vystup.html">výpis</a> řetězce pomocí funkce <code>printf</code> můžeme použít zástupný znak <code>%s</code>.</p>
</span>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    char text[4] = {'U', 'P', 'R', '\0'};
    printf(&quot;%s\n&quot;, text);
    return 0;
}
</code></pre>
<p>Pokud bychom potřebovali řetězec s dynamickou nebo velkou délkou, můžeme pro vytvoření řetězce
samozřejmě použít také <a href="c/text/../pole/dynamicke_pole.html">dynamickou paměť</a>.</p>
<h3><a class="header" href="#Řetězcový-literál" id="Řetězcový-literál">Řetězcový literál</a></h3>
<p>Vytváření řetězců tímto způsobem je nicméně celkem zdlouhavé a nepřehledné. Často chceme v programu
jednoduše a rychle zapsat krátký textový řetězec tak, aby šel přehledně přečíst. K tomu můžeme využít
tzv. <strong>řetězcový literál</strong> (<em>string literal</em>), který lze vytvořit tak, že napíšeme text do dvojitých
uvozovek (<code>&quot;</code>). Pokud tedy v našem programu vytvoříme například literál <code>&quot;UPR&quot;</code>, tak se stane následující:</p>
<ol>
<li>Překladač při překladu uloží do výsledného spustitelného souboru pole reprezentující daný řetězec.
V tomto případě půjde o pole velikosti 4 s hodnotami <code>'U'</code>, <code>'P'</code>, <code>'R'</code> a <code>'\0'</code>. Při spuštění
programu se toto pole načte do <a href="c/text/../prace_s_pameti/globalni_pamet.html">globální paměti</a> v sekci
adresního prostoru, která je určena pouze pro čtení. Do takto vytvořeného řetězce tak nelze
zapisovat, lze jej pouze číst<sup class='margin-toggle sidenote-number'>2</sup>.<span class='sidenote'><p><sup class='number'>2</sup>Tyto řetězce jsou pouze pro čtení zejména z toho důvodu, aby je šlo sdílet. Pokud například
v programu použijete třikrát stejný řetězcový literál, překladač může v paměti pole pro tento
literál vytvořit pouze jednou, aby ušetřil paměť. Kvůli toho ale musí být řetězce pouze pro čtení,
pokud bychom totiž takto sdílený řetězec změnili, změnilo by to i hodnotu všech ostatních literálů,
které se vyhodnotí na jeho adresu, což by bylo dost neintuitivní.</p>
</span></li>
<li>Samotný výraz literálu se při běhu programu vyhodnotí jako adresa prvního znaku řetězce
uloženého v globální paměti.</li>
<li>Datový typ literálu bude
<a href="c/text/../prace_s_pameti/ukazatele.html#konstantn%C3%AD-ukazatele">ukazatel na konstantní znak</a>, tedy
<code>const char*</code>. Tento datový typ říká, že hodnotu znaku na dané adrese nelze měnit.</li>
</ol>
<p>Pomocí řetězcového literálu si tak můžeme značne usnadnit zápis řetězců v programech, jelikož
nemusíme přemýšlet nad délkou pole, nemusíme pamatovat na umístění znaku <code>'\0'</code> na konec řetězce
a ani nemusíme obalovat jednotlivé znaky do apostrofů:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    const char* text = &quot;UPR&quot;;
    printf(&quot;%s\n&quot;, text);
    return 0;
}
</code></pre>
<p>Je však třeba pamatovat na to, že takto vytvořené řetězce jsou opravdu pouze pro čtení, a nesmíme
tak do nich zapisovat. Pokud je budete ukládat do proměnné, tak použijte datový typ <code>const char*</code>,
díky kterému vás překladač bude hlídat, abyste se do takovéhoto řetězce omylem nesnažili něco zapsat.</p>
<p>Pokud byste chtěli použít řetězcový literál pro vytvoření řetězce, který lze měnit, můžete ho uložit
do proměnné typu <code>char[]</code> (tj. pole znaků):</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    char text[] = &quot;UPR&quot;;
    text[0] = 'A';
    printf(&quot;%s\n&quot;, text);
    return 0;
}
</code></pre>
<p>V takovémto případě se hodnota z literálu překopíruje do proměnné pole znaků na zásobníku.</p>
<blockquote>
<p>Pokud jsou vám řetězcové literály povědomé, je to kvůli toho, že jsme je již mnohokrát
využili při volání funkce <code>printf</code>.</p>
</blockquote>
<h4><a class="header" href="#víceřádkové-řetězcové-literály" id="víceřádkové-řetězcové-literály">Víceřádkové řetězcové literály</a></h4>
<p>Pokud budete chtít zapsat řetězcový literál na více řádků kódu, můžete buď na konci každého
neukončeného řádku použít znak <code>\</code>:</p>
<pre><code class="language-c">const char* veta = &quot;Ahoj \
jmenuji \
se \
Karel&quot;;
</code></pre>
<p>nebo každý řádek samostatně obalit uvozovkami:</p>
<pre><code class="language-c">const char* veta = &quot;Ahoj&quot;
&quot;jmenuji&quot;
&quot;se&quot;
&quot;Karel&quot;;
</code></pre>
<p>Pozor však na to, že v ani jednom ze zmíněných případů nebude součástí řetězce znak odřádkování.
Ten musíte vždy přidat explicitně:</p>
<pre><code class="language-c">const char* radky = &quot;radek1\n\
radek2\n\
radek3\n&quot;;

// nebo
const char* radky = &quot;radek1\n&quot;
&quot;radek2\n&quot;
&quot;radek3\n&quot;;
</code></pre>
<h3><a class="header" href="#k-čemu-slouží-nulový-znak-na-konci" id="k-čemu-slouží-nulový-znak-na-konci">K čemu slouží nulový znak na konci?</a></h3>
<p>U polí je trochu nepraktické to, že pokud je chceme poslat do nějaké funkce, musíme spolu s
ukazatelem na první prvek pole předat také jeho
<a href="c/text/../pole/staticke_pole.html#p%C5%99ed%C3%A1v%C3%A1n%C3%AD-velikosti-pole">velikost</a>, aby funkce věděla, ke kolika prvkům
si může dovolit přistoupit. Jiným způsobem, jak určit velikost pole, je zvolit si speciální hodnotu,
která bude značit konec pole. Když kód, který s takovýmto polem bude pracovat, na tuto speciální
hodnotu narazí, tak bude vědět, že dále v paměti již pole nepokračuje.</p>
<p>Tento mechanismus je využit právě u řetězců zakončených nulou, kde onou speciální hodnotou je právě
tzv. <code>NUL</code> znak, který má číselnou hodnotu <code>0</code>. Například při procházení řetězce v cyklu tak nemusíme
dopředu znát jeho délku, stačí cyklus ukončit, jakmile narazíme na znak <code>'\0'</code>. Například funkce
pro spočtení délky řetězce by mohla vypadat takto<sup class='margin-toggle sidenote-number'>3</sup>:</p>
<span class='sidenote'><p><sup class='number'>3</sup>Všimněte si, že tato funkce bere ukazatel na konstantní pole znaků.
Pokud ve funkci nepotřebujete měnit hodnoty pole, je obvykle dobrý nápad použít klíčové slovo
<code>const</code> před datovým typem obsaženým v poli, aby vás překladač ohlídal, že se pole nesnažíte měnit.
Do takovéto funkce pak klidně můžete poslat i pole, které ve skutečnosti měnit lze, jinak řečeno
např. <code>char*</code> lze bez problému převést na <code>const char*</code>. V opačném směru konverze není korektní.</p>
</span>
<pre><code class="language-c">int delka_retezce(const char* retezec) {
    int delka = 0;

    // dokud není znak na adrese v ukazateli roven znaku NUL
    while (*retezec != '\0') {
        delka = delka + 1;
        retezec = retezec + 1;  // posuň ukazatel o jeden znak dále
    }
    return delka;
}
</code></pre>
<p>Tato funkce postupně projde všechny znaky řetězce a počítá, kolik jich je, dokud nenarazí na
znak <code>'\0</code>. Pro procházení řetězce je zde použita
<a href="c/text/../prace_s_pameti/ukazatele.html#aritmetika-s-ukazateli">aritmetika s ukazateli</a>.</p>
<p>Z toho vyplývá mimo jiné to, že znak <code>NUL</code> nemůže být použit &quot;uprostřed&quot; řetězce. Pokud by tomu tak
bylo, tak funkce, které by s takovýmto řetězcem pracovaly, by při nalezení tohoto znaku přestaly
řetězec zpracovávat, a jakékoliv další znaky za <code>NUL</code> by byly ignorovány. Uhodnete tak, co vypíše
následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    char text[] = {'U', '\0', 'P', 'R', '\0'};
    printf(&quot;%s\n&quot;, text);
    return 0;
}
</code></pre>
<h3><a class="header" href="#Řetězce-jako-pole" id="Řetězce-jako-pole">Řetězce jako pole</a></h3>
<p>S řetězci pracujeme jako s klasickými poli znaků. Například pro získání prvního znaku řetězce můžeme
použít operátor hranatých závorek:</p>
<pre><code class="language-c">char vrat_prvni_znak(const char* retezec) {
    return retezec[0];
}
</code></pre>
<h2><a class="header" href="#funkce-pro-práci-s-řetězci" id="funkce-pro-práci-s-řetězci">Funkce pro práci s řetězci</a></h2>
<p>Standardní knihovna <em>C</em> obsahuje <a href="https://devdocs.io/c/string/byte">řadu funkcí</a>, které umí s
řetězci zakončenými nulou pracovat. Zde je seznam několika vybraných funkcí, které pro vás můžou
být užitečné:</p>
<ul>
<li>
<p><strong>Zjištění délky řetězce</strong>: funkce <a href="https://devdocs.io/c/string/byte/strlen"><code>strlen</code></a> bere jako
parametr řetězec a vrací jeho délku. Jedná se o jednu z nejčastěji používaných funkcí při práci s
řetězci a vyplatí se jí tak znát.</p>
<p>Při jejím použití je ovšem nutné si dát pozor na to, že délka provádění této funkce závisí na tom, jak je
řetězec dlouhý. Pokud bude mít řetězec milion znaků, tak bude tato funkce muset projít všech milion
znaků, dokud nenarazí na znak <code>NUL</code>. Dávejte si tak pozor, abyste tuto funkci nevolali zbytečně často.
Například pokud použijete funkci <code>strlen</code> v podmínce cyklu <code>for</code>:</p>
<pre><code class="language-c">for (int i = 0; i &lt; strlen(retezec); i++) {
    ...
}
</code></pre>
<p>Tak se délka řetězce vypočte při každé iteraci cyklu. Pokud by tak řetězec měl milion znaků,
musel by program provést bilion<sup class='margin-toggle sidenote-number'>4</sup> (!) operací pouze pro zjištění délky řetězce.
Lepší volbou (pokud se tedy délka řetězce nemění) je tak předpočítat si jeho délku dopředu a
uložit si ji do proměnné:</p>
<span class='sidenote'><p><sup class='number'>4</sup>1 000 000 000 000</p>
</span>
<pre><code class="language-c">int delka = strlen(retezec);
for (int i = 0; i &lt; delka; i++) {
    ...
}
</code></pre>
</li>
</ul>
<ul>
<li><strong>Porovnání dvou řetězců</strong>: běžnou operací, kterou bychom s řetězci chtěli udělat, je porovnat,
zdali jsou dva řetězce stejné, popřípadě který z nich je menší<sup class='margin-toggle sidenote-number'>5</sup>. Funkce
<a href="https://devdocs.io/c/string/byte/strcmp"><code>strcmp</code></a> bere dva řetězce a vrací nulu, pokud se řetězce
rovnají, zápornou hodnotu, pokud je první řetězec menší než ten druhý, a kladnou hodnotu, pokud je
druhý řetězec menší než první.<span class='sidenote'><p><sup class='number'>5</sup>Pro porovnávání řetězců se používá <a href="https://cs.wikipedia.org/wiki/Lexikografick%C3%A9_uspo%C5%99%C3%A1d%C3%A1n%C3%AD">lexikografické uspořádání</a>.
Nalezne se první dvojice znaků (zleva), ve kterém se řetězce liší, a tyto dva znaky se porovnají
pomocí jejich číselné (ASCII) hodnoty.</p>
</span></li>
</ul>
<ul>
<li>
<p><strong>Vyhledání řetězce v řetězci</strong>: pokud chcete zjistit, jestli se v nějakém řetězci vyskytuje jiný
řetězec, můžete použít funkci <a href="https://devdocs.io/c/string/byte/strstr"><code>strstr</code></a>.</p>
</li>
<li>
<p><strong>Převod textu na číslo</strong>: často můžete potřebovat převést textový zápis čísla na jeho číselnou
hodnotu. K tomu můžete použít například funkci <a href="https://devdocs.io/c/string/byte/strtol"><code>strtol</code></a>
(<em>string to long</em>). První parametr funkce je řetězec, který chcete převést, do druhého parametru
můžete předat ukazatel na ukazatel na znak, do kterého se uloží pozice ve vstupním řetězci těsně za
načteným číslem. Posledním parametrem je soustava, ve které se má číslo načíst (obvykle to bude
desítková soustava, tedy hodnota <code>10</code>). Návratovou hodnotou funkce je pak načtené číslo.</p>
<p>Můžete použít také funkci <a href="https://devdocs.io/c/string/byte/atoi"><code>atoi</code></a>, která je trochu
jednodušší na použití, ale při jejím použití nelze zjistit, zdali při konverzi nedošlo k chybě
(například pokud vstupní řetězec nereprezentoval číslo).</p>
</li>
</ul>
<hr />
<p><strong>Cvičení</strong>: Pro procvičení práce s řetězci si můžete zkusit některé z těchto funkcí sami
naprogramovat. Další úlohy pro práci s řetězci můžete nalézt <a href="c/text/../../ulohy/retezce.html">zde</a>.</p>
<hr />
<h1><a class="header" href="#vstup-a-výstup" id="vstup-a-výstup">Vstup a výstup</a></h1>
<p>Už víme, jak v paměti počítače pracovat s (ASCII) znaky a řetězci. Nyní si ukážeme, jak můžou naše
programy komunikovat s okolním světem – se <a href="c/text/../soubory/soubory.html">soubory</a> na disku, s terminálem, s
ostatními programy běžícími na vašem počítači či s úplně jiným počítačem přes síť. Komunikace programů
se obecně označuje jako <strong>I/O</strong> (<em>input/output</em>).</p>
<p>Komunikace s terminálem, souborem, tiskárnou či přes síť má samozřejmě rozlišná pravidla. Abychom v
každém programu nemuseli programovat podporu pro každý vstupní/výstupní kanál od nuly, z velké části
se o toto stará operační systém. Ten nám umožňuje komunikovat s okolním světem pomocí tzv.
<strong>souborových deskriptorů</strong> (<em>file descriptors</em>). Při vytvoření nového komunikačního kanálu
(například při otevření souboru) našemu programu operační systém předá nový souborový deskriptor
identifikovaný číslem. Když poté náš program chce vypsat nebo načíst data, tak musí předat operačnímu
systému číslo deskriptoru, se kterým chceme komunikovat. Můžeme například říct <code>Vypiš text &quot;ahoj&quot; do souborového deskriptoru s číslem 5</code>. Ať už je na tento deskriptor připojen soubor, terminál či něco
jiného, operační systém se postará o to, aby k němu data z našeho programu korektně dorazila.</p>
<h2><a class="header" href="#standardní-souborové-deskriptory" id="standardní-souborové-deskriptory">Standardní souborové deskriptory</a></h2>
<p>Každému programu při spuštění přiřadí operační systém tři základní souborové deskriptory:</p>
<ul>
<li>
<p><strong>Standardní vstup</strong> (<code>stdin</code>): tento deskriptor má číslo <code>0</code> a používá se pro čtení vstupu.
Pokud váš program spustíte z terminálu, tak do <code>stdin</code>u bude přesměrován text, který napíšete v
terminálu. Nemusí tomu tak však být vždy. Váš program můžete například spustit z jiného programu, a
předat mu vstup přímo z paměti. Nebo můžete například na vstup vašeho programu přesměrovat soubor z
disku:</p>
<pre><code class="language-bash">$ ./program &lt; soubor.txt
</code></pre>
</li>
<li>
<p><strong>Standardní výstup</strong> (<code>stdout</code>): tento deskriptor má číslo <code>1</code> a používá se pro výpis dat. Pokud
váš program spustíte z terminálu, tak data odeslaná do <code>stdout</code>u se objeví na obrazovce terminálu.
Opět to ale není jediná možnost, <code>stdout</code> může být například přesměrovaný do souboru na disku:</p>
<pre><code class="language-bash">$ ./program &gt; soubor.txt
</code></pre>
<p>Funkce <code>printf</code> posílá svůj výstup právě do deskriptoru <code>stdout</code>.</p>
<p>Pokud toto nastavení <a href="https://devdocs.io/c/io/setvbuf">nezměníte</a>, tak <code>stdout</code> implicitně používá 
tzv. <strong>bufferování po řádcích</strong> (<em>line buffering</em>). To znamená, že pokud zapíšete do <code>stdout</code>
pomocí některé z funkcí standardní knihovny <em>C</em> nějaký text, tak tento text se nejprve zapíše
do dočasného pole (tzv. <em>bufferu</em>) v paměti. Až jakmile na výstup zapíšete znak odřádkování <code>'\n'</code><sup class='margin-toggle sidenote-number'>1</sup>,
tak dojde k vyprázdnění (<em>flush</em>) bufferu, kdy je jeho obsah odeslán na výstup. Jinak řečeno,
dokud nevypíšete znak odřádkování, váš výstup se neobjeví např. v terminálu. Bufferování po
řádcích se provádí jako optimalizace, výstup (i vstup) totiž dost často brzdí vykonávání programů.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Nebo jakmile v bufferu dojde paměť.</p>
</span></li>
<li>
<p><strong>Standardní chybový výstup</strong> (<code>stderr</code>): tento deskriptor má číslo <code>2</code> a používá se pro výpis
chyb a logovacích záznamů. Narozdíl od <code>stdout</code> nepoužívá <code>stderr</code> implicitně line buffering, takže
cokoliv, co do něj zapíšete, se okamžite odešle na výstup deskriptoru.</p>
</li>
</ul>
<p>Mimo těchto standardních deskriptorů můžete ve svých programech vytvářet i další deskriptory,
například pomocí otevírání <a href="c/text/../soubory/soubory.html">souborů</a>. Více o tom, jak fungují souborové deskriptory
a vstup a výstup programu se dozvíte v předmětu
<a href="http://poli.cs.vsb.cz/edu/osy/osnova.html">Operační systémy</a>.</p>
<h3><a class="header" href="#interpretace-vstupních-a-výstupních-dat" id="interpretace-vstupních-a-výstupních-dat">Interpretace vstupních a výstupních dat</a></h3>
<p>Je dobré si uvědomit, že stejně jako v <a href="c/text/../../uvod/pamet.html">operační paměti</a>, i při komunikaci vždy
pracujeme pouze s čísly (byty), jejichž význam je dán čistě tím, jak je jejich příjemce bude interpretovat.
Pokud náš program do souboru zapíše byty <code>85</code>, <code>80</code>, <code>82</code>, a my tento soubor otevřeme v textovém
editoru, který jej bude pokládat za ASCII soubor, zobrazí se nám text <code>UPR</code>. Pokud jej však otevřeme
v binárním editoru, budou to pro něj pouze tři celá čísla. Pro prohlížeč obrázků by tato čísla zase
mohla reprezentovat barevné složky RGB pixelu.</p>
<p>Aby tak komunikace dvou stran dávala smysl, musí se obě strany dohodnout na tom, jak budou
interpretovat přenášená data. Například u souborů se způsob interpretace obvykle udává tím, jakou
dáme souboru příponu (<code>.txt</code> je pokládán za textový soubor, <code>.jpg</code> za JPEG obrázek atd.).</p>
<h2><a class="header" href="#ošetření-chyb" id="ošetření-chyb">Ošetření chyb</a></h2>
<p>Zatím jsme předpokládali, že operace, které provádíme v programu, vždy uspějí. Například při zápisu
hodnoty do proměnné jsme předpokládali, že se hodnota v paměti na adrese dané proměnné opravdu objeví
a když ji pak zpátky načteme, tak se při přenosu nijak neznehodnotí.</p>
<p>Při načítání vstupu či vypisování dat ovšem může velmi často dojít k různým chybovým situacím.
Během zápisu souboru na USB &quot;flashku&quot; ji můžeme omylem vytáhnout, při posílání dat přes síť nám může
vypadnout připojení k internetu nebo při načítání čísla z terminálu nám může zákeřný uživatel zadat
něco, co číslo ani zdaleka nepřipomíná.</p>
<p>Pokud tedy chceme psát robustní programy, které zvládnou korektně reagovat i na nevalidní vstup a
na různé chybové situace, které mohou nastat, musíme do našich programů přidat tzv.
<strong>ošetření chyb</strong> (<em>error handling</em>). Jedná se o obslužný kód, který reaguje na možné problémové
situace a snaží se je vyřešit. Jak ošetřovat chyby při komunikaci si ukážeme v jednotlivých sekcích
o <a href="c/text/vstup.html">vstupu</a> a <a href="c/text/vystup.html">výstupu</a>.</p>
<h1><a class="header" href="#vstup" id="vstup">Vstup</a></h1>
<p>Abychom mohli našim programům dávat příkazy nebo parametrizovat jejich chování, téměř vždy v nich
potřebujeme přečíst nějaké informace ze vstupu programu. V této sekci si ukážeme několik užitečných
funkcí ze <a href="c/text/../funkce/stdlib.html">standardní knihovny <em>C</em></a>, které nám to umožňují. Pro použití těchto
funkcí musíte ve svém programu <a href="c/text/../preprocesor/vkladani_souboru.html">vložit</a> soubor <code>&lt;stdio.h&gt;</code>.</p>
<h2><a class="header" href="#načtení-jednoho-znaku" id="načtení-jednoho-znaku">Načtení jednoho znaku</a></h2>
<p>Pro načtení jednoho znaku ze standardního vstupu (<code>stdin</code>) můžeme použít funkci
<a href="https://devdocs.io/c/io/getchar"><code>getchar</code></a>. Ta nám vrátí jeden znak ze vstupu, popřípadě hodnotu
makra <code>EOF</code><sup class='margin-toggle sidenote-number'>1</sup>, pokud již je vstup uzavřený a nelze z něj nic dalšího načíst nebo pokud došlo při
načítání k nějaké chybě.</p>
<span class='sidenote'><p><sup class='number'>1</sup><em>End-of-file</em></p>
</span>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char x = getchar();
    printf(&quot;Zadaný znak: %c\n&quot;, x);

    return 0;
}
</code></pre>
<h2><a class="header" href="#načtení-řádku" id="načtení-řádku">Načtení řádku</a></h2>
<p>Načítat vstup po jednotlivých znacích je poměrně zdlouhavé. Velmi často chceme ze vstupu načíst
delší úsek textu najednou, například celý řádek. Toho můžeme dosáhnout například použitím funkce
<a href="https://devdocs.io/c/io/fgets"><code>fgets</code></a>. Ta jako parametry přijímá ukazatel na řetězec, do kterého
zapíše načítaný řádek a maximální počet znaků, který lze načíst<sup class='margin-toggle sidenote-number'>2</sup>. Třetí parametr je
<a href="c/text/../soubory/soubory.html">soubor</a>, ze kterého se má vstup načíst. O souborech se dozvíte více později,
pokud chcete načítat data ze standardního vstupu, tak použijte jako třetí parametr globální proměnnou
<code>stdin</code>, která je nadefinována v souboru <code>&lt;stdio.h&gt;</code>. Pro jednoduché zjištění délky řetězce, do
kterého zapisujete, můžete použít operátor <code>sizeof</code>:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Tato velikost je včetně znaku <code>'\0'</code>, který je vždy zapsán na konec vstupního řetězce. Pokud
tak máte řetězec (pole) o délce <code>10</code>, předejte do <code>fgets</code> hodnotu <code>10</code>. Funkce načte maximálně <code>9</code>
znaků a na konec řetězce umístí znak <code>'\0'</code>.</p>
</span>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char buf[80];
    // načti řádek textu ze vstupu do řetězce `buf`
    fgets(buf, sizeof(buf), stdin);

    return 0;
}
</code></pre>
<p>Pokud tato funkce vrátí návratovou hodnotu <code>NULL</code>, tak při načítání došlo k chybě. Tuto chybu byste
tak ideálně měli nějak ošetřit:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char buf[80];
    if (fgets(buf, sizeof(buf), stdin) == NULL) {
        printf(&quot;Nacteni dat nevyslo. Ukoncuji program\n&quot;);
        return 1;
    }

    return 0;
}
</code></pre>
<h2><a class="header" href="#načtení-formátovaného-textu" id="načtení-formátovaného-textu">Načtení formátovaného textu</a></h2>
<p>Pokud chceme načítat text, u kterého očekáváme, že bude mít nějaký specifický formát, popřípadě chceme
text rovnou nějak zpracovat, například jej převést na číslo, můžeme použít formátované načítání vstupu
pomocí funkce <a href="https://devdocs.io/c/io/fscanf"><code>scanf</code></a>. Této funkci předáme tzv.
<strong>formátovací řetězec</strong> (<em>format string</em>), který udává, jak má vypadat vstupní text. V tomto řetězci
můžeme používat různé zástupné znaky. Za každý zástupný znak ve formátovacím řetězci <code>scanf</code> očekává
jeden argument s adresou, do které se má uložit načtená hodnota popsaná zástupným znakem ze vstupu.
Například tento kód načte ze vstupu dvě celá čísla:</p>
<pre><code class="language-c">int x, y;
scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
</code></pre>
<p>Pomocí formátovacího řetězce můžeme také vyžadovat, co musí v textu být. Například <code>scanf(&quot;x%d&quot;, …)</code>
načte vstup pouze, pokud v něm nalezne znak <code>'x'</code> následovaný číslem.</p>
<p>Seznam všech těchto zástupných znaků naleznete v <a href="https://devdocs.io/c/io/fscanf">dokumentaci</a>.
Načítat můžeme například celá čísla (<code>%d</code>), desetinná čísla (<code>%f</code>) či znaky (<code>%c</code>).</p>
<blockquote>
<p>Funkce <code>scanf</code> načítá data ze standardního vstupu programu (<code>stdin</code>). Obsahuje ovšem několik dalších
variant, pomocí kterých může načítat formátovaná data z libovolného souboru (<code>fscanf</code>) nebo třeba i
z řetězce v paměti (<code>sscanf</code>).</p>
</blockquote>
<p>Funkce <code>scanf</code> je jistě užitečná, zejména u krátkých a jednoduchých programů, nicméně má také určité
problémy, které jsou popsány níže. Pokud to je tedy možné, pro načítání vstupu raději používejte
funkci <code>fgets</code>.</p>
<h3><a class="header" href="#načítání-řetězců-pomocí-scanf" id="načítání-řetězců-pomocí-scanf">Načítání řetězců pomocí <code>scanf</code></a></h3>
<p>Pomocí <code>scanf</code> můžeme načítat také celé řetězce pomocí zástupného znaku <code>%s</code>. Zde si ovšem musíme
dávat pozor, abychom u něj uvedli i maximální délku řetězce, do kterého chceme text načíst<sup class='margin-toggle sidenote-number'>3</sup>:</p>
<span class='sidenote'><p><sup class='number'>3</sup>Narozdíl od funkce <code>fgets</code> se zde musí uvést délka o jedna menší, než je délka cílového řetězce,
do kterého znaky zapisujeme.</p>
</span>
<pre><code class="language-c">char buf[21];
scanf(&quot;%20s&quot;, buf);
</code></pre>
<p>Pokud bychom použili zástupný znak <code>%s</code> bez uvedené velikosti cílového řetězce, snadno by se mohlo
stát, že nám uživatel zadá moc dat, které by funkce <code>scanf</code> začala vesele zapisovat i za paměť předaného
řetězce, což může vést buď k pádu programu (v tom lepším případě) nebo ke vzniku bezpečnostní
zranitelnosti, pomocí které by uživatel našeho programu mohl například získat přístup k počítači,
na kterém program běží (v tom horším případě):</p>
<pre><code class="language-c">char buf[21];
// pokud uživatel zadá více než 20 znaků, může svým vstupem začít přepisovat paměť
// běžícího programu
scanf(&quot;%s&quot;, buf);
</code></pre>
<h3><a class="header" href="#zpracování-bílých-znaků" id="zpracování-bílých-znaků">Zpracování bílých znaků</a></h3>
<p>Funkce <code>scanf</code> ignoruje bílé znaky (mezery, odřádkování, tabulátory atd.) mezi jednotlivými
zástupnými znaky ve formátovacím řetězci. Například v následujícím kódu je validním vstupem <code>x8</code>,
<code>x 8</code> i <code>x  8</code>:</p>
<pre><code class="language-c">int a;
scanf(&quot;x%d&quot;, &amp;a);
</code></pre>
<p>I když může toto chování být užitečné, někdy je také celkem neintuitivní. Problém může způsobovat
zejména, pokud se pro načítání vstupu kombinuje formátované načítání (<code>scanf</code>) s neformátovaným
načítáním (např. <code>fgets</code>). Funkce <code>scanf</code> totiž bílé znaky nechá ve vstupu ležet, pokud je
nepotřebuje zpracovat.</p>
<p>Následující program načítá číslo pomocí funkce <code>scanf</code> a poté se snaží načíst následující
řádek textu pomocí funkce <code>fgets</code>:</p>
<pre><code class="language-c">int cislo;
scanf(&quot;%d&quot;, &amp;cislo);

char radek[80];
fgets(radek, sizeof(radek), stdin);
</code></pre>
<p>Pokud tomuto programu předáme text <code>5\nahoj</code>, očekávali bychom, že se v řetězci <code>radek</code> objeví
<code>ahoj</code>. Nicméně funkce <code>scanf</code> načte číslo <code>5</code> a nechá ve vstupu ležet znak odřádkování, protože
nic dalšího načíst nepotřebuje. Funkce <code>fgets</code> poté uvidí znak odřádkování, načte jej a skončí
své provádění (načte prázdný řádek), což zřejmě není chování, které bychom od programu čekali.</p>
<h3><a class="header" href="#ošetření-chyb-1" id="ošetření-chyb-1">Ošetření chyb</a></h3>
<p>Funkce <code>scanf</code> je problematická i co se týče ošetření chyb. Její návratová hodnota sice udává, kolik
zástupných znaků ze vstupu se jí podařilo načíst, problémem však je, že pokud funkce načte třeba
pouze polovinu vstupu, tak ji už nemůžeme zavolat znovu se stejným formátovacím řetězcem, jinak by se
snažila načíst data, která již načetla. Například pokud bychom tomuto programu:</p>
<pre><code class="language-c">int x, y;
scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
</code></pre>
<p>předali text <code>5 asd</code>, tak funkce vrátí hodnotu <code>1</code>, tj. načetla ze vstupu jedno číslo. Nyní ovšem už
funkci nemůžeme zavolat znovu (jakmile bychom např. ve vstupu přeskočili nevalidní text), protože
v této chvíli už bychom chtěli načíst pouze jedno číslo. </p>
<h2><a class="header" href="#parametry-příkazového-řádku" id="parametry-příkazového-řádku">Parametry příkazového řádku</a></h2>
<p>Další možností, jak předat nějaký vstup vašemu programu, je předat mu parametry při spuštění v
terminálu:</p>
<pre><code class="language-bash">$ ./program arg1 arg2 arg3
</code></pre>
<p>K těmto předaným řetězcům poté lze přistoupit ve funkci
<a href="c/text/../../ruzne/funkce_main.html#vstupn%C3%AD-parametry-funkce-main"><code>main</code></a>.</p>
<h1><a class="header" href="#výstup" id="výstup">Výstup</a></h1>
<p>Stejně jako pro načítání vstupu, i pro výpis textu na výstup nabízí standardní knihovna <em>C</em> sadu
užitečných funkcí, opět umístěných v souboru <code>&lt;stdio.h&gt;</code>. Stejně jako u načítání <a href="c/text/vstup.html">vstupu</a>
bychom i u výstupu měli řešit <a href="c/text/vstupavystup.html#o%C5%A1et%C5%99en%C3%AD-chyb">ošetření chyb</a>. Nicméně, u zápisu to
(alespoň u malých programů) není až tak nezbytné, protože chyby zápisu jsou vzácnější než chyby při
vstupu. Zdrojem dat je totiž náš program, a nemusíme tak kontrolovat, jestli jsou data validní.
Tato povinnost v jistém smyslu přechází na druhou stranu, s kterou náš program komunikuje.</p>
<h2><a class="header" href="#vypsání-znaku" id="vypsání-znaku">Vypsání znaku</a></h2>
<p>Pro vypsání jednoho znaku na standardní výstup (<code>stdout</code>) můžeme použít funkci
<a href="https://devdocs.io/c/io/putchar"><code>putchar</code></a>.</p>
<h2><a class="header" href="#vypsání-řetězce" id="vypsání-řetězce">Vypsání řetězce</a></h2>
<p>Pro vypsání celého řetězce na <code>stdout</code> můžete použít funkci <a href="https://devdocs.io/c/io/puts"><code>puts</code></a>,
která zároveň za řetězcem vypíše znak odřádkování <code>\n</code>:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    puts(&quot;Ahoj&quot;);
    puts(&quot;UPR&quot;);
    return 0;
}
</code></pre>
<p>Dávejte si pozor na to, že v předaném řetězci musí být obsažen ukončovací <code>NUL</code> znak! Funkce <code>puts</code>
se bude snažit číst a vypisovat znaky ze zadané adresy, až dokud na takovýto znak nenarazí. Pokud
by tento znak v předaném řetězci nebyl, tak se bude funkce pokoušet číst nevalidní paměť za koncem
řetězce, dokud na <code>NUL</code> nenarazí, což by vedlo k
<a href="c/text/../../caste_chyby/pametove_chyby.html">paměťové chybě</a> 💣.</p>
<h2><a class="header" href="#vypsání-formátovaného-textu" id="vypsání-formátovaného-textu">Vypsání formátovaného textu</a></h2>
<p>K výpisu formátovaného textu na <code>stdout</code> můžeme použít funkci <code>printf</code>, s kterou jsme se již
mnohokrát setkali. Prvním parametrem funkce je formátovací řetězec, do kterého můžete dávat
zástupné znaky. Pro každý zástupný znak funkce očekává jednu hodnotu (argument) za formátovacím
řetězcem, která bude zformátována na výstup. Například takto můžeme vytisknout číslo a po něm řetězec:</p>
<pre><code class="language-c">const char* text = &quot;Cislo&quot;;
int cislo = 5;
printf(&quot;Cislo %d, retezec %s: \n&quot;, cislo, text);
</code></pre>
<p>Zástupné znaky funkcí <code>printf</code> i <code>scanf</code> jsou obdobné, jejich seznam a různé možnosti nastavení
můžete najít v <a href="https://devdocs.io/c/io/fprintf">dokumentaci</a>.</p>
<blockquote>
<p>Stejně jako <code>scanf</code> má i funkce <code>printf</code> různé varianty pro formátovaný výpis do souborů
(<code>fprintf</code>) či do řetězce v paměti (<code>sprintf</code>).</p>
</blockquote>
<h1><a class="header" href="#vlastní-datové-typy" id="vlastní-datové-typy">Vlastní datové typy</a></h1>
<p>Nyní už umíme pracovat se základními datovými typy v <em>C</em>
(<a href="c/struktury/../datove_typy/celociselne_typy.html">celá čísla</a>, <a href="c/struktury/../datove_typy/desetinne_typy.html">desetinná čísla</a>,
<a href="c/struktury/../datove_typy/pravdivostni_typy.html">pravdivostní hodnoty</a>, <a href="c/struktury/../text/znaky.html">znaky</a>) a také
umíme pracovat s jejich <a href="c/struktury/../prace_s_pameti/ukazatele.html">adresami</a> a vytvářet jich
<a href="c/struktury/../pole/pole.html">více najednou</a>. Doposud jsme však vždy pracovali s každým datovým typem zvlášť.</p>
<p>Představte si, že byste chtěli naprogramovat hru, ve které budete mít nějaké počítačem ovládané
příšery<sup class='margin-toggle sidenote-number'>1</sup>. Každá příšera může mít spoustu vlastností – jméno, počet životů, zranění, které uděluje,
umístění na mapě, kořist atd. Zároveň bude takových příšer v naší hře určitě více. Mohli bychom tak
příšery reprezentovat pomocí pole pro každou jeho vlastnost:</p>
<span class='sidenote'><p><sup class='number'>1</sup><em>Non-player character</em> (NPC)</p>
</span>
<pre><code class="language-c">const char* prisera_jmeno[100];
int prisera_zivot[100];
int prisera_zraneni[100];
float prisera_poloha_x[100];
float prisera_poloha_y[100];
...
</code></pre>
<p>I když by jistě šlo programy tvořit tímto způsobem, asi sami uznáte, že to není ideální, protože to
má spoustu nevýhod:</p>
<ul>
<li>Pokud bychom například změnili (maximální) počet příšer, museli bychom synchronizovat tuto velikost
mezi všemi poli, které reprezentují jednotlivé vlastnosti příšer.</li>
<li>K názvům proměnných musíme přidávat nějakou předponu (např. <code>prisera</code>), abychom dali najevo, že
tyto proměnné vlastně patří k jednomu logickému prvku (příšeře).</li>
<li>Pokud bychom chtěli jednu takovou příšeru poslat do funkce, tak by to vyžadovalo spoustu parametrů:
<pre><code class="language-c">int vypocti_pocet_zkusenosti(
    const char* prisera_jmeno,
    int prisera_zivot,
    int prisera_zraneni,
    float prisera_poloha_x,
    float prisera_poloha_y,
    ...
) { }
</code></pre>
Celou příšeru bychom ani nemohli z funkce přímočaře vrátit, protože funkce mohou vracet pouze
jednu hodnotu.</li>
<li>Pokud bychom chtěli příšeře přidat novou vlastnost, museli bychom přidat novou proměnnou nebo pole
na všechna místa, kde s příšerami pracujeme. Například by se musely změnit parametry každé funkce,
která by přijímala příšeru.</li>
</ul>
<p>Co bychom ve skutečnosti chtěli překladači říct, je něco ve smyslu <code>Příšera je něco, co má jméno, počet životů, zranění, pozici a kořist</code>, a poté bychom chtěli ve funkci například říct <code>Vytvoř pole 100 příšer</code>:</p>
<pre><code class="language-c">Prisera prisery[100];
</code></pre>
<p>Takto bychom zlepšili úroveň abstrakce našeho kódu – v tomto konkrétním případě bychom se mohli začít
v kódu bavit o <code>příšeře</code> místo pouze o sadě atributů <code>jméno, počet životů, zranění, …</code>.</p>
<p>Jinak řečeno, chtěli bychom si vytvořit náš vlastní datový typ. A právě to můžeme v <em>C</em> udělat pomocí
<a href="c/struktury/struktury.html">struktur</a>.</p>
<blockquote>
<p>Struktury jsou posledním syntaktickým prvkem <em>C</em>, o kterém se budeme v předmětu UPR bavit. Jazyk
<em>C</em> sice obsahuje i několik dalších <a href="c/struktury/../co_dal.html">syntaktických prvků</a>, které jsme si neukázali,
ty však nejsou nutné pro tvorbu jednoduchých programů. Dále se už pouze budeme bavit o konkrétních
aplikacích toho, co jsme se naučili, pro tvorbu různých typů programů.</p>
</blockquote>
<h1><a class="header" href="#struktury" id="struktury">Struktury</a></h1>
<p><strong>Struktury</strong> (<em>structures</em>) nám umožňují popsat nový datový typ, který se bude skládat z
jednoho či více tzv. <strong>členů</strong> (<em>members</em>)<sup class='margin-toggle sidenote-number'>1</sup>. Každému členu musíme určit jeho jméno a datový typ.
Novou strukturu můžeme popsat pomocí tzv. <em>deklarace struktury</em>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Můžete se setkat také s názvy <strong>atribut</strong> (<em>attribute</em>), <strong>vlastnost</strong> (<em>property</em>) nebo
<em>field</em>. V kontextu struktur <em>C</em> označují všechny tyto názvy jedno a to samé - člena struktury.</p>
</span>
<pre><code class="language-c">struct &lt;název struktury&gt; {
    &lt;datový typ prvního členu&gt; &lt;název prvního členu&gt;;
    &lt;datový typ druhého členu&gt; &lt;název druhého členu&gt;;
    &lt;datový typ třetího členu&gt; &lt;název třetího členu&gt;;
    ...
};
</code></pre>
<blockquote>
<p>Při deklaraci struktury nezapomínejte na finální středník za složenými závorkami, je povinný.</p>
</blockquote>
<p>Například, pokud bychom chtěli vytvořit datový typ reprezentující <code>příšeru</code>, která má své jméno
a počet životů, můžeme deklarovat následující strukturu:</p>
<pre><code class="language-c">struct Prisera {
    const char* jmeno;
    int pocet_zivotu;
};
</code></pre>
<p>Tento kód sám o sobě <strong>nic neprovádí</strong>! Pouze pomocí něj říkáme překladači, že vytváříme nový datový
typ s názvem <code>struct Prisera</code>. Poté nám překladač umožní dále v programu vytvořit například lokální
proměnnou tohoto datového typu:</p>
<pre><code class="language-c">// lokální proměnná s názvem `karel` a datovým typem `struct Prisera`
struct Prisera karel;
</code></pre>
<p>Pro pojmenovávání struktur používejte v rámci předmětu UPR jmennou konvenci
<a href="c/struktury/../promenne/pojmenovavani.html#v%C3%ADceslovn%C3%A9-n%C3%A1zvy"><code>PascalCase</code></a>.</p>
<blockquote>
<p>Struktury jsou plnohodnotnými datovými typy. Můžete tak vytvářet ukazatele na struktury, pole
struktur, můžete použít struktury jako <a href="c/struktury/struktury.html#pou%C5%BEit%C3%AD-struktur-ve-struktur%C3%A1ch">členy jiné struktury</a>
atd.</p>
</blockquote>
<h2><a class="header" href="#reprezentace-struktury-v-paměti" id="reprezentace-struktury-v-paměti">Reprezentace struktury v paměti</a></h2>
<p>Pokud vytvoříme proměnnou datového typu struktury, tak překladač naalokuje paměť pro všechny
členy této struktury. V případě výše by proměnná <code>karel</code> obsahovala nejprve byty pro ukazatel
<code>const char*</code> a poté byty pro <code>int</code>. Členové struktury budou v paměti uloženi ve stejném pořadí,
v jakém byly popsány při deklaraci struktury. Neznamená to ovšem, že musí ležet hned za sebou!
Překladač se může rozhodnout mezi členy struktury v paměti vložit mezery (tzv. <em>padding</em>) kvůli
urychlení provádění programu<sup class='margin-toggle sidenote-number'>2</sup>.</p>
<span class='sidenote'><p><sup class='number'>2</sup>Pro některé typy procesorů může být rychlejší přistupovat k adresám v paměti, které jsou
například násobkem <code>4</code> nebo <code>8</code>. Proto překladač mezery do struktur vkládá, aby jednotlivé členy
zarovnal (<em>align</em>) v paměti. Více se můžete dozvědět například
<a href="https://en.wikipedia.org/wiki/Data_structure_alignment">zde</a>.</p>
</span>
<p>Z toho vyplývá, že velikost struktury není vždy zcela intuitivní. Například následující struktura
s názvem <code>StiskKlavesy</code> obsahuje jeden znak (<code>char</code>) s velikostí 1 byte a jedno číslo (<code>int</code>) s
velikostí 4 byty. Kvůli &quot;neviditelným&quot; mezerám vloženým překladačem ovšem velikost struktury nemusí
být <code>5</code> bytů!</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

struct StiskKlavesy {
    char klavesa;
    int delka;
};

int main() {
    printf(&quot;Velikost znaku: %lu\n&quot;, sizeof(char));
    printf(&quot;Velikost cisla: %lu\n&quot;, sizeof(int));
    printf(&quot;Velikost struktury StiskKlavesy: %lu\n&quot;, sizeof(struct StiskKlavesy));

    return 0;
}
</code></pre>
<p>Proto pro zjištění velikosti struktury (například při dynamické alokaci paměti) vždy používejte
operátor <a href="c/struktury/../prace_s_pameti/dynamicka_pamet.html#velikost-alokovan%C3%A9-pam%C4%9Bti"><code>sizeof</code></a>.</p>
<h3><a class="header" href="#umístění-a-platnost-struktur" id="umístění-a-platnost-struktur">Umístění a platnost struktur</a></h3>
<p>Stejně jako u <a href="c/struktury/../promenne/promenne.html#platnost">proměnných</a> platí, že strukturu lze
používat pouze v oblasti, ve které je platná (v jejím tzv. <em>scopu</em>). Narozdíl od
<a href="c/struktury/../funkce/funkce.html#um%C3%ADst%C4%9Bn%C3%AD-funkc%C3%AD">funkcí</a> lze struktury deklarovat i uvnitř funkcí, nicméně
nejčastěji se struktury deklarují na nejvyšší úrovni souboru (tzv. <em>global scope</em>), stejně jako
funkce.</p>
<h2><a class="header" href="#inicializace-struktury" id="inicializace-struktury">Inicializace struktury</a></h2>
<p>Stejně jako u <a href="c/struktury/../promenne/promenne.html#v%C5%BEdy-inicializujte-prom%C4%9Bnn%C3%A9">základních datových typů</a> a
<a href="c/struktury/../pole/staticke_pole.html#inicializace-pole">polí</a> platí, že pokud lokální proměnné s datovým typem
nějaké struktury nedáte počáteční hodnotu, tak bude její hodnota nedefinovaná 💣. Strukturu můžete
nainicializovat pomocí složených závorek se seznamem hodnot pro jednotlivé členy struktury:</p>
<pre><code class="language-c">struct Prisera karel = { &quot;Karel&quot;, 100 };
</code></pre>
<p>Stejně jako u polí platí, že hodnoty, které nezadáte, se nainicializují na nulu:</p>
<pre><code class="language-c">struct Prisera karel = {}; // `jmeno` i `pocet_zivotu` bude `0`
struct Prisera karel = { &quot;Karel&quot; }; // `jmeno` bude &quot;Karel&quot;, `pocet_zivotu` bude `0`
</code></pre>
<p>Abyste si nemuseli pamatovat pořadí členů struktury při její inicializaci, můžete jednotlivé členy
nainicializovat explicitně pomocí tečky a názvu daného členu:</p>
<pre><code class="language-c">struct Prisera karel = { .pocet_zivotu = 100, .jmeno = &quot;Karel&quot; };
</code></pre>
<p>Jednotlivé hodnoty členům se přiřazují zleva doprava, takže pokud použijete název nějakého členu
více než jednou, &quot;zvítězí&quot; poslední zadaná hodnota. Tomuto se však vyhněte, a ani nekombinujte
inicializaci pomocí pořadí a pomocí názvů členů. Takovýto kód by totiž byl značně nepřehledný.</p>
<h2><a class="header" href="#přístup-ke-členům-struktur" id="přístup-ke-členům-struktur">Přístup ke členům struktur</a></h2>
<p>Abychom mohli číst a zapisovat jednotlivé členy struktur, můžeme použít operátor
<strong>přístupu ke členu</strong> (<em>member access operator</em>), který má syntaxi <code>&lt;výraz typu struktura&gt;.&lt;název členu&gt;</code>:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

struct Osoba {
    int vek;
    int pocet_pratel;
};

int main() {
    struct Osoba martina = { .vek = 18, .pocet_pratel = 10 };
    martina.vek += 1;
    martina.pocet_pratel += 20;
    printf(&quot;Martina ma %d let a ma %d pratel\n&quot;, martina.vek, martina.pocet_pratel);

    return 0;
}
</code></pre>
<p>Pokud máme k dispozici pouze ukazatel na strukturu, tak je přístup k jejím členům trochu nepraktický
kvůli <a href="https://en.cppreference.com/w/c/language/operator_precedence">prioritě operátorů</a>. Operátor
dereference (<code>*</code>) má totiž menší prioritu než operátor přístupu ke členu (<code>.</code>). Abychom tak nejprve
z ukazatele na strukturu načetli její hodnotu a až poté přistoupili k jejímu členu, museli bychom
použít závorky:</p>
<pre><code class="language-c">void pridej_pratele(struct Osoba* osoba) {
    (*osoba).pocet_pratel++;
}
</code></pre>
<p>Jelikož ukazatele na struktury jsou využívány velmi často, <em>C</em> nabízí pro tuto situaci zkratku v
podobě operátoru <strong>přístupu k členu přes ukazatel</strong> (<em>member access through pointer</em>), který má
syntaxi <code>&lt;ukazatel na strukturu&gt;-&gt;&lt;název členu&gt;</code>:</p>
<pre><code class="language-c">void pridej_pratele(struct Osoba* osoba) {
   osoba-&gt;pocet_pratel++;
}
</code></pre>
<p>Operátor <code>-&gt;</code> je čistě syntaktickou zkratkou, tj. platí <code>*(ukazatel).clen == ukazatel-&gt;clen</code>.</p>
<h2><a class="header" href="#vytváření-nových-jmen-pro-datové-typy" id="vytváření-nových-jmen-pro-datové-typy">Vytváření nových jmen pro datové typy</a></h2>
<p>Možná vás napadlo, že psát při každém použití struktury klíčové slovo <code>struct</code> před jejím názvem je
zdlouhavé. <em>C</em> umožňuje dávat datovým typům nové názvy, aby se nám s nimi lépe pracovalo. Lze toho
dosáhnout pomocí syntaxe <code>typedef &lt;datový typ&gt; &lt;jméno&gt;;</code>:</p>
<pre><code class="language-c">typedef int teplota;

int main() {
    teplota venkovni = 24;
    return 0;
}
</code></pre>
<p>Pomocí <code>typedef</code> vytvoříme nové jméno pro datový typ, pomocí kterého se pak na tento typ můžeme
odkazovat (původní název datového typu to však nijak neovlivní a můžeme ho stále používat). Opět
platí, že takto vytvořené jméno lze použít pouze v oblasti (<em>scopu</em>), kde byl <code>typedef</code> použit.
Obvykle se používá na nejvyšší úrovni souboru. </p>
<p>U struktur si pomocí <code>typedef</code> můžeme zkrátit jejich název ze <code>struct &lt;nazev&gt;</code> na <code>&lt;nazev&gt;</code>:</p>
<pre><code class="language-c">struct Osoba {
    int vek;
};

typedef struct Osoba Osoba;

int main() {
    Osoba jiri;
    return 0;
}
</code></pre>
<p>Toto lze ještě více zkrátit, pokud deklaraci struktury použijeme přímo na místě datového typu v
<code>typedef</code>:</p>
<pre><code class="language-c">typedef struct Osoba {
    int vek;
} Osoba;
</code></pre>
<p>A konečně, abychom nemuseli jméno struktury opakovat dvakrát, můžeme vytvořit tzv. <strong>anonymní
strukturu</strong> (<em>anonymous structure</em>) bez názvu, a jméno jí přiřadit až pomocí <code>typedef</code>.</p>
<pre><code class="language-c">typedef struct {
    int vek;
} Osoba;
</code></pre>
<p>Právě takto se obvykle deklarují struktury v <em>C</em>.</p>
<h2><a class="header" href="#použití-struktur-ve-strukturách" id="použití-struktur-ve-strukturách">Použití struktur ve strukturách</a></h2>
<p>Jelikož deklarace struktury vytvoří nový datový typ, nic vám nebrání v tom používat struktury jako
členy jiných struktur<sup class='margin-toggle sidenote-number'>3</sup>:</p>
<span class='sidenote'><p><sup class='number'>3</sup>Lze si můžete všimnout, že vnořené struktury lze inicializovat stejně jako proměnné struktur,
tj. pomocí složených závorek <code>{}</code>.</p>
</span>
<pre><code class="language-c">typedef struct {
    float x;
    float y;
} Poloha;

typedef struct {
    const char* jmeno;
    int cena;
} Vec;

typedef struct {
    int pocet_zivotu;
    Poloha poloha;
    Vec korist[10];
} Prisera;

int main() {
    Prisera prisera = { .pocet_zivotu = 100, .poloha = { .x = 0, .y = 0 } };

    return 0;
}
</code></pre>
<p>Díky tomu můžeme vytvářet celé hierarchie datových typů, což může značně zpřehlednit náš program,
protože můžeme pracovat s kódem na vyšší úrovni abstrakce.</p>
<h3><a class="header" href="#rekurzivní-struktury" id="rekurzivní-struktury">Rekurzivní struktury</a></h3>
<p>Pokud bychom chtěli použít jako člena struktury tu stejnou strukturu (například struktura
<code>Osoba</code> může mít člen <code>matka</code> opět s datovým typem <code>Osoba</code>), nemůžeme takovýto člen uložit ve
struktuře přímo, můžeme tam uložit pouze jeho adresu<sup class='margin-toggle sidenote-number'>4</sup>:</p>
<span class='sidenote'><p><sup class='number'>4</sup>Zde si můžete všimnout, že musíme použít <code>struct Osoba</code> pro datový typ členu <code>matka</code>. Je to z
toho důvodu, že v momentě, kdy tento člen definujeme, tak ještě není platný <code>typedef</code>, ve kterém se
struktura nachází, takže datový typ <code>Osoba</code> zatím neexistuje. Nové jméno pro datový typ lze používat
až za středníkem daného <code>typedef</code>u.</p>
</span>
<pre><code class="language-c">typedef struct Osoba {
    int vek;
    struct Osoba* matka;
} Osoba;
</code></pre>
<p>Je to proto, že pokud by <code>Osoba</code> byla definována pomocí <code>Osoby</code>, tak by došlo k rekurzivní definici,
kterou nelze vyřešit. Nešlo by totiž určit velikost <code>Osoby</code> - její velikost by závisela na velikosti
jejího členu <code>matka</code>, jehož velikost by závisela na velikosti jeho členu <code>matka</code> atd. Proto tedy musíme
v tomto případě použít ukazatel, který má fixní velikost, ať už ukazuje na jakýkoliv typ.</p>
<h1><a class="header" href="#struktury-a-funkce" id="struktury-a-funkce">Struktury a funkce</a></h1>
<p>Pomocí struktur si můžeme vytvořit nový datový typ, což pomáhá přehlednosti programů, protože se
díky tomu můžeme v programech vyjadřovat pomocí pojmů z oblasti (tzv. domény), kterou se náš program
zabývá (<code>Student</code>, <code>Příšera</code>, <code>Munice</code>, <code>Letadlo</code>, <code>Volant</code> atd.) a ne pouze pomocí pojmů, kterým
rozumí počítač (číslo, znak, pravdivostní hodnota).</p>
<p>Abychom pracovali s ještě vyšší úrovní abstrakce, bylo by užitečné, pokud bychom mohli k
vlastním datovým typům nadefinovat také vlastní operace, které by s nimi uměly pracovat. Některé
programovací jazyky umožňují provádět tzv.
<a href="https://en.wikipedia.org/wiki/Operator_overloading"><strong>přetěžování operátorů</strong></a> (<em>operator overloading</em>),
pomocí kterého můžeme například umožnit používání operátorů jako je <code>+</code> s vlastními datovými typy.
<em>C</em> toto sice neumožňuje, nicméně chování můžeme k námi vytvořeným strukturám přidat pomocí funkcí.</p>
<p>Často tak k naší struktuře chceme vytvořit sadu funkcí, které s ní budou pracovat. V <em>C</em> pro tento
koncept neexistuje žádná syntaktická podpora. Obvykle se tak prostě takovéto funkce pojmenují tak,
aby začínaly názvem struktury, ke které jsou přidružené, a přebírají ukazatel na tuto strukturu jako
svůj první parametr<sup class='margin-toggle sidenote-number'>1</sup>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Ukazatel se používá, abychom nemuseli struktury při předávání do funkcí kopírovat (mohou být
relativně velké) a abychom je mohli případně zevnitř funkcí modifikovat.</p>
</span>
<pre><code class="language-c editable">#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;

typedef struct {
    float x;
    float y;
} Poloha;

typedef struct {
    const char* jmeno;
    int skore;
    Poloha poloha;
} Hrac;

void hrac_posun(Hrac* hrac, int x, int y) {
    hrac-&gt;poloha.x += x;
    hrac-&gt;poloha.y += y;
}
void hrac_pridej_skore(Hrac* hrac, int skore) {
    hrac-&gt;skore += skore;
    if (hrac-&gt;skore &gt; 100) {
        hrac-&gt;skore = 100;
    }
}
bool hrac_vyhral(Hrac* hrac) {
    return hrac-&gt;skore == 100;
}

int main() {
    Hrac hrac = { .jmeno = &quot;Jindrich&quot;, .skore = 40, .poloha = { .x = 10, .y = 20 } };
    hrac_posun(&amp;hrac, 5, -8);
    hrac_pridej_skore(&amp;hrac, 70);

    printf(&quot;Hrac vyhral: %d\n&quot;, hrac_vyhral(&amp;hrac));

    return 0;
}
</code></pre>
<p>Pokud vytvoříme vhodné datové typy (struktury) a budeme s nimi pracovat pomocí funkcí, tak by se naše
programy měly přibližovat k tomu, aby je šlo číst jako plynulý a přehledný text. </p>
<blockquote>
<p>Vytváření vlastních datových typů, které mají přidružené chování, je základem tzv.
<a href="https://edison.sso.vsb.cz/cz.vsb.edison.edu.study.prepare.web/SubjectVersion.faces?version=460-2055/01&amp;subjectBlockAssignmentId=375759&amp;studyFormId=2&amp;studyPlanId=22001&amp;locale=cs&amp;back=true">Objektově orientovaného programování</a>.</p>
</blockquote>
<h2><a class="header" href="#struktury-jako-návratový-typ-funkce" id="struktury-jako-návratový-typ-funkce">Struktury jako návratový typ funkce</a></h2>
<p>Jelikož struktury mohou obsahovat více datových typů, můžete pomocí nich také obejít fakt, že
funkce mohou vracet pouze jednu hodnotu:</p>
<pre><code class="language-c">typedef struct {
    float x;
    float y;
} Poloha;

Poloha vrat_pocatecni_polohu() { ... }
</code></pre>
<hr />
<p><strong>Cvičení</strong>: Vyzkoušejte si práci se strukturami a funkcemi <a href="c/struktury/../../ulohy/struktury.html">zde</a>.</p>
<hr />
<h1><a class="header" href="#soubory" id="soubory">Soubory</a></h1>
<p>V sekci o <a href="c/soubory/../text/vstupavystup.html">vstupu a výstupu</a> jsme si ukázali, jak pracovat se souborovými
deskriptory <code>stdin</code> a <code>stdout</code> pro základní komunikaci s okolním světem (obvykle s terminálem).
Nyní si ukážeme, jak si vytvořit vlastní souborové deskriptory pomocí otevírání souborů na disku.
Použijeme k tomu funkce ze standardní knihovny <em>C</em>, které se opět nachází v souboru <code>&lt;stdio.h&gt;</code>.</p>
<p>Stejně jako u obecného vstupu a výstupu platí, že soubor na disku je pouze seznamem čísel (bytů).
Jejich význam je dán čistě tím, jak je budeme interpretovat. Stejný soubor může být například:</p>
<ul>
<li>Textovým editorem pokládán za textový dokument</li>
<li>Prohlížečem obrázků pokládán za obrázek</li>
<li>Hudebním přehrávačem pokládan za zvukovou nahrávku</li>
</ul>
<p>Obvykle souborům dáváme přípony (<code>.txt</code>, <code>.jpg</code>, <code>.mp3</code> atd.), abychom dali najevo, jak by se
daný soubor měl interpretovat. Samotná přípona však sama o sobě nic neznamená. Změnou přípony z
<code>.txt</code> na <code>.jpg</code> sice můžeme změnit způsob interpretace souboru, samotná data v něm však zůstanou
stále stejná – pokud v souboru předtím nebyla data ve formátu <a href="https://en.wikipedia.org/wiki/JPEG">JPEG</a>,
změna přípony tento stav nijak nezmění a soubor se nám tak nejspíše jako obrázek nepodaří otevřít.</p>
<p>Nejprve si ukážeme, jak můžeme <a href="c/soubory/otevirani_souboru.html">otevírat</a> soubory na disku, a poté jak do
otevřených souborů <a href="c/soubory/prace_se_soubory.html">zapisovat nebo z nich číst</a> data.</p>
<h1><a class="header" href="#otevírání-souborů" id="otevírání-souborů">Otevírání souborů</a></h1>
<p>Abychom mohli s nějakým souborem začít pracovat, musíme ho nejprve v našem programu otevřít, aby
byl vytvořen souborový deskriptor, do kterého pak můžeme zapisovat či z něho číst data. K tomu slouží
funkce <a href="https://devdocs.io/c/io/fopen"><code>fopen</code></a>, která má následující
<a href="c/soubory/../funkce/funkce.html#syntaxe">signaturu</a>:</p>
<pre><code class="language-c">FILE* fopen(const char* filename, const char* mode);
</code></pre>
<h2><a class="header" href="#cesta-k-souboru" id="cesta-k-souboru">Cesta k souboru</a></h2>
<p>Jako svůj první parametr funkce <code>fopen</code> očekává řetězec s cestou k souboru, který má být otevřen.
Cestu můžete zadat dvěma způsoby:</p>
<ul>
<li><strong>Absolutní cesta</strong> (<em>absolute path</em>) je cesta, která začíná kořenovým adresářem souborového
systému, například <code>/home/student/upr/soubor.txt</code><sup class='margin-toggle sidenote-number'>1</sup>. Aby byla cesta absolutní, musí na Linuxu
začínat dopředným lomítkem.<span class='sidenote'><p><sup class='number'>1</sup>Na Windows by podobná cesta mohla vypadat například jako
<code>C:\Users\student\upr\soubor.txt</code>.</p>
</span></li>
<li><strong>Relativní cesta</strong> (<em>relative path</em>) se vyhodnotí relativně k tzv. <strong>pracovnímu adresáři</strong>
(<em>working directory</em>) běžícího programu. Pokud spustíte váš program z terminálu, tak se pracovní
adresář implicitně nastaví na adresář, ze kterého jste program spustili. Pokud tedy například spustíte
váš program z adresáře <code>/home/student/upr</code> a funkci <code>fopen</code> předáte cestu <code>soubor.txt</code>, tak se funkce
pokusí otevřít soubor na cestě <code>/home/student/upr/soubor.txt</code>.</li>
</ul>
<p>Při zadávání cesty můžete využít zkratky <code>.</code> a <code>..</code>, které jsou užitečné zejména u relativních cest:</p>
<ul>
<li>Zkratka <code>.</code> se odkazuje na současný adresář, <code>./soubor.txt</code> je tedy to samé jako <code>soubor.txt</code>.</li>
<li>Zkratka <code>..</code> se odkazuje na rodičovský adresář, <code>../data/abc.txt</code> tedy říká:
<code>Podívej se do rodičovského adresáře, tam nalezni adresář data a v něm soubor abc.txt</code>.</li>
</ul>
<p>Nepokoušejte se však zadávat cesty k neexistujícím adresářům. <code>fopen</code> sice umí vytvořit nový soubor
(pokud použijete odpovídající <a href="c/soubory/otevirani_souboru.html#m%C3%B3d-otev%C5%99en%C3%AD">mód</a>), neexistující adresář za vás nicméně nevytvoří.</p>
<blockquote>
<p>Doposud jsme používali prvky <em>C</em>, které byly vesměs nezávislé na použitém operačním systému. Jakmile
ale naše programy začnou interagovat se <strong>souborovým systémem</strong> (<em>file system</em>), budeme muset začít
respektovat zákonitosti operačního systému, na kterém náš program poběží. Proto například u cesty
k souborům vždy používejte dopředná lomítka (<code>/</code>) pro oddělování adresářů, pokud program budete
spouštět na Linuxu. </p>
</blockquote>
<h2><a class="header" href="#mód-otevření" id="mód-otevření">Mód otevření</a></h2>
<p>Druhým parametrem funkce <code>fopen</code> je řetězec, jehož obsah určuje, v jakém <strong>módu</strong> (<em>mode</em>) se má
soubor otevřít. Kompletní seznam všech kombinací módů naleznete v
<a href="https://devdocs.io/c/io/fopen">dokumentaci</a>, zde je seznam běžných variant:</p>
<table><thead><tr><th align="center">Mód</th><th align="center">Možné operace</th><th align="center">Co se stane, když už soubor existuje?</th><th align="center">Co se stane, když soubor neexistuje?</th></tr></thead><tbody>
<tr><td align="center"><code>&quot;r&quot;</code></td><td align="center">Čtení</td><td align="center"></td><td align="center">chyba</td></tr>
<tr><td align="center"><code>&quot;w&quot;</code></td><td align="center">Zápis</td><td align="center">obsah souboru je smazán</td><td align="center">soubor je vytvořen</td></tr>
<tr><td align="center"><code>&quot;a&quot;</code></td><td align="center">Zápis na konci</td><td align="center"></td><td align="center">soubor je vytvořen</td></tr>
<tr><td align="center"><code>&quot;r+&quot;</code></td><td align="center">Čtení, zápis</td><td align="center"></td><td align="center">chyba</td></tr>
<tr><td align="center"><code>&quot;w+&quot;</code></td><td align="center">Čtení, zápis</td><td align="center">obsah souboru je smazán</td><td align="center">soubor je vytvořen</td></tr>
<tr><td align="center"><code>&quot;a+&quot;</code></td><td align="center">Čtení, zápis na konci</td><td align="center"></td><td align="center">soubor je vytvořen</td></tr>
</tbody></table>
<p>Při otevírání souboru si musíte rozmyslet, jestli z něj chcete číst, zapisovat do něj nebo provádět
obojí. Zároveň si musíte určit, jestli chcete soubor vytvořit v případě, že neexistuje, popřípadě
jestli má být jeho obsah smazán, pokud už existuje. Podle těchto vlastností si pak zvolte odpovídající
mód otevření souboru.</p>
<h3><a class="header" href="#textový-vs-binární-režim" id="textový-vs-binární-režim">Textový vs binární režim</a></h3>
<p>Pokud použijete jeden ze základních módů, soubor se otevře v tzv. <strong>textovém režimu</strong>. V tomto režimu
dochází ke konverzi určitých bytů při čtení a zápisu ze souboru. Asi nejdůležitějším znakem, který
je takto konvertován, je <code>'\n'</code>, neboli <strong>odřádkování</strong> (<em>newline</em>). Různé operační systémy totiž
při interpretaci souborů používají různé znaky pro odlišení situace, kdy má dojít k přesunu kurzoru
na nový řádek:</p>
<ul>
<li><code>LF</code>: Linux a macOS<sup class='margin-toggle sidenote-number'>2</sup> používají pro konec řádku přímo ASCII znak <code>LF (line feed)</code>, který lze v
<em>C</em> zapsat jako <code>'\n'</code>.<span class='sidenote'><p><sup class='number'>2</sup>V <a href="https://en.wikipedia.org/wiki/Classic_Mac_OS">dávných dobách</a> používal Mac OS pro odřádkování
pouze znak <code>CR</code>.</p>
</span></li>
<li><code>CRLF</code>: Windows používá pro konec řádku dvojici ASCII znaků <code>CR (carriage return)</code> a <code>LF</code>
(v tomto pořadí). <code>CR</code> lze v <em>C</em> zapsat jako <code>'\r'</code>.</li>
</ul>
<p>Na Windows tak při zápisu do souborů otevřených v textovém módu dojde ke konverzi znaku odřádkování
<code>\n</code> na dvojici znaků <code>\r\n</code>. Stejně tak při načítání dat ze souboru se dvojice znaků <code>\r\n</code> převedou
na <code>\n</code>. Na Linuxu textový mód v podstatě nic nedělá, protože se zde pro odřádkování používá přímo
znak <code>\n</code>.</p>
<p>Pokud byste však chtěli mít jistotu, že opravdu k žádné konverzi nedojde, a budete zapisovat data,
která nemají být interpretována jako text, můžete na konec módu přidat znak <code>b</code>. Poté se soubor
otevře v tzv. <strong>binární režimu</strong>, kde k žádné konverzi nedojde. Mód <code>&quot;rb&quot;</code> tak například říká
<code>Otevři soubor pro čtení v binárním režimu</code>.</p>
<blockquote>
<p>Pokud byste chtěli explicitně říct, že se má použít textový režim, můžete na konec módu přidat
znak <code>t</code>. Například mód <code>&quot;rt&quot;</code> je ekvivalentní s módem <code>&quot;r&quot;</code> a označuje otevření souboru pro
textové čtení.</p>
</blockquote>
<h3><a class="header" href="#ošetření-chyb-2" id="ošetření-chyb-2">Ošetření chyb</a></h3>
<p>Jakmile řeknete funkci <code>fopen</code> jaký soubor (a v jakém módu) má otevřít, funkce jej otevře a vrátí
vám ukazatel na strukturu <code>FILE</code>, pomocí které můžete se souborem dále pracovat<sup class='margin-toggle sidenote-number'>3</sup>. Stejně jako
u jakékoliv práce se vstupem a výstupem i při práci se soubory však může často docházet k různým
chybám.</p>
<span class='sidenote'><p><sup class='number'>3</sup><code>FILE</code> je tzv. <strong>neprůhledná</strong> (<em>opaque</em>) struktura deklarovaná ve standardní knihovně <em>C</em>.
Nebudete přistupovat k žádným jejím členům, pouze budete ukazatel na ni posílat do různých funkcí
pro práci se soubory, abyste určili, s jakým (otevřeným) souborem chcete pracovat.</p>
</span>
<p>Pokud byste se například pokoušeli otevřít neexistující soubor v módu pro čtení <code>&quot;r&quot;</code>, dojde k chybě.
V takovém případě vám funkce <code>fopen</code> vrátí adresu nula (tzv. <code>NULL</code> ukazatel). Po každém pokusu o
otevření souboru byste tak měli ověřit, zdali se otevření opravdu podařilo nebo ne. Pokud při otevření
došlo k chybě, tak se do <a href="c/soubory/../promenne/globalni_promenne.html">globální proměnné</a>
<a href="https://devdocs.io/c/error/errno"><code>errno</code></a> uloží číslo, které identifikuje, o jaký typ chyby šlo<sup class='margin-toggle sidenote-number'>4</sup>.
K proměnné budete mít přístup, pokud do svého programu <a href="c/soubory/../preprocesor/vkladani_souboru.html">vložíte</a>
soubor <code>&lt;errno.h&gt;</code>. Pomocí funkce <a href="https://devdocs.io/c/string/byte/strerror"><code>strerror</code></a> ze souboru
<code>&lt;string.h&gt;</code> pak můžete získat řetězec, který danou chybu popisuje:</p>
<span class='sidenote'><p><sup class='number'>4</sup>Seznam různých chybových hodnot, které se můžou v <code>errno</code> objevit, můžete naleznout například
<a href="https://www.thegeekstuff.com/2010/10/linux-error-codes/#optiontable">zde</a>.</p>
</span>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

int main() {
    FILE* soubor = fopen(&quot;soubor.txt&quot;, &quot;r&quot;);
    if (soubor == NULL) {
        printf(&quot;Doslo k chybe pri otevirani souboru: %s\n&quot;, strerror(errno));
        return 1; // došlo k chybě, vrátíme 1 jako chybový stav programu
    }

    return 0;
}
</code></pre>
<h3><a class="header" href="#použití-assert" id="použití-assert">Použití <code>assert</code></a></h3>
<p>Pokud píšete malý program a nechce se vám ručně každou chybu ošetřovat, můžete využít
<a href="c/soubory/../preprocesor/makra.html">makro</a> <a href="https://devdocs.io/c/error/assert"><code>assert</code></a> ze souboru <code>&lt;assert.h&gt;</code>.
Toto makro očekává pravdivostní hodnotu a kontroluje, zdali platí (<code>assert</code> znamená
<code>ujisti se, že platí …</code>). Pokud hodnota neplatí, tj. vyhodnotí se na <code>0</code> či <code>false</code>, tak dojde k
okamžitému ukončení vašeho programu. Nebudete tak sice moct ovlivnit vypsanou chybovou hlášku, ale
ošetření chyby se značně zjednodušší:</p>
<pre><code class="language-c">FILE* soubor = fopen(&quot;soubor.txt&quot;, &quot;r&quot;);
assert(soubor); // pokud je `soubor` roven `NULL`, program se zde ukončí
</code></pre>
<p>Ošetření chyb je dobré nepodceňovat. Pokud chybu ošetříte okamžitě po jejím možném vzniku (i kdyby
to mělo být okamžitým vypnutím programu), tak bude mnohem jednodušší zjistit, kde v kódu a proč vznikla.
Jinak se může jednoduše stát, že k chybě sice dojde, ale program bude pokračovat vesele dál. Tato
chyba pak může v průběhu programu způsobit kaskádu dalších chyb, které nakonec dříve či později povedou
k &quot;spadnutí&quot; nebo špatnému fungování programu. V takové situaci bude mnohem náročnější zjistit, kde
vznikla původní chyba, která vše způsobila, protože program může spadnout na úplně jiném místě v kódu. </p>
<h2><a class="header" href="#zavření-souboru" id="zavření-souboru">Zavření souboru</a></h2>
<p>Jakmile se souborem přestanete pracovat, je <strong>nutné</strong> ho zavřít. K tomu slouží funkce
<a href="https://devdocs.io/c/io/fclose"><code>fclose</code></a>:</p>
<pre><code class="language-c">FILE* soubor = fopen(&quot;soubor.txt&quot;, &quot;w&quot;);
// zápis/čtení ze souboru…
fclose(soubor);
</code></pre>
<p>Funkce <code>fclose</code> vrací číselnou hodnotu, která oznamuje, zdali funkce proběhla v pořádku nebo ne.
Pokud funkce vrátí <code>0</code>, tak se soubor úspěšně uzavřel. I u zavírání souborů bychom tedy měli mít
alespoň základní ošetření chyb<sup class='margin-toggle sidenote-number'>5</sup>:</p>
<span class='sidenote'><p><sup class='number'>5</sup>Operátor <code>!</code> provede logickou negaci. Pokud jej použijeme s hodnotou <code>0</code>, vrátí hodnotu <code>1</code>.
Pokud jej použijeme s jakoukoliv jinou hodnotou, vrátí hodnotu <code>0</code>. Pokud tedy funkce <code>fclose</code> vrátí
cokoliv jiného než <code>0</code>, <code>assert</code> ukončí program.</p>
</span>
<pre><code class="language-c">assert(!fclose(soubor));
</code></pre>
<p>Pokud bychom soubor nezavřeli, tak se například může stát, že kvůli použitému
<a href="c/soubory/../text/vstupavystup.html#standardn%C3%AD-souborov%C3%A9-deskriptory"><em>bufferování</em></a> by se data, která jsme do
souboru zapsali, nemusela objevit na souborovém systému.</p>
<h1><a class="header" href="#práce-se-soubory" id="práce-se-soubory">Práce se soubory</a></h1>
<p>Jakmile jsme se pokusili o otevření souboru, ujistili jsme se, že se to opravdu povedlo a získali
jsme ukazatel <code>FILE*</code>, můžeme začít do programu zapisovat nebo z něj číst data (podle toho, v jakém
módu jsme ho otevřeli).</p>
<h2><a class="header" href="#pozice-v-souboru" id="pozice-v-souboru">Pozice v souboru</a></h2>
<p>Struktura <code>FILE</code> má vnitřně uloženou <strong>pozici</strong> v souboru, na které probíhají veškeré operace čtení
a zápisu. Pro zjednodušení práce se soubory se pozice automaticky posouvá dopředu o odpovídající
počet bytů po každém čtení či zápisu. Jakmile tedy přečtete ze souboru <code>n</code> bytů, tak se pozice posune
o <code>n</code> pozic dopředu. Pokud byste tedy dvakrát po sobě přečetli jeden byte ze souboru obsahující text
<code>ABC</code>, nejprve získáte znak <code>A</code>, a podruhé už znak <code>B</code>, protože po prvním čtení se pozice posunula
dopředu o jeden byte.</p>
<blockquote>
<p>Tím, že je pozice sdílená pro čtení a zápis, tak se raději vyvarujte současnému čtení i zápisu
nad stejným otevřeným souborem. V opačném případě budete muset být opatrní, abyste si omylem
nepřepsali data nebo nečetli data ze špatné pozice.</p>
</blockquote>
<p>Současnou pozici v souboru můžete zjistit pomocí funkce <a href="https://devdocs.io/c/io/ftell"><code>ftell</code></a>.
Pokud byste chtěli pozici ručně změnit, můžete použít funkci <a href="https://devdocs.io/c/io/fseek"><code>fseek</code></a>,
pomocí které se také například můžete v souboru přesunout na začátek (např. abyste ho přečetli
podruhé) nebo na konec (např. abyste zjistili, kolik soubor celkově obsahuje bytů)<sup class='margin-toggle sidenote-number'>1</sup>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Toho můžete dosáhnout tak, že pomocí <code>fseek(file, 0, SEEK_END)</code> přesunete pozici na konec
souboru, a dále pomocí <code>ftell(file)</code> zjistíte, na jaké pozici jste. To vám řekne, kolik má soubor
celkově bytů.</p>
</span>
<blockquote>
<p>Při použití módu <code>&quot;a&quot;</code> budou veškeré zápisy probíhat vždy na konci souboru. Tento mód se hodí
například při zápisu do tzv. <strong>logovacích souborů</strong>, které chronologicky zaznamenávají události v
programu (události tak vždy pouze přibývají). Zároveň se však po každém zápisu v tomto módu
pozice posune na jeho konec. Raději tak nepoužívejte mód <code>&quot;a+&quot;</code>, který umožňuje zápis na konec i
čtení. Práce s pozicí při současném zapisování i čtení je v takovémto módu totiž poněkud náročná.</p>
</blockquote>
<p>Všimněte si, že při práci se <code>stdout</code> a <code>stdin</code> jsme s pozicí manipulovat nemohli. Je to proto, že
tyto dva deskriptory jsou z jistého pohledu &quot;obecnější&quot; než soubory. Můžou být přesměrované na
terminál, do souboru, ale klidně také i do jiného počítače přes síť. Tím, že nevíme, &quot;co jsou zač&quot;,
tak si s nimi nemůžeme dovolit provádět některé operace, jako je právě manipulace s pozicí. Pokud
například odešleme data přes síť, už je nemůžeme &quot;vrátit zpátky&quot; změnou pozice. U souborů však
víme, že opravdu pracujeme se souborem, takže pozici pro zápis a čtení měnit můžeme.</p>
<h2><a class="header" href="#zápis-a-čtení-souborů" id="zápis-a-čtení-souborů">Zápis a čtení souborů</a></h2>
<p>V následujících sekcích se dozvíte, jak <a href="c/soubory/zapis_do_souboru.html">zapisovat</a> a <a href="c/soubory/cteni_ze_souboru.html">číst</a>
ze souborů.</p>
<h1><a class="header" href="#zápis-do-souboru" id="zápis-do-souboru">Zápis do souboru</a></h1>
<p>Pokud chceme do otevřeného souboru zapsat nějaké byty, můžeme použít funkci
<a href="https://devdocs.io/c/io/fwrite"><code>fwrite</code></a>:</p>
<pre><code class="language-c">size_t fwrite(
    const void* buffer, // adresa, ze které načteme data do souboru
    size_t size,        // velikost prvku, který zapisujeme
    size_t count,       // počet prvků, které zapisujeme
    FILE* stream        // soubor, do kterého zapisujeme
);
</code></pre>
<p>Funkce <code>fwrite</code> předpokládá, že budeme do souboru zapisovat více hodnot stejného datového typu.
Parametr <code>size</code> udává velikost tohoto datového typu a parametr <code>count</code> počet hodnot, které chceme
zapsat. Pokud tuto funkci zavoláme, tak dojde k zápisu <code>size * count</code> bytů z adresy <code>buffer</code> do
souboru <code>stream</code>. Návratová hodnota <code>fwrite</code> značí, kolik prvků bylo do souboru úspěšně zapsáno.
Pokud je tato hodnota menší než <code>count</code>, tak došlo k nějaké chybě. Například zápis pěti celých
čísel do souboru by mohl vypadat následovně:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

int main() {
    int pole[5] = { 1, 2, 3, 4, 5 };

    // otevření souboru
    FILE* soubor = fopen(&quot;soubor&quot;, &quot;wb&quot;);
    assert(soubor);

    // binární zápis do souboru
    int zapsano = fwrite(pole, sizeof(int), 5, soubor);
    assert(zapsano == 5);

    // zavření souboru
    fclose(soubor);    

    return 0;
}
</code></pre>
<blockquote>
<p>Při takovémto použití <code>fwrite</code> může dojít k zapsání například pouze <code>3</code> čísel, pokud během zápisu
dojde k chybě<sup class='margin-toggle sidenote-number'>1</sup>. Pokud bychom chtěli zapsat buď vše nebo nic, můžeme říct, že zapisujeme pouze
jeden prvek a parameter <code>count</code> nastavit na celkovou velikost všech dat, které chceme zapsat:</p>
<span class='sidenote'><p><sup class='number'>1</sup>V takovémto případě by funkce <code>fwrite</code> vrátila hodnotu <code>3</code>.</p>
</span>
<pre><code class="language-c">int pole[5] = { 1, 2, 3, 4, 5 };
fwrite(pole, sizeof(pole), 1, soubor);
</code></pre>
</blockquote>
<p>Pokud bychom zapsali <code>pole</code> do souboru takto, uloží se do něj celkem <code>20</code> (<code>5</code> * <code>4</code>) bytů (čísel),
které později můžeme v programu zase <a href="c/soubory/cteni_ze_souboru.html">načíst zpátky</a>. Pokud bychom se podívali,
co v souboru je, nalezli bychom seznam čísel <code>1 0 0 0 2 0 0 0 3 0 0 0 4 0 0 0 5 0 0 0</code>, což odpovídá
paměťové reprezentaci pole pěti <code>int</code>ů, které bylo vytvořeno výše.</p>
<h2><a class="header" href="#textový-zápis" id="textový-zápis">Textový zápis</a></h2>
<p>Pokud bychom chtěli tato data zapsat do souboru v textové podobě (a ne pouze jako jejich binární
reprezentaci), můžeme čísla z výše zmíněného pole zapsat pomocí nějakého textového kódování,
například <a href="c/soubory/../text/znaky.html">ASCII</a>. K tomu můžeme využít funkci
<a href="https://devdocs.io/c/io/fprintf"><code>fprintf</code></a>, která funguje stejně jako <code>printf</code>, s tím rozdílem,
že text nevypisuje na <code>stdout</code>, ale do předaného souboru<sup class='margin-toggle sidenote-number'>2</sup>:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Všimněte si, že zde jsme použili <a href="c/soubory/otevirani_souboru.html#M%C3%B3d-otev%C5%99en%C3%AD">mód otevření</a> pro textový
zápis (<code>&quot;w&quot;</code>), namísto binárního zápisu <code>&quot;wb&quot;</code> použitého výše.</p>
</span>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

int main() {
    int pole[5] = { 1, 2, 3, 4, 5 };

    // otevření souboru
    FILE* soubor = fopen(&quot;soubor.txt&quot;, &quot;wt&quot;);
    assert(soubor);

    // textový zápis do souboru
    for (int i = 0; i &lt; 5; i++) {
        fprintf(soubor, &quot;%d &quot;, pole[i]);
    }

    // zavření souboru
    fclose(soubor);    

    return 0;
}
</code></pre>
<p>V tomto případě by se do souboru zapsalo deset bytů (čísel) <code>49 32 50 32 51 32 52 32 53 32</code>, protože
číslice jsou v <a href="https://www.asciitable.com/">ASCII</a> reprezentovány čísly <code>48</code> až <code>57</code> a mezera je
reprezentována číslem <code>32</code>. Pokud bychom tento soubor otevřeli v textovém editoru, tak by se nám
zobrazil text <code>1 2 3 4 5 </code>.</p>
<h2><a class="header" href="#bufferování" id="bufferování">Bufferování</a></h2>
<p>Stejně jako při zápisu do <code>stdout</code> se i při zápisu do souborů uplatňuje
<a href="c/soubory/../text/vstupavystup.html#standardn%C3%AD-souborov%C3%A9-deskriptory"><em>bufferování</em></a>. Data, která do souboru
zapíšeme, se tak v něm neobjeví hned. Pokud bychom chtěli donutit náš program, aby data uložená
v bufferu opravdu vypsal do souboru, můžeme použít funkci <a href="https://devdocs.io/c/io/fflush"><code>fflush</code></a>
<sup class='margin-toggle sidenote-number'>3</sup>.</p>
<span class='sidenote'><p><sup class='number'>3</sup>Ani zavolání funkce <code>fflush</code> však nezajistí, že se data opravdu zapíšou na fyzické médium
(například harddisk). To je ve skutečnosti velmi obtížný <a href="https://lwn.net/Articles/457667/">problém</a>.</p>
</span><h1><a class="header" href="#Čtení-ze-souboru" id="Čtení-ze-souboru">Čtení ze souboru</a></h1>
<p>Pro čtení ze souboru můžeme použít funkci <a href="https://devdocs.io/c/io/fread"><code>fread</code></a>, která je
protikladem funkce <code>fwrite</code>:</p>
<pre><code class="language-c">size_t fread(
    void* buffer,   // adresa, na kterou zapíšeme data ze souboru
    size_t size,    // velikost prvku, který načítáme
    size_t count,   // počet prvků, které načítáme
    FILE* stream    // soubor, ze kterého čteme
);
</code></pre>
<p>Tato funkce opět předpokládá, že budeme ze souboru načítat několik hodnot stejného datového typu.
Například načtení pěti celých čísel, které jsme zapsali v kódu <a href="c/soubory/zapis_do_souboru.html">zde</a>, by mohlo
vypadat následovně:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

int main() {
    int pole[5] = { 1, 2, 3, 4, 5 };

    // otevření souboru
    FILE* soubor = fopen(&quot;soubor&quot;, &quot;rb&quot;);
    assert(soubor);

    // čtení ze souboru
    int precteno = fread(pole, sizeof(int), 5, soubor);
    assert(precteno == 5);

    // zavření souboru
    fclose(soubor);    

    return 0;
}
</code></pre>
<p>Funkce <code>fread</code> vrací počet prvků, které úspěšně načetla ze souboru.</p>
<h2><a class="header" href="#textové-čtení" id="textové-čtení">Textové čtení</a></h2>
<p>Pokud bychom chtěli načítat ze souboru ASCII text, můžeme použít již známé funkce pro načítání textu,
například <a href="https://devdocs.io/c/io/fgets"><code>fgets</code></a><sup class='margin-toggle sidenote-number'>1</sup> nebo <a href="https://devdocs.io/c/io/fscanf"><code>fscanf</code></a>,
což je varianta funkce <code>scanf</code> určená pro formátované čtení ze souborů.</p>
<span class='sidenote'><p><sup class='number'>1</sup>S funkcí <code>fgets</code> jsme se setkali již <a href="c/soubory/../text/vstup.html#na%C4%8Dten%C3%AD-%C5%99%C3%A1dku">dříve</a>, kdy jsme jí
jako poslední parametr globální proměnnou <code>stdin</code>. Datový typ proměnné <code>stdin</code> je právě <code>FILE*</code> –
při spuštění programu standardní knihovna <em>C</em> vytvoří proměnné <code>stdin</code>, <code>stdout</code> a <code>stderr</code> a uloží
do nich standardní vstup, výstup a chybový výstup.</p>
</span>
<blockquote>
<p>U načítání dat si vždy dejte pozor na to, abyste na adrese, kterou předáváte do <code>fread</code> nebo
<code>fgets</code>, měli dostatek naalokované validní paměti. Jinak by se mohlo stát, že data ze souboru
přepíšou adresy v paměti, kde leží nějaké nesouvisející hodnoty, což by vedlo k
<a href="c/soubory/../../caste_chyby/pametove_chyby.html#segmentation-fault">paměťové chybě</a> 💣.</p>
</blockquote>
<h3><a class="header" href="#rozpoznání-konce-souboru" id="rozpoznání-konce-souboru">Rozpoznání konce souboru</a></h3>
<p>Při čtení ze souboru je třeba vyřešit jednu dodatečnou věc – jak rozpoznáme, že už jsme soubor
přečetli celý a už v něm nic dalšího nezbývá? Pokud načítáme data ze souboru &quot;binárně&quot;, tj.
interpretujeme je jako byty a ne jako (ASCII) text, obvykle stačí si velikost souboru
<a href="c/soubory/prace_se_soubory.html#pozice-v-souboru">předpočítat</a> po jeho otevření pomocí funkcí
<a href="https://devdocs.io/c/io/ftell"><code>ftell</code></a> a <a href="https://devdocs.io/c/io/fseek"><code>fseek</code></a> nebo si ji
přečíst přímo ze samotného souboru<sup class='margin-toggle sidenote-number'>2</sup>.</p>
<span class='sidenote'><p><sup class='number'>2</sup>Spousta binárních formátů (např. <code>JPEG</code>) jsou tzv. <strong>samo-popisné</strong> (<em>self-describing</em>), což
znamená, že typicky na začátku souboru je v pevně stanoveném formátu (tzv. <em>hlavičce</em>) uvedeno,
jak je daný soubor velký. Využijeme toho například při práci s obrázkovým formátem
<a href="c/soubory/../aplikovane_ulohy/tga.html"><code>TGA</code></a>.</p>
</span>
<p>Co ale dělat, když načítáme textové soubory, jejichž formát obvykle není ani zdaleka pevně daný?
Předpočítat si velikost souboru a pak muset po každém načtení např. řádku počítat, kolik znaků jsme
vlastně načetli, by bylo relativně komplikované. Při čtení textových souborů se tak obvykle využívá
jiná strategie – čteme ze souboru tak dlouho, dokud nedojde k chybě. Způsob detekce chyby záleží na
použité funkci:</p>
<ul>
<li><a href="https://devdocs.io/c/io/fscanf"><code>fscanf</code></a> vrátí číslo <code>&lt;= 0</code>, pokud se jí nepodaří načíst žádný
zástupný znak ze vstupu.</li>
<li><a href="https://devdocs.io/c/io/fgets"><code>fgets</code></a> vrátí ukazatel s hodnotou <code>0</code>, pokud dojde k chybě při
čtení.</li>
</ul>
<p>Jakmile dojde k chybě, tak bychom ještě měli ověřit, jestli jsme opravdu na konci souboru, anebo
byla chyba způsobena něčím jiným<sup class='margin-toggle sidenote-number'>3</sup>. To můžeme zjistit pomocí funkcí
<a href="https://devdocs.io/c/io/feof"><code>feof</code></a>, která vrátí nenulovou hodnotu, pokud jsme se před jejím
zavoláním pokusili o čtení a <a href="c/soubory/prace_se_soubory.html#pozice-v-souboru">pozice</a> již byla na konci souboru,
a <a href="https://devdocs.io/c/io/ferror"><code>ferror</code></a>, která vrátí nenulovou hodnotu, pokud došlo k nějaké
jiné chybě při práci se souborem. </p>
<span class='sidenote'><p><sup class='number'>3</sup>Například pokud čteme soubor z USB flashky, který je během čtení odpojen od počítače.</p>
</span>
<p>Program, který by načítal a rovnou vypisoval řádky textu ze vstupního souboru, dokud nedojde na
jeho konec, by tedy mohl vypadat například takto:</p>
<pre><code class="language-c">#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    FILE* soubor = fopen(&quot;soubor.txt&quot;, &quot;rt&quot;);
    assert(soubor);

    char radek[80];
    while (1) {
        if (fgets(radek, sizeof(radek), soubor)) {
            // radek byl uspesne nacten
            printf(&quot;Nacteny radek: %s&quot;, radek);
        }
        else {
            if (feof(soubor)) {
                printf(&quot;Dosli jsme na konec souboru\n&quot;);
            } else if (ferror(soubor)) {
                printf(&quot;Pri cteni ze souboru doslo k chybe: %s\n&quot;, strerror(errno));
            }

            break;
        }
    }

    fclose(soubor);

    return 0;
}
</code></pre>
<h1><a class="header" href="#modularizace" id="modularizace">Modularizace</a></h1>
<p>Prozatím byly naše programy tvořeny pouze jedním zdrojovým souborem. Pro krátké programy do pár
stovek řádků to stačí, nicméně asi si dovedete představit, že programy s tisíce či miliony řádků kódu
už se do jednoho souboru rozumně &quot;nevlezou&quot;. V této sekci si tak ukážeme, jak programy v <em>C</em> rozdělit
do více zdrojových souborů.</p>
<p>Rozdělení programu do více souborů má spoustu výhod:</p>
<ul>
<li>
<p><strong>Větší přehlednost</strong> Pokud by byl veškerý kód v jednom zdrojovém souboru, tak by se v takovém souboru
dalo u větších programů jen těžko vyznat. Pokud budou jednotlivé logické části programu umístěny
v samostatných souborech či adresářích, bude např. mnohem jednodušší najít část programu, kterou
chceme upravit.</p>
<p>Například u hry bychom mohli rozdělit program do souborů <code>zvuk.c</code>, <code>grafika.c</code>, <code>ovladani_priser.c</code>,
<code>zbrane.c</code>, <code>klavesnice.c</code>, <code>mys.c</code> atd. Pokud by některý z těchto souborů byl opět moc velký
nebo složitý, můžeme jeho funkcionalitu dále rozdělit do více souborů.</p>
</li>
<li>
<p><strong>Menší provázanost</strong> Pokud je vše v jednom souboru, znamená to, že z libovolné funkce lze volat
všechny ostatní funkce (popř. používat všechny ostatní struktury atd.). Toto vede k situaci, kdy jsou
jednotlivé části programu na sobě vzájemně závislé a propojené. To možná zní nevinně, nicméně ve
skutečnosti to téměř nevyhnutelně vede k programu, který je velmi obtížné upravit. Pokud totiž
změníte jednu věc, často se musí změnit i všechny další věci (funkce, struktury), které na dané věci
závisí. Pokud závisí vše na všem, tak i malá změna v jedné části kódu může kaskádově vyvolat nutnost
upravit celý zbytek programu, což je náročné.</p>
<p>Abychom tomu předešli, je vhodné učinit jednotlivé části programu samostatné, sdílet z nich se
zbytkem kódu pouze to, co je opravdu potřeba, a zbytek funkcionality učinit &quot;soukromou&quot; pro daný
soubor. Změny v těchto soukromých částech pak nemohou ovlivnit zbytek kódu, protože ten na nich
nebude závislý.</p>
</li>
<li>
<p><strong>Efektivnější spolupráce v týmu</strong> Rozdělení na více souborů také usnadní týmovou spolupráci.
Pokud budou jednotliví programátoři upravovat jiné soubory, bude mnohem menší riziko tzv. &quot;souběhu&quot;,
kdy by jejich změny ve stejném souboru mohly kolidovat. Tyto problémy pak dále řeší tzv.
<a href="https://cs.wikipedia.org/wiki/Verzov%C3%A1n%C3%AD">verzování</a>, o kterém se dozvíte v navazujících
předmětech.</p>
</li>
<li>
<p><strong>Znovuvyužití kódu</strong> Pokud by každý program musel implementovat veškerou funkcionalitu od nuly,
tak by bylo programování i jednoduchého programu nesmírně náročné.<sup class='margin-toggle sidenote-number'>1</sup> V rámci jednoho programu si
můžeme nějakou ucelenou funkcionalitu (např. sadu funkcí spolu se strukturami) vyčlenit do
samostatného souboru, což nám umožní ji opakovaně používat z ostatních souborů v našem programu.
Napříč programy pak můžeme sdílet kód pomocí tzv. <strong>knihoven</strong> (<em>libraries</em>). Pro obojí musíme umět
používat kód, který se nenachází ve zdrojovém souboru, ze kterého ho chceme využít.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Ostatně například bez <a href="c/modularizace/../funkce/stdlib.html">standardní knihovny <em>C</em></a> bychom v našem programu
ani nebyli schopni něco vypsat do terminálu.</p>
</span></li>
</ul>
<p>V programovacích jazycích se obecně různé samostatné části kódu, které jsou typicky umístěny v
adresářích či souborech, a starají se o konkrétní funkcionalitu v programu, nazývají <em>moduly</em>.
Proto je tato sekce nazvána <em>modularizace</em>. Jedná se však spíše o obecný pojem, v jazyce <em>C</em> se přímo
s pojmem modul zase tak běžně nesetkáte.</p>
<p>Postupně si ukážeme:</p>
<ul>
<li>Jak funguje překlad programů <a href="c/modularizace/linker.html">s více zdrojovými soubory</a></li>
<li>Jak používat funkce a proměnné <a href="c/modularizace/pouzivani_kodu_z_jinych_souboru.html">z jiných souborů</a></li>
<li>Jaké jsou konvence pro používání <a href="c/modularizace/hlavickove_soubory.html">více zdrojových souborů v C</a></li>
<li>Jak používat kód, který napsal někdo jiný, a nasdílel ho v podobě <a href="c/modularizace/knihovny.html">knihovny</a></li>
</ul>
<h1><a class="header" href="#linker" id="linker">Linker</a></h1>
<p>V této sekci si vysvětlíme detailněji, jak probíhá překlad <em>C</em> programů, jehož základní fungování
již bylo stručně popsáno v sekci o <a href="c/modularizace/../../prostredi/preklad_programu.html">překladu</a>. Díky tomu pak
budeme schopni vytvářet programy skládající se z více než jednoho zdrojového souboru.</p>
<p>Prozatím jsme naše programy (skládající se z jediného zdrojového souboru) překládali pomocí
příkazu podobnému tomuto:</p>
<pre><code class="language-bash">$ gcc soubor.c -o program
</code></pre>
<p>Tímto příkazem jsme ve skutečnosti prováděli dvě věci najednou: <strong>překlad</strong> (<em>translation</em>) a
<strong>linkování</strong> (<em>linking</em>). Níže si vysvětlíme obě dvě tyto části detailněji.</p>
<blockquote>
<p>Překlad a linkování se dohromady nazývá <strong>kompilace</strong> programu.</p>
</blockquote>
<h2><a class="header" href="#překlad-programu-1" id="překlad-programu-1">Překlad programu</a></h2>
<p>Programy v <em>C</em> se skládají z jedné či více tzv. <strong>jednotek překladu</strong> (<em>translation unit</em>). Jedná se
o nezávislé komponenty, ze kterých je nakonec vytvořen cílový program. Každá jednotka je obvykle
tvořena jedním zdrojovým souborem (obvykle s příponou <code>.c</code>). Při překladu <strong>překladač</strong> převede
jednotku ze zdrojového kódu v <em>C</em> do instrukcí procesoru, tzv. <strong>objektového kódu</strong> (<em>object code</em>).</p>
<p>Pokud chceme překladačem <code>gcc</code> (pouze) přeložit zdrojový soubor do objektového kódu (resp.
objektového souboru), můžeme použít přepínač <code>-c</code>:</p>
<pre><code class="language-bash">$ gcc -c soubor.c
</code></pre>
<p>Pokud nezadáme název výstupu pomocí přepínače <code>-o</code>, tak <code>gcc</code> implicitně vytvoří objektový soubor
<code>&lt;nazev-vstupu&gt;.o</code> (tj. zde <code>soubor.o</code>).</p>
<p>Jednotky překladu jsou na sobě nezávislé, můžeme tedy každou jednotku (zdrojový soubor) přeložit
zvlášť:</p>
<pre><code class="language-bash">$ gcc -c a.c
$ gcc -c b.c
...
</code></pre>
<p>Jak ale nyní jednotlivé soubory propojíme? Aby vůbec mělo rozdělení do více jednotek (souborů) smysl,
tak musíme mít možnost v jednom souboru používat kód (např. funkce nebo globální proměnné), který je
nadefinovaný v jiném souboru. V <em>C</em> toto propojení jednotek neprobíhá při překladu, ale až v následné
fázi nazývané linkování.</p>
<h2><a class="header" href="#linkování-programu" id="linkování-programu">Linkování programu</a></h2>
<p>Jakmile přeložíme všechny naše zdrojové soubory postupně do objektových souborů, potřebujeme z nich
vytvořit finální spustitelný soubor, což je práce programu nazývaného <strong>linker</strong>. Linker obdrží
seznam všech (již přeložených) objektových souborů, ze kterých se má program skládat, propojí je
dohromady a vytvoří z nich spustitelný soubor.</p>
<p>Jak propojení jednotlivých souborů probíhá? Představme si například, že v souboru <code>a.c</code> voláme
funkci <code>foo</code>, která v tomto souboru neexistuje. Při překladu tohoto souboru překladač vytvoří
objektový soubor <code>a.o</code>, ve kterém bude uložena informace, že voláme funkci <code>foo</code>. Dejme tomu, že
tato funkce existuje v souboru <code>b.c</code>, který je přeložen do objektového souboru <code>b.o</code>. Při linkování
linker obdrží seznam všech objektových souborů, tedy <code>a.o</code> i <code>b.o</code>. Když narazí na informaci, že z
<code>a.o</code> chceme volat funkci <code>foo</code>, pokusí se tuto funkci naleznout v některém z předaných objektových
souborů:</p>
<ul>
<li>Pokud jej nenalezne, tak vypíše chybu a program se nepřeloží<sup class='margin-toggle sidenote-number'>1</sup>.<span class='sidenote'><p><sup class='number'>1</sup>V takovém případě byste se setkali s chybou <code>undefined reference to 'foo'</code>.</p>
</span></li>
<li>Pokud jej nalezne (v tomto případě v <code>b.o</code>), tak volání funkce &quot;propojí&quot; tak, aby se volala správná
funkce původně vytvořená v <code>b.c</code>.</li>
</ul>
<p>Manuální použití linkeru<sup class='margin-toggle sidenote-number'>2</sup> je relativně složité, proto i linker budeme používat přes <code>gcc</code>. Tomu
můžeme předat sadu objektových souborů a on se postará o správné zavolání linkeru, který je spojí
a vytvoří finální spustitelný soubor:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Na Linuxu lze použít například linker <code>ld</code>.</p>
</span>
<pre><code class="language-bash">$ gcc a.o b.o -o program
</code></pre>
<p>Při finálním linkování programu také dochází ke kontrole toho, jestli je v některém z objektových
souborů obsažena funkce <code>main</code>, aby program věděl, kde má začít své vykonávání.</p>
<h4><a class="header" href="#proč-takto-složitě" id="proč-takto-složitě">Proč takto složitě?</a></h4>
<p>Možná vás napadlo, proč kompilace <em>C</em> programů probíhá takto komplikovaně a nestačí prostě překladači
dát všechny zdrojové soubory našeho programu tak, jak jsme to dělali doposud:</p>
<pre><code class="language-bash">$ gcc soubor1.c soubor2.c soubor3.c ...
</code></pre>
<p>Ve skutečnosti i to lze provést (tento postup se nazývá tzv. <strong>unity build</strong>). Nicméně má velkou
nevýhodu. Pokud bychom překládali celý náš program najednou, při sebemenší změně kódu bychom museli
přeložit všechny soubory znovu. Pokud bychom tak měli obrovský program s tisícem zdrojových souborů
a změnili jeden znak v jednom souboru, muselo by se všech tisíc souborů přeložit znovu, což může být
dost pomalé<sup class='margin-toggle sidenote-number'>3</sup>.</p>
<span class='sidenote'><p><sup class='number'>3</sup>Velké programy v <em>C</em> může trvat přeložit klidně i několik hodin nebo dokonce dnů!</p>
</span>
<p>Pokud překládáme každý soubor zvlášť, tak po změně v jednom souboru stačí přeložit daný soubor a znovu
slinkovat všechny objektové soubory (ty původní můžeme znovuvyužít, protože se nezměnily). To je u
velkých programů mnohem rychlejší než překládat vše od nuly.</p>
<p>Navíc pokud bychom se nanučili používat zvlášť překladač a linker, nemohli bychom používat
<a href="c/modularizace/knihovny.html">knihovny</a>, u kterých obvykle nemáme přístup k samotnému zdrojovému kódu, ale pouze k
již přeloženému objektovému kódu<sup class='margin-toggle sidenote-number'>4</sup>.</p>
<span class='sidenote'><p><sup class='number'>4</sup>Například proto, aby autor knihovny zatajil původní zdrojový kód, který je jeho duševním
vlastnictvím.</p>
</span><h1><a class="header" href="#používání-kódu-z-jiných-souborů" id="používání-kódu-z-jiných-souborů">Používání kódu z jiných souborů</a></h1>
<p>Nyní už víme, jak přeložit program skládající se z více jednotek překladu (zdrojových souborů) a
následně tyto jednotky spojit dohromady pomocí linkeru. V této sekci si ukážeme, jak můžeme použít
kód, který existuje v jiném zdrojovém souboru.</p>
<p>Pokud chceme zavolat funkci, kterou jsme napsali v jiném souboru, můžeme ji prostě zavolat a linker
se postará o zbytek:</p>
<pre><code class="language-c">// soubor1.c
int main() {
    moje_funkce();
    return 0;
}

// soubor2.c
void moje_funkce() {}
</code></pre>
<p>Pokud tyto dva soubory přeložíme a poté slinkujeme, tak se zavolá správná funkce:</p>
<pre><code class="language-bash">$ gcc -c soubor1.c
$ gcc -c soubor2.c
$ gcc soubor1.o soubor2.o -o program
</code></pre>
<p>Nicméně, pokud bychom používali kód z jiných souborů takto &quot;naslepo&quot;, narazili bychom na několik
problémů. Tím, že překladač v souboru <code>soubor1.c</code> nemá přístup k <a href="c/modularizace/../funkce/funkce.html#syntaxe">signatuře</a>
funkce <code>moje_funkce</code>, tak nemůže ověřit, jestli jsme jí předali správný počet argumentů se správnými
datovými typy, a ani neví, jaký je datový typ návratové hodnoty této funkce.</p>
<p>Kód &quot;naslepo&quot; navíc nebude vůbec fungovat pro použití (globálních) proměnných. Při pokusu o
použití neexistující proměnné by překladač totiž rovnou ohlásil chybu.</p>
<h2><a class="header" href="#deklarace-vs-definice" id="deklarace-vs-definice">Deklarace vs definice</a></h2>
<p>Ideálně bychom potřebovali překladači říct, jak bude kód, který chceme použít, vypadat – jaký bude
datový typ a název globální proměnné, popř. jaké budou parametry, návratový typ a název funkce.
Toho můžeme dosáhnout pomocí tzv. <strong>deklarace</strong> (<em>declaration</em>).</p>
<p>Deklarace &quot;slibuje&quot;, že bude v programu existovat nějaká proměnná či funkce s konkrétním názvem a
typem, ale neříká, kde bude tato proměnná či funkce vytvořena (může to být například v jiném
zdrojovém souboru). Samotné vytvoření funkce či proměnné se nazývá <strong>definice</strong> (<em>definition</em>).
Zatím jsme tedy prováděli vždy definice funkcí i proměnných, nyní si ukážeme, jak vytvořit pouze
deklaraci.</p>
<p>Deklaraci funkce provedeme tak, že zadáme její <a href="c/modularizace/../funkce/funkce.html#syntaxe">signaturu</a>, ale ne její
tělo:</p>
<pre><code class="language-c">int funkce(int a, int b);           // deklarace funkce
int funkce(int a, int b) { ... }    // definice funkce
</code></pre>
<p>Deklaraci globální proměnné lze provést tak, že před ní dáme klíčové slovo <code>extern</code><sup class='margin-toggle sidenote-number'>1</sup>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Toto klíčové slovo můžeme použít i před deklarací funkce, nicméně není to potřeba, <code>extern</code> je
na tomto místě předpokládáno implicitně.</p>
</span>
<pre><code class="language-c">extern int promenna;    // deklarace proměnné
int promenna;           // definice proměnné
</code></pre>
<blockquote>
<p>Při sdílení kódu napříč soubory má smysl se bavit pouze o
<a href="c/modularizace/../promenne/globalni_promenne.html">globálních proměnných</a>. Lokální proměnné lze totiž používat vždy
pouze v rámci jedné funkce.</p>
</blockquote>
<p>Díky deklaracím tak můžeme v jednom zdrojovém souboru určit, jak mají vypadat funkce a proměnné, které
chceme používat, aby překladač mohl provádět kontrolu datových typů. Linker pak během linkování použije
správné proměnné/funkce z odpovídajících zdrojových souborů. Více o tom, kde a jak deklarace vytvářet,
se dozvíme v příští sekci o <a href="c/modularizace/hlavickove_soubory.html">hlavičkových souborech</a>.</p>
<h2><a class="header" href="#jednoprůchodový-překlad" id="jednoprůchodový-překlad">Jednoprůchodový překlad</a></h2>
<p>Z historických důvodů překladače <em>C</em> fungují v tzv. jednoprůchodovém režimu (<em>one-pass compilation</em>).
Znamená to, že překladač &quot;čte&quot; náš zdrojový kód shora dolů, a v momentě, kdy chceme například použít
nějakou funkci nebo proměnnou, tak již překladač dříve musel vidět (alespoň) její deklaraci, popř.
rovnou i definici.</p>
<p>Například v následujícím programu:</p>
<pre><code class="language-c">void funkce1() {
    funkce2();
}
void funkce2() {}
</code></pre>
<p>si překladač bude stěžovat na to, že na řádku 2 nezná funkci <code>funkce2</code>, protože tato funkce je v
souboru nadefinovaná až po funkci <code>funkce1</code>, která ji používá:</p>
<pre><code>test.c: In function ‘funkce’:
test.c:2:5: warning: implicit declaration of function ‘funkce2’;
    2 |     funkce2();
</code></pre>
<p>Pokud tedy potřebujeme nadefinovat funkci na pozdějším místě, než je její první použití, můžeme
nejprve vytvořit její deklaraci a až později (popř. v úplně jiném souboru) vytvořit její definici:</p>
<pre><code class="language-c">void funkce2();     // deklarace

void funkce1() {
    funkce2();      // použití
}
void funkce2() {}   // definice
</code></pre>
<p>Takovýto program už se přeloží bez varování. Koncept deklarování funkcí či proměnných v
jednoprůchodových překladačích se nazývá <strong>dopředná deklarace</strong> (<em>forward declaration</em>).</p>
<h2><a class="header" href="#pravidlo-jedné-definice" id="pravidlo-jedné-definice">Pravidlo jedné definice</a></h2>
<p>V <em>C</em> platí tzv. <strong>pravidlo jedné definice</strong> (<em>one definition rule</em>). Každá proměnná i funkce musí
být v programu <em>nadefinována</em> právě jednou (deklarována může být vícekrát). To platí jak v rámci
jednoho souboru, tak v rámci celého programu (tj. napříč všemi zdrojovými soubory).</p>
<ul>
<li>Pokud bychom proměnnou či funkci pouze nadeklarovali a/nebo použili bez definice:
<pre><code class="language-c">// soubor.c
void funkce();

int main() {
    funkce();
    return 0;
}
</code></pre>
Tak by kompilace selhala v době linkování, protože by nenašel žádnou funkci/proměnnou, kterou
by mohl použít:
<pre><code class="language-bash">$ gcc -c soubor.c
$ gcc soubor.o
/usr/bin/ld: test.o: in function `main':
test.c:(.text+0xe): undefined reference to `funkce'
collect2: error: ld returned 1 exit status
</code></pre>
</li>
<li>Pokud bychom naopak nadefinovali proměnnou či funkci více než jednou:
<pre><code class="language-c">// soubor1.c
void funkce() {}

int main() {
    funkce();
    return 0;
}
// soubor2.c
void funkce() {}
</code></pre>
Tak by linkování opět selhalo, protože by linker nevěděl, kterou definici použít:
<pre><code class="language-bash">$ gcc -c soubor1.c
$ gcc -c soubor2.c
$ gcc soubor1.o soubor2.o
/usr/bin/ld: soubor2.o: in function `funkce':
soubor2.c:(.text+0x0): multiple definition of `funkce'; test.o:test.c:(.text+0x0): first defined here
collect2: error: ld returned 1 exit status
</code></pre>
</li>
</ul>
<h2><a class="header" href="#viditelnost-funkcí-a-proměnných" id="viditelnost-funkcí-a-proměnných">Viditelnost funkcí a proměnných</a></h2>
<p>Z jiných souborů lze používat pouze funkce a proměnné, které jsou <em>veřejné</em>. Implicitně jsou
všechny funkce i všechny globální proměnné veřejné. Pokud byste chtěli zamezit tomu, aby mohly
ostatní soubory používat nějakou funkci nebo globální proměnnou, můžete ji označit klíčovým slovem
<code>static</code>, abyste z nich udělali <em>soukromé</em> funkce či proměnné:</p>
<pre><code class="language-c">static void soukroma_funkce() {}
static int soukroma_promenna;
</code></pre>
<p>Takovéto funkce a proměnné půjde používat pouze v souboru, ve kterém byly nadefinovány. Doporučujeme
<code>static</code> používat pro označení proměnných a funkcí, které nechcete sdílet se zbytkem programu. Půjde
tak na první pohled poznat, které funkce jsou určeny k použití z jiných souborů a které ne<sup class='margin-toggle sidenote-number'>2</sup>.</p>
<span class='sidenote'><p><sup class='number'>2</sup>Použití <code>static</code> také může v určitých případech vést k vygenerování efektivnějšího kódu a
menší velikosti výsledného spustitelného souboru.</p>
</span>
<blockquote>
<p>Klíčové slovo <code>static</code> lze také použít u lokálních proměnných, zde má ovšem úplně jiný význam než
u globálních proměnných! Použití <code>static</code> u lokální proměnné z ní udělá proměnnou uloženou v
<a href="c/modularizace/../prace_s_pameti/globalni_pamet.html">globální paměti</a>. Takováto proměnná se nainicializuje, když
se program poprvé dostane k řádku s její definicí. Proměnná bude existovat po celou dobu běhu
programu a udrží si svou hodnotu i po skončení volání funkce:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void test() {
  static int x = 0;
  x += 1;
  printf(&quot;%d\n&quot;, x);
}

int main() {
  test();
  test();
  return 0;
}
</code></pre>
</blockquote>
<h1><a class="header" href="#hlavičkové-soubory" id="hlavičkové-soubory">Hlavičkové soubory</a></h1>
<p>Nyní už víme, že pro použití kódu z jiných souborů bychom nejprve měli dané funkce a proměnné
<a href="c/modularizace/pouzivani_kodu_z_jinych_souboru.html#deklarace-vs-definice">deklarovat</a>. Pokud bychom však museli
v každém souboru, ve kterém chceme použít kód z jiného souboru, museli vytvářet deklarace pro
každou funkci či proměnnou, kterou chceme použít, bylo by to docela zdlouhavé. Pokud by navíc došlo
ke změně datového typu či názvu takovéto sdílené funkce či proměnné, museli bychom deklarace upravit
ve všech souborech, kde funkci či proměnnou používáme.</p>
<p>Pro vyřešení tohoto problému se v <em>C</em> často využívá koncept tzv. <strong>hlavičkových souborů</strong>
(<em>header files</em>). Pro každý zdrojový soubor, jehož kód chceme sdílet, vytvoříme hlavičkový soubor,
který bude obsahovat deklarace všech sdílených veřejných funkcí a globálních proměnných z daného
zdrojového souboru. Ve zdrojovém souboru pak budou jejich definice. Dle jmenné konvence se hlavičkový
soubor pojmenovává jako <code>&lt;název zdrojového souboru&gt;.h</code>:</p>
<pre><code class="language-c">// soubor.h
int moje_funkce();
extern int moje_promenna;

// soubor.c
int moje_funkce() {}
int moje_promenna;
</code></pre>
<p>Hlavičkový soubor tak udává tzv. <strong>rozhraní</strong> (<em>interface</em>) odpovídajícího zdrojového souboru –
obsahuje seznam funkcí a proměnných, které jsou sdílené a zbytek programu je může používat.</p>
<p>Ostatní soubory, které chtějí funkce z nějakého zdrojového souboru použít, pak
<a href="c/modularizace/../preprocesor/vkladani_souboru.html">vloží</a> jeho hlavičkový soubor pomocí preprocesoru, aby mohly
používat sdílené funkce a globální proměnné s korektní kontrolou datových typů:</p>
<pre><code class="language-c">// main.c
#include &quot;soubor.h&quot;

int main() {
    moje_funkce();
    int x = moje_promenna;

    return 0;
}
</code></pre>
<p>Pokud dojde ke změně signatury funkce či typu/názvu proměnné, tak stačí změnu udělat v hlavičkovém
(a odpovídajícím zdrojovém) souboru. Všechny ostatní soubory, které danou funkci nebo proměnnou
používají, pak budou okamžitě využívat upravenou deklaraci díky použití <code>#include</code>.</p>
<p>S hlavičkovými soubory jsme již setkali při použití <a href="c/modularizace/../funkce/stdlib.html">standardní knihovny</a>. V
souborech jako je <code>stdio.h</code> se nacházejí deklarace funkcí jako je například <code>printf</code>, jejichž definice
je poté obsažena v objektových souborech standardní knihovny.</p>
<h2><a class="header" href="#obsah-hlavičkového-souboru" id="obsah-hlavičkového-souboru">Obsah hlavičkového souboru</a></h2>
<p>Jelikož hlavičkové soubory jsou určeny k tomu, aby byly využívány (vkládány) v různých zdrojových
souborech, tak se jejich obsah přirozeně může vyskytnout ve více jednotkách překladu. Aby tak nebylo
porušeno <a href="c/modularizace/pouzivani_kodu_z_jinych_souboru.html#pravidlo-jedn%C3%A9-definice">pravidlo jedné definice</a>, je
důležité do hlavičkových souborů dávat <strong>pouze deklarace, a ne definice</strong> funkcí a proměnných!</p>
<p>Pokud byste do hlavičkového souboru dali například definici funkce, a tento soubor by se vyskytnul
ve více jednotkách překladu, tak by linkování selhalo kvůli vícenásobné definici. Pokud byste
přecejenom opravdu chtěli definici nějaké funkce &quot;propašovat&quot; do hlavičkového souboru, můžete před
ní použít klíčové slovo <code>inline</code>:</p>
<pre><code class="language-c">// soubor.h
inline void moje_funkce() { ... }
</code></pre>
<p>Tímto klíčovým slovem slibujete linkeru, že všechny definice funkce s tímto názvem jsou stejné.
Pokud tak linker narazí na definici této funkce vícekrát (což nastane, když tento hlavičkový soubor
bude vložen ve více jednotkách překladu), tak nebude hlásit chybu, ale prostě si jednu z těchto
definicí vybere. Pokud by definice stejné nebyly, může to vést k dost zvláštnímu chování. Pokuste
se tak <code>inline</code> raději nevyužívat.</p>
<blockquote>
<p>U (globálních) proměnných nemá smysl <code>inline</code> používat.</p>
</blockquote>
<p>Kromě deklarací funkcí a proměnných se do hlavičkových souborů také běžně vkládají struktury, které
jsou součástí typů sdílených proměnných či parametrů nebo návratových hodnot sdílených funkcí.</p>
<p>Aby mohly zdrojové soubory používat sdílené struktury i sdílené funkce v
<a href="c/modularizace/pouzivani_kodu_z_jinych_souboru.html#jednopr%C5%AFchodov%C3%BD-p%C5%99eklad">libovolném pořadí</a>, tak obvykle zdrojové
soubory vkládají svůj vlastní hlavičkový soubor:</p>
<pre><code class="language-c">// soubor.h
typedef struct {
    int vek;
} Osoba;

int zpracuj_osobu(Osoba osoba);

// soubor.c
#include &quot;soubor.h&quot;
int zpracuj_osobu(Osoba osoba) { ... }
</code></pre>
<p>Pro použití struktur nebo např.
<a href="c/modularizace/../struktury/struktury.html#vytv%C3%A1%C5%99en%C3%AD-nov%C3%BDch-jmen-pro-datov%C3%A9-typy"><code>typedefů</code></a> z ostatních souborů
je také běžné, že hlavičkové soubory vkládají jiné hlavičkové soubory.</p>
<h2><a class="header" href="#ochrana-vkládání" id="ochrana-vkládání">Ochrana vkládání</a></h2>
<p>U hlavičkových souborů je nutné řešit ještě jednu další věc. Jelikož se běžně používají v kombinaci
s <code>#include</code>, může se stát, že i v rámci jedné jednotky překladu se jeden hlavičkový soubor vloží do
výsledného zdrojového souboru více než jednou. To může způsobovat různé typy problémů:</p>
<ul>
<li>Pokud se budou hlavičkové soubory vkládat navzájem, mohlo by dojít k cyklické závislosti. Například
zde by překlad selhal, protože by se hlavičkové soubory snažili vložit se navzájem donekonečna:
<pre><code class="language-c">// a.h
#include &quot;b.h&quot;

// b.h
#include &quot;a.h&quot;
</code></pre>
</li>
<li>Hlavičkový soubor se zbytečně vícekrát načítá překladačem, což prodlužuje dobu překladu.</li>
<li>Pokud by hlavičkový soubor obsahoval nějakou definici, tak i kdyby byl použit pouze v jedné
jednotce překladu, došlo by k chybě při linkování, protože by definice byla zduplikovaná. </li>
</ul>
<p>Abychom těmto situacím zamezili, tak u hlavičkových souborů budeme používat tzv. <strong>ochranu vkládání</strong>
(<em>include guard</em>). Pomocí ochrany vkládání zajistíme, že jeden hlavičkový soubor se v rámci jedné
jednotky překladu vloží maximálně jednou.</p>
<p>Zamezení vícenásobného vložení můžeme dosáhnout pomocí
<a href="c/modularizace/../preprocesor/makra.html#podm%C3%ADn%C4%9Bn%C3%BD-p%C5%99eklad">podmíněného překladu</a>:</p>
<pre><code class="language-c">// soubor.h
#ifndef SOUBOR_H
#define SOUBOR_H

void moje_funkce();

#endif
</code></pre>
<p>Tohle je nicméně trochu zdlouhavé. Moderní překladače obsahují mnohem jednodušší způsob. Na začátek
hlavičkového souboru stačí vždy vložit řádek <code>#pragma once</code> a dál nemusíte nic řešit:</p>
<pre><code class="language-c">// soubor.h
#pragma once

void moje_funkce();
</code></pre>
<h1><a class="header" href="#knihovny" id="knihovny">Knihovny</a></h1>
<p>Nyní už známe vše potřebné na to, abychom si rozdělili náš vlastní program do libovolného množství
zdrojových souborů. Často také ale budeme chtít používat kód, který už před námi napsal někdo jiný.
Pokud bychom si totiž museli vše psát od nuly, tak bychom se daleko nedostali<sup class='margin-toggle sidenote-number'>1</sup>, respektive trvalo
by nám to dlouho.</p>
<span class='sidenote'><p><sup class='number'>1</sup>I když napsat si nějaký systém &quot;od nuly&quot; je dobrý způsob, jak se
<a href="c/modularizace/../co_dal.html#co-se-d%C3%A1le-nau%C4%8Dit">zlepšit v programování</a>.</p>
</span>
<p>Aby programátoři mohli sdílet svůj kód s ostatními programátory, tak využívají tzv. <strong>knihovny</strong>
(<em>libraries</em>). Knihovna je kód, který řeší nějakou ucelenou funkcionalitu (např.
<a href="https://www.libsdl.org/">vykreslování grafiky</a>, <a href="https://www.freetype.org/">sazbu fontů</a> nebo
<a href="http://zlib.net/">kompresi dat</a>) a obsahuje návod (dokumentaci), jak tento kód používat. Klíčové
vlastnosti knihoven jsou znovupoužitelnost (můžeme je použít v různých programech) a abstrakce
(nemusíme rozumět, jak knihovna funguje, pouze ji využijeme k vyřešení konkrétního problému).</p>
<blockquote>
<p>Knihovna není program – neobsahuje žádnou funkci <code>main</code> a nelze ji ani přímo spustit. V kontextu
jazyka <em>C</em> je knihovna typicky sada funkcí, struktur a globálních proměnných.</p>
</blockquote>
<p>Například pokud bychom programovali hru, můžeme využít knihovny na vykreslení grafiky, na přehrávání
zvuku, na snímání vstupu z klávesnice nebo myši atd. Náš kód se pak může zabývat zejména logikou hry
a nemusí tolik řešit problémy, které již vyřešila spousta programátorů před námi.</p>
<p>Na internetu můžete naleznout <a href="https://github.com/kozross/awesome-c">tisice různých knihoven</a>,
které řeší rozlišné problémy.</p>
<h2><a class="header" href="#sdílení-knihoven" id="sdílení-knihoven">Sdílení knihoven</a></h2>
<p>Teoreticky bychom mohli knihovny používat prostě tak, že si nějakou najdeme na internetu, stáhneme
její hlavičkové a zdrojové soubory k našeho programu a začneme je využívat. I když i tak to lze někdy
udělat, není to obvyklé, protože tento přístup má spoustu nevýhod:</p>
<ul>
<li>Jelikož obvykle nebudeme autory knihovny, kterou chceme použít, tak nemusíme ani být schopní
danou knihovnu přeložit. Potřebuje daná knihovna konkrétní překladač nebo jeho specifické nastavení?
Má závislosti na dalších knihovnách? Přeložit &quot;cizí&quot; knihovnu ze zdrojových souborů nemusí být
zdaleka přímočaré.</li>
<li>Pokud dojde k vydání nové verze knihovny, která může přinášet opravy chyb a novou funkcionalitu,
museli bychom (kromě potenciální úpravy našeho kódu) také překopírovat nebo správně upravit nové a
změněné soubory knihovny, což by bylo náročné a náchylné na chyby.</li>
<li>Zdrojový kód knihoven není vždy zveřejněn, například aby si jejich autoři uchránili duševní
vlastnictví. Často se tak setkáme se situací, že máme k dispozici pouze objektový kód (např. <code>.so</code>
nebo <code>.dll</code>) a nemůžeme tak získat zdrojové soubory knihovny.</li>
</ul>
<p>Z tohoto důvodu jsou knihovny obvykle sdíleny ve formě objektových souborů (ty obsahují implementaci
funkcí) a odpovídajících hlavičkových souborů (ty obsahují
<a href="c/modularizace/pouzivani_kodu_z_jinych_souboru.html#deklarace-vs-definice">deklarace</a>, aby šlo knihovnu jednoduše
používat).</p>
<h2><a class="header" href="#statické-vs-dynamické-knihovny" id="statické-vs-dynamické-knihovny">Statické vs dynamické knihovny</a></h2>
<p>Předávat překladači desítky či stovky objektových souborů by bylo docela nepraktické, proto se tyto
soubory při distribuci knihovny balí do jednoho či více archivů, které mají standardizovaný formát
a překladače s nimi umí přímo pracovat. Knihovna může být distribuována v jednom ze dvou typů archivů,
které určují to, jak bude daná knihovna &quot;přilinkována&quot; (připojena) k našemu programu:</p>
<ul>
<li>
<p><strong>Dynamická knihovna</strong> (<em>dynamic library</em>) - objektové soubory takovéto knihovny nebudou součástí
našeho programu (tj. nebudou obsaženy ve spustitelném souboru, který bude vytvořen překladačem).
K jejich načtení dojde až &quot;dynamicky&quot; při spuštění programu<sup class='margin-toggle sidenote-number'>2</sup>.</p>
<span class='sidenote'><p><sup class='number'>2</sup>O toto načítání se stará tzv. <a href="https://man7.org/linux/man-pages/man8/ld.so.8.html">dynamický linker</a>.</p>
</span>
<p>Výhody tohoto přístupu jsou, že bude mít náš spustitelný soubor menší velikost, a to jak na disku,
tak v operační paměti. Operační systém totiž dokáže jednu dynamickou knihovnu sdílet mezi více
programy najednou. Dynamickou knihovnu také půjde aktualizovat bez nutnosti překládat znovu náš
program a můžeme také při spuštění programu knihovnu
<a href="https://stackoverflow.com/questions/426230/what-is-the-ld-preload-trick">nahradit jinou implementací</a>.</p>
<p>Nevýhodou je, že při spuštění našeho programu musíme zajistit, že knihovna bude na daném systému
k dispozici (pokud by nebyla nalezena, tak program nepůjde spustit). To může způsobovat problémy
zejména při distribuci našeho programu na jiné počítače. Kvůli tomu, že se knihovna načítá
dynamicky, také může v určitých případech být její použití méně efektivní než v případě statické
knihovny.</p>
<p>Archivy s objektovými soubory dynamických knihoven mají příponu <code>.so</code>.</p>
</li>
<li>
<p><strong>Statická knihovna</strong> (<em>static library</em>) - objektové soubory takovéto knihovny budou přímo přibaleny
k našemu programu (jako bychom je přímo jeden po druhém předali překladači).</p>
<p>Výhody tohoto přístupu jsou, že náš program bude &quot;samostatný&quot; – knihovnu bude obsahovat uvnitř
svého spustitelného souboru, takže nebude nutné ji mít dostupnou na cílovém systému (narozdíl
od dynamické knihovny).</p>
<p>Nevýhodou je, že výsledný spustitelný soubor bude větší a knihovnu nepůjde aktualizovat bez
opětovného překladu celého programu.</p>
<p>Archivy s objektovými soubory statických knihoven mají příponu <code>.a</code>.</p>
</li>
</ul>
<blockquote>
<p>Názvy přípon statických a dynamických knihoven závisí na operačním systému. Například na Windows
se můžete setkat s příponami <code>.lib</code> pro statické knihovny a <code>.dll</code> pro dynamické knihovny.</p>
</blockquote>
<h2><a class="header" href="#použití-knihoven-s-gcc" id="použití-knihoven-s-gcc">Použití knihoven s <code>gcc</code></a></h2>
<p>Nyní si ukážeme, jak říct překladači <code>gcc</code>, aby připojil nějakou knihovnu k našemu programu. Pro to
musíme mít k dispozici archiv s objektovými soubory knihovny (s příponou <code>.a</code> nebo <code>.so</code>, v
závislosti na typu knihovny) a obvykle také i adresář s hlavičkovými soubory knihovny.</p>
<p>Nejprve si ukážeme, jak překladači předat cestu k hlavičkovým souborům knihovny. Ty obvykle nebudou
součástí našich zdrojových kódů, ale budou nainstalovány v nějakém systémovém adresáři (jako tomu je
např. u <code>stdio.h</code>). Budeme je tedy chtít <a href="c/modularizace/../preprocesor/vkladani_souboru.html">vkládat</a> pomocí syntaxe
<code>#include &lt;&gt;</code>. Překladači můžeme předat dodatečné adresáře, ve kterých má hledat (hlavičkové) soubory
pro vkládání, pomocí přepínače <code>-I</code>. Pokud bychom tak měli hlavičkové soubory knihovny např. v
adresáři <code>/usr/foo/include</code>, tak překladači při překladu předáme přepínač <code>-I/usr/foo/include</code>.</p>
<p>Dále je třeba překladači říct, které archivy s objektovými soubory knihovny má k našemu programu
přilinkovat. K tomu slouží dva přepínače. <code>-L</code> udává adresář, ve kterém se budou vyhledávat knihovny
a <code>-l</code> poté specifikuje konkrétní knihovnu, která má být přilinkována k našemu programu. Pokud bychom
tak měli například archiv knihovny v souboru <code>/usr/foo/lib/libknihovna.so</code>, tak překladači předáme
parametry<code>-L/usr/foo/lib</code> a <code>-lknihovna</code>. Při použití přepínače <code>-l</code> je třeba si dávat pozor na dvě
věci:</p>
<ul>
<li>Všimněte si, že se použila zkrácená konvence pro pojmenování knihovny. Obecně se knihovny
pojmenovávají <code>lib&lt;název&gt;.so</code> (nebo <code>lib&lt;název&gt;.a</code>) a překladači se poté předává pouze jejich název,
tj. <code>-l&lt;název&gt;</code>.</li>
<li>Přepínač <code>-l</code> se aplikuje na zdrojové/objektové soubory, které byly v příkazové řádce zadány před
ním. Používejte jej tedy až po předání vašich zdrojových souborů:
<pre><code class="language-bash"># správně
$ gcc main.c -lknihovna

# špatně
$ gcc -lknihovna main.c
</code></pre>
</li>
</ul>
<p>Celý příkaz pro připojení knihovny k vašemu programu by tak mohl vypadat např. takto:</p>
<pre><code class="language-bash">$ gcc -o program main.c -L/usr/foo/lib/ -lfoo -I/usr/foo/include
</code></pre>
<h3><a class="header" href="#předání-cesty-k-dynamické-knihovně" id="předání-cesty-k-dynamické-knihovně">Předání cesty k dynamické knihovně</a></h3>
<p>Pokud přeložíte program s dynamickou knihovnou, může se stát, že při jeho spuštění nebude schopen
danou knihovnu najít. V takovém případě při spuštění programu můžete pomocí
<a href="https://cs.wikipedia.org/wiki/Prom%C4%9Bnn%C3%A1_prost%C5%99ed%C3%AD"><strong>proměnné prostředí</strong></a><sup class='margin-toggle sidenote-number'>3</sup>
(<em>environment variable</em>) <code>LD_LIBRARY_PATH</code> předat cestu k adresáři, ve které se daná knihovna nachází:</p>
<span class='sidenote'><p><sup class='number'>3</sup>Proměnné prostředí jsou způsobem, jak předávat parametry programům (podobně jako
například <a href="c/modularizace/../../ruzne/funkce_main.html#vstupn%C3%AD-parametry-funkce-main">parametry příkazového řádku</a>).
V programu si můžete přečíst hodnotu konkrétní proměnné prostředí pomocí funkce
<a href="https://devdocs.io/c/program/getenv"><code>getenv</code></a>.</p>
</span>
<pre><code class="language-bash">$ LD_LIBRARY_PATH=/usr/foo/lib ./program
</code></pre>
<h3><a class="header" href="#zobrazení-vyžadovaných-dynamických-knihoven" id="zobrazení-vyžadovaných-dynamických-knihoven">Zobrazení vyžadovaných dynamických knihoven</a></h3>
<p>Pokud si přeložíte nějaký program a použijete na něj program <code>ldd</code>, dozvíte se, které dynamické
knihovny vyžaduje ke svému běhu. Měli byste mezi nimi naleznout mj. i
<a href="c/modularizace/../funkce/stdlib.html">standardní knihovnu <em>C</em></a> (<code>libc</code>) a dozvědět se tak její umístění na disku:</p>
<pre><code class="language-bash">$ ldd ./program
libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f0d3a328000)
</code></pre>
<blockquote>
<p><a href="c/modularizace/../funkce/stdlib.html">Standardní knihovna jazyka <em>C</em></a> je používána téměř každým programem a i z
tohoto důvodu je obvykle linkována dynamicky, aby její paměť šla sdílet mezi programy.</p>
</blockquote>
<h2><a class="header" href="#vytvoření-knihovny" id="vytvoření-knihovny">Vytvoření knihovny</a></h2>
<p>Pokud byste si chtěli vytvořit vlastní knihovnu, můžete toho jednoduše dosáhnout pomocí <code>gcc</code>. Dejme
tomu, že máte soubory <code>a.c</code> a <code>b.c</code>, které chcete zabalit do knihovny. Nejprve každý zdrojový soubor
přeložíme do objektového souboru<sup class='margin-toggle sidenote-number'>4</sup>:</p>
<span class='sidenote'><p><sup class='number'>4</sup>Parametr <code>-fPIC</code> je nutný při překladu zdrojových souborů, které poté chceme umístit do
knihovny. Více se můžete dozvědět např. <a href="https://stackoverflow.com/a/5311538/1107768">zde</a>.</p>
</span>
<pre><code class="language-bash">$ gcc -c -fPIC a.c
$ gcc -c -fPIC b.c
</code></pre>
<p>Další postup závisí na tom, jaký typ knihovny chceme vytvořit:</p>
<ul>
<li><strong>Vytvoření statické knihovny</strong> - použijeme program <code>ar</code> (archiver):
<pre><code class="language-bash">$ ar rcs libknihovna.a a.o b.o
</code></pre>
</li>
<li><strong>Vytvoření dynamické knihovny</strong> - použijeme program <code>gcc</code> s přepínačem <code>-shared</code>:
<pre><code class="language-bash">$ gcc -shared a.o b.o -o libknihovna.so
</code></pre>
</li>
</ul>
<h1><a class="header" href="#automatizace-překladu" id="automatizace-překladu">Automatizace překladu</a></h1>
<p>Možná vás napadlo, že v případě rozdělení programu do více zdrojových souborů a při použití knihoven
začne být docela namáhavé náš program vůbec přeložit. Musíme přeložit zvlášť každou
<a href="c/modularizace/linker.html#p%C5%99eklad-programu">jednotku překladu</a>, nakonec je všechny slinkovat dohromady
a případně ještě předat potřebné cesty k použitým knihovnám. A toto je třeba po jakékoliv změně v
kódu našeho programu, pokud ji budeme chtít otestovat.</p>
<p>Tento problém se dá řešit různými způsoby, od vytvoření <a href="https://en.wikipedia.org/wiki/Shell_script">shell skriptu</a>,
pomocí kterého můžeme všechny tyto úkony provést pomocí jediného příkazu v terminálu, až po pokročilé
<strong>sestavovací systémy</strong> (<em>build systems</em>), které umí automaticky vyhledávat cesty ke knihovnám a
překládat pouze změněné soubory pro urychlení opakovaných překladů programu.</p>
<p>Bohužel neexistuje jednotný standardní sestavovací systém pro programy napsané v <em>C</em>. Různé projekty
či knihovny tak používají různé sestavovací systémy, což může někdy představovat problém při jejich
integraci do našich programů. Sestavovací systémy se navíc obvykle nastavují pomocí konfiguračních
souborů, které jsou psány v proprietárních jazycích, které se musíte naučit a pochopit, abyste daný
sestavovací systém mohli používat. Situaci nepomáhá ani to, že se od sebe jednotlivé systémy značně
liší a bývají velmi komplikované. </p>
<h2><a class="header" href="#a-hrefhttpsenwikipediaorgwikimake_softwaremakea" id="a-hrefhttpsenwikipediaorgwikimake_softwaremakea"><a href="https://en.wikipedia.org/wiki/Make_(software)"><code>make</code></a></a></h2>
<p>Asi stále nejpoužívanějším sestavovacím systémem je <code>make</code>, který existuje již od roku 1976. Pro jeho
použití musíte vytvořit soubor <code>Makefile</code>, ve kterém popíšete, jak se má váš program přeložit, a poté
spustíte program <code>make</code>, který jej dle konfiguračního souboru přeloží.</p>
<p>Návod pro vytvoření konfiguračního souboru <code>Makefile</code> a použití <code>make</code> naleznete například
<a href="https://www.itnetwork.cz/cecko/linux/tutorial-c-linux-makefile">zde</a>.</p>
<h2><a class="header" href="#cmake" id="cmake"><code>CMake</code></a></h2>
<p>Poněkud modernější alternativou je <a href="https://cmake.org/"><code>CMake</code></a>. Jedná se o tzv. meta systém, ve
skutečnosti totiž neřídí překlad vašeho programu, ale pouze generuje potřebné soubory pro nějaký
jiný sestavovací systém, který váš program teprve přeloží. Výhodou pak je, že z jednoho <code>CMake</code>
konfiguračního souboru tak můžete vygenerovat např. <code>Makefile</code> pro přeložení na Linuxu anebo jiné
konfigurační soubory pro přeložení stejného programu pod Windows.</p>
<p>Další výhodou <code>CMake</code> je, že některá vývojová prostředí (např.
<a href="https://code.visualstudio.com/">Visual Studio Code</a> nebo <a href="https://www.jetbrains.com/clion/">CLion</a>)
mu rozumí a dokáží díky němu usnadnit analýzu a ladění vašeho programu. </p>
<h3><a class="header" href="#instalace" id="instalace">Instalace</a></h3>
<p><code>CMake</code> můžete na Ubuntu nainstalovat následujícím příkazem v terminálu:</p>
<pre><code class="language-bash">$ sudo apt install cmake
</code></pre>
<h3><a class="header" href="#použití" id="použití">Použití</a></h3>
<p>Pro použití <code>CMake</code> musíte vytvořit konfigurační soubor <code>CMakeLists.txt</code>, ve kterém popíšete jednotlivé
zdrojové soubory vašeho programu, a také zadáte knihovny, které chcete k vašemu programu připojit.
Vzorový soubor <code>CMakeLists.txt</code> může vypadat např. takto:</p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.4)

# Název projektu
project(hra)

# Přidání přepínačů překladače
set(CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -fsanitize=address&quot;)

# Vyhledání knihovny SDL
find_package(SDL2)

# Vytvoření programu s názvem `hra`
# Program se bude skládat ze dvou zadaných zdrojových souborů (jednotek překladu)
add_executable(hra hra.c grafika.c)

# Přidání adresářů s hlavičkovými soubory k programu (obdoba -I)
target_include_directories(hra PRIVATE ${SDL2_INCLUDE_DIRS})

# Přilinkování knihoven k programu (obdoba -l)
target_link_libraries(hra ${SDL2_LIBRARIES} m)
</code></pre>
<p>Jakmile tento soubor vytvoříte, musíte pomocí příkazu <code>cmake</code> vytvořit <code>Makefile</code>:</p>
<pre><code class="language-bash">$ mkdir build
$ cd build
$ cmake ..
</code></pre>
<p>a poté pomocí <code>make</code> program finálně přeložit:</p>
<pre><code class="language-bash">$ make
</code></pre>
<p>Dobrá zpráva je, že pokud používáte kompatibilní vývojové prostředí, tak tyto úkony typicky provádí
za vás a vám tak stačí správně nastavit soubor <code>CMakeLists.txt</code>.</p>
<p>Návod k použití <code>CMake</code> naleznete například <a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">zde</a>.</p>
<h3><a class="header" href="#použití-ve-visual-studio-code" id="použití-ve-visual-studio-code">Použití ve Visual Studio Code</a></h3>
<p>Pokud chcete spustit či ladit <code>CMake</code> projekt ve VSCode, tak proveďte tyto kroky:</p>
<ol>
<li>Nainstalujte si <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools">toto</a> rozšíření do VSCode</li>
<li>Otevřete ve VSCode složku, která bude obsahovat soubor <code>CMakeLists.txt</code></li>
<li>Spusťte program pomocí <code>Ctrl + F5</code></li>
</ol>
<h1><a class="header" href="#Úlohy" id="Úlohy">Úlohy</a></h1>
<p>V této sekci si ukážeme několik jednoduchých aplikovaných přístupů a knihoven, které můžete použít
například na:</p>
<ul>
<li>Práci s obrázky pomocí formátu <a href="c/aplikovane_ulohy/tga.html">TGA</a>.</li>
<li>Práci s animacemi pomocí formátu <a href="c/aplikovane_ulohy/gif.html">GIF</a>.</li>
<li>Tvorbě interaktivních aplikací a her pomocí knihovny <a href="c/aplikovane_ulohy/sdl.html">SDL</a>.</li>
<li>Simulaci fyzikálních procesů pomocí knihovny <a href="c/aplikovane_ulohy/chipmunk.html">Chipmunk</a>.</li>
</ul>
<h1><a class="header" href="#tga" id="tga">TGA</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Truevision_TGA">TGA</a> je formát pro ukládání rastrových obrázků na
disk. Slouží tedy ke stejnému účelu jako známější formáty <code>JPEG</code> nebo <code>PNG</code>, ale oproti nim je
mnohem jednodušší. Díky tomu můžeme načíst i zapsat <code>TGA</code> soubor pomocí několika řádků kódu, zatímco
např. u <code>JPEG</code> nebo <code>PNG</code> bychom potřebovali buď použít již existující knihovnu anebo naimplementovat
jejich relativně komplikované standardy, které čítají stovky stránek.</p>
<h2><a class="header" href="#hlavička-tga" id="hlavička-tga">Hlavička <code>TGA</code></a></h2>
<p>Soubory ve formátu <code>TGA</code> obsahují na svém začátku tzv. <strong>hlavičku</strong> (<em>header</em>), která obsahuje informace
popisující daný obrázek. Tyto informace jsou reprezentovány byty, které jsou umístěny na pevně
daných pozicích. Zde je seznam jednotlivých částí hlavičky TGA:</p>
<table><thead><tr><th align="center">Název</th><th align="center">Pozice prvního bytu</th><th align="center">Počet bytů</th></tr></thead><tbody>
<tr><td align="center">ID</td><td align="center">0</td><td align="center">1</td></tr>
<tr><td align="center">Typ barevné mapy</td><td align="center">1</td><td align="center">1</td></tr>
<tr><td align="center"><strong>Typ obrázku</strong></td><td align="center">2</td><td align="center">1</td></tr>
<tr><td align="center">Barevná mapa</td><td align="center">3</td><td align="center">5</td></tr>
<tr><td align="center"><strong>Počátek X</strong></td><td align="center">8</td><td align="center">2</td></tr>
<tr><td align="center"><strong>Počátek Y</strong></td><td align="center">10</td><td align="center">2</td></tr>
<tr><td align="center"><strong>Šířka</strong></td><td align="center">12</td><td align="center">2</td></tr>
<tr><td align="center"><strong>Výška</strong></td><td align="center">14</td><td align="center">2</td></tr>
<tr><td align="center"><strong>Barevná hloubka</strong></td><td align="center">16</td><td align="center">1</td></tr>
<tr><td align="center">Popisovač</td><td align="center">17</td><td align="center">1</td></tr>
</tbody></table>
<p>Tato tabulka udává, jak máme interpretovat jednotlivé byty na začátku <code>TGA</code> souboru. Pokud bychom tedy
například otevřeli <code>TGA</code> soubor a přečteli si jeho 12. a 13. byte, tak se dozvíme šířku tohoto obrázku. 
Nás budou zajímat zejména tučně vyznačené části:</p>
<ul>
<li><strong>Typ</strong>: Hodnota <code>2</code> udává nekomprimovaný RGB obrázek, hodnota <code>3</code> udává nekomprimovaný
obrázek ve stupních šedi (&quot;černobílý&quot; obrázek). Ostatní platné hodnoty typu obrázku můžete nalézt
např. na <a href="https://en.wikipedia.org/wiki/Truevision_TGA">Wikipedii</a>.</li>
<li><strong>Počátek</strong>: Tato část hlavičky určuje, kde bude počátek souřadnicového systému obrázku. Jinak
řečeno, pokud do obrázku zapíšete pixel na pozici <code>(0, 0)</code>, tak se objeví na pozici počátku. Pokud
použijete počátek <code>(0, 0)</code>, tak tato pozice bude v levém dolním rohu obrázku. Počátek je rozdělený
do souřadnic <code>x</code> a <code>y</code>, obě dvě zabírají dva byty.</li>
<li><strong>Rozměry</strong>: Tato část hlavičky určuje rozměry obrázku. Stejně jako u počátku šířka i výška
zabírá dva byty (aby formát podporoval i obrázky s rozměry většími než 255 pixelů).</li>
<li><strong>Barevná hloubka</strong>: Udává, kolik bitů bude zabírat každý pixel obrázku. Pokud použijeme typ obrázku
RGB, měli bychom použít hloubku 24 bitů (8 bitů na každou barevnou složku), pokud použijeme typ
obrázku ve stupních šedi, tak použijeme hloubku 8 bitů.</li>
</ul>
<blockquote>
<p>Při načítání binárních dat ze souborů musíme dávat pozor na to, jestli jsou hodnoty uloženy v
<strong>little-endian</strong> nebo <strong>big-endian</strong> formátu. U <code>TGA</code> je určeno, že musí být v little-endian, což je
zároveň s velkou pravděpodobností i formát, který používá vás počítač, nemusíme tedy provádět žádnou
konverzi. Více o tzv. <strong>endianness</strong> můžete nalézt např. <a href="https://en.wikipedia.org/wiki/Endianness">zde</a>.</p>
</blockquote>
<h2><a class="header" href="#načtení-hlavičky-ze-souboru" id="načtení-hlavičky-ze-souboru">Načtení hlavičky ze souboru</a></h2>
<p>Jednotlivé části z hlavičky bychom mohli načítat byte po bytu, nicméně to by bylo dosti nepraktické.
V případě, že formát, který chceme načíst, má pevně dané rozložení bytů, je mnohem jednodušší
nadefinovat si <a href="c/aplikovane_ulohy/../struktury/struktury.html">strukturu</a>, která bude danému rozložení odpovídat, a poté
celou strukturu načíst ze souboru najednou.</p>
<p>Jednotlivé hodnoty v hlavičce jsou reprezentovány byty bez znaménka. Jelikož tento datový typ v <em>C</em>
má trochu zdlouhavý název, vytvořme si pro něj nejprve nové jméno <code>byte</code>:</p>
<pre><code class="language-c">typedef unsigned char byte;
</code></pre>
<p>Nyní si vytvořme strukturu, která bude reprezentovat <code>TGA</code> hlavičku. Jednotlivé atributy struktury
musí přesně odpovídat hodnotám v hlavičce a musí být také uvedeny ve stejném pořadí:</p>
<pre><code class="language-c">typedef struct {
    byte id_length;
    byte color_map_type;
    byte image_type;
    byte color_map[5];
    byte x_origin[2];
    byte y_origin[2];
    byte width[2];
    byte height[2];
    byte depth;
    byte descriptor;
} TGAHeader;
</code></pre>
<blockquote>
<p>Možná vám přijde zvláštní, proč např. šířku definujeme jako pole dvou bytů namísto použití
&quot;dvou-bajtového celého čísla&quot;, tedy datového typu <code>short</code>. Děláme to, aby do této struktury překladač
nevložil žádné <a href="c/aplikovane_ulohy/../struktury/struktury.html#reprezentace-struktury-v-pam%C4%9Bti">mezery</a>. Pokud by je tam
vložil, tak by naše struktura v paměti už neodpovídala hlavičce <code>TGA</code> v souboru a četli bychom tak
neplatné hodnoty. Když použijeme pro všechny atributy datový typ s velikostí 1 byte, tak překladač
žádné mezery vkládat nebude.</p>
<p>Alternativním řešením by bylo říct překladači, ať do dané struktury žádné mezery
<a href="https://stackoverflow.com/a/40642888/1107768">nevkládá</a>.</p>
</blockquote>
<p>Nyní už stačí pouze otevřít nějaký <code>TGA</code> soubor (např. <a href="c/aplikovane_ulohy/../../static/img/carmack.tga">tento</a>),
<a href="c/aplikovane_ulohy/../soubory/cteni_ze_souboru.html">načíst</a> z něj počet bytů odpovídající naší struktuře
a poté si z ní můžeme přečíst informace o daném obrázku:</p>
<pre><code class="language-c">FILE* file = fopen(&quot;carmack.tga&quot;, &quot;rb&quot;);
assert(file);

TGAHeader header = {};
assert(fread(header, sizeof(TGAHeader), 1, file) == 1);

printf(&quot;Image type: %d, pixel depth: %d\n&quot;, header.image_type, header.depth);
</code></pre>
<p>Pokud budeme chtít pracovat s hodnotami rozměrů či počátku, musíme je nejprve převést z pole bytů
na celé číslo. Toho můžeme dosáhnout pomocí funkce <a href="https://devdocs.io/c/string/byte/memcpy"><code>memcpy</code></a>:</p>
<pre><code class="language-c">int width = 0;
int height = 0;

memcpy(&amp;width, header-&gt;width, 2);
memcpy(&amp;height, header-&gt;height, 2);
</code></pre>
<h2><a class="header" href="#načtení-pixelů-ze-souboru" id="načtení-pixelů-ze-souboru">Načtení pixelů ze souboru</a></h2>
<p>Jakmile jsme načetli hlavičku, můžeme načíst ze souboru i samotné pixely. Ty jsou umístěny v souboru
hned za hlavičkou. Každý pixel má odpovídající počet bytů podle typu obrázku (u RGB obrázků 3 byty<sup class='margin-toggle sidenote-number'>1</sup>,
u obrázků ve stupních šedi 1 byte) a počet pixelů je dán rozměry obrázku (<code>šířka * výška</code>).</p>
<span class='sidenote'><p><sup class='number'>1</sup>V <code>TGA</code> jsou jednotlivé barevné složky uložené v pořadí <code>blue</code>, <code>green</code>, <code>red</code>. Jedná se tedy
vlastně o formát BGR.</p>
</span>
<p>Můžeme si tak vytvořit pole pro pixely a načíst je z obrázku. Pro RGB obrázky by načtení pixelů
mohlo vypadat např. takto: </p>
<pre><code class="language-c">typedef struct {
    byte blue;
    byte green;
    byte red;
} Pixel;

Pixel* load_pixels(TGAHeader header, FILE* file) {
    int width = 0;
    int height = 0;
    
    memcpy(&amp;width, header.width, 2);
    memcpy(&amp;height, header.height, 2);

    Pixel* pixels = (Pixel*) malloc(sizeof(Pixel) * width * height);
    assert(fread(pixels, sizeof(Pixel) * width * height, 1, file) == 1);
    return pixels;
}
</code></pre>
<h2><a class="header" href="#zapsání-tga-do-souboru" id="zapsání-tga-do-souboru">Zapsání <code>TGA</code> do souboru</a></h2>
<p>Pokud byste chtěli <code>TGA</code> obrázek naopak do souboru zapsat, tak musíte vytvořit hlavičku a nastavit
do ní odpovídající hodnoty. Hlavičku poté musíte zapsat binárně do souboru a hned za ní zapsat
všechny pixely obrázku, řádek po řádku.</p>
<h1><a class="header" href="#gif" id="gif">GIF</a></h1>
<p><a href="https://en.wikipedia.org/wiki/GIF">GIF</a> je velmi populární formát pro sdílení animací. <code>GIF</code> animace
se skládá z jednoho nebo více tzv. <strong>snímků</strong> (<em>frames</em>), které mají určenou délku, po kterou se mají
zobrazit. Při přehrání animace se pak jednotlivé snímky zobrazují postupně jeden za druhým, což
vytváří dojem animace.</p>
<p>Pořád se jedná o relativně jednoduchý formát, nicméně je už trošku složitější než např. <a href="c/aplikovane_ulohy/tga.html">TGA</a>,
protože používá kompresi a pixely nejsou uloženy v souboru přímo, místo toho je každý pixel reprezentován
indexem do tabulky (palety) předpřipravených barev.</p>
<p>Pro vytvoření <code>GIF</code> animace tak použijeme kód, který už pro nás připravil někdo jiný. Konkrétně se
bude jednat o <a href="https://github.com/lecram/gifenc">knihovnu <code>gifenc</code></a><sup class='margin-toggle sidenote-number'>1</sup>. Stáhněte si soubory
<code>gifenc.c</code> a <code>gifenc.h</code> a použijte je při <a href="c/aplikovane_ulohy/../modularizace/pouzivani_kodu_z_jinych_souboru.html">překladu</a>
svého programu.</p>
<span class='sidenote'><p><sup class='number'>1</sup>I když jsme se předtím bavili o tom, že sdílet knihovny ve formě zdrojových kódů není
<a href="c/aplikovane_ulohy/../modularizace/knihovny.html#sd%C3%ADlen%C3%AD-knihoven">úplně běžné</a>, tato knihovna je velmi malá a
jednoduchá a zároveň je open-source, takže zkopírovat její zdrojové kódy do našeho programu je asi
nejjednodušší způsob, jak ji použít.</p>
</span>
<h2><a class="header" href="#vytvoření-gif-animace" id="vytvoření-gif-animace">Vytvoření <code>GIF</code> animace</a></h2>
<p>Pro práci s <code>GIF</code> souborem si nejprve musíme nadefinovat tzv. <strong>paletu</strong> (<em>palette</em>). Paleta není
nic jiného než pole barev, které můžeme v naší animaci používat. Jednotlivým pixelům každého snímku
pak pouze řekneme, jaký index z této palety se má použít pro jejich vykreslení. Například tato paleta
definuje čtyři barvy:</p>
<pre><code class="language-c">typedef unsigned char byte;

byte palette[] = {
    0x00, 0x00, 0x00, /* 0 -&gt; černá   (R=0, G=0, B=0)   */
    0xFF, 0x00, 0x00, /* 1 -&gt; červená (R=255, G=0, B=0) */
    0x00, 0xFF, 0x00, /* 2 -&gt; zelená  (R=0, G=255, B=0) */
    0x00, 0x00, 0xFF, /* 3 -&gt; modrá   (R=0, G=0, B=255) */
};
</code></pre>
<p>Pokud použijeme pro pixel index <code>1</code>, bude vykreslen červenou barvou, protože v této paletě se na
pozici <code>1</code> nachází červená barva.</p>
<p>Jakmile máme nadefinovanou paletu, můžeme použít funkci <code>ge_new_gif</code>, která umožňuje vytvořit nový
<code>GIF</code> soubor. Funkci musíme předat cestu k výstupnímu souboru, jeho rozměry, informace o paletě a o
tom, kolikrát se má animace přehrát<sup class='margin-toggle sidenote-number'>2</sup>:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Pro použití hlavičkového souboru knihovny nezapomeňte na začátku svého programu
<a href="c/aplikovane_ulohy/../preprocesor/vkladani_souboru.html">vložit</a> <a href="c/aplikovane_ulohy/../modularizace/hlavickove_soubory.html">hlavičkový soubor</a>
<code>gifenc.h</code>.</p>
</span>
<pre><code class="language-c">int width = 300;
int height = 300;

ge_GIF* gif = ge_new_gif(
    &quot;output.gif&quot;,
    width,
    height,
    palette,
    2,  /* hloubka palety */
    0   /* opakovat neustále dokola */
);
</code></pre>
<p>Parametr hloubky palety by měl být nastaven na dvojkový logaritmus počtu baret v paletě. V naší
paletě jsou 4 barvy, takže jsme zde předali hodnotu parametru <code>2</code>. Poslední parametr udává, kolikrát
se má animace přehrát. Hodnota <code>0</code> udává, že se má animace opakovat neustále dokola<sup class='margin-toggle sidenote-number'>3</sup>.</p>
<span class='sidenote'><p><sup class='number'>3</sup>Všechny tyto údaje lze vyčíst z <a href="https://github.com/lecram/gifenc/blob/master/README#L25">dokumentace</a>
knihovny.</p>
</span>
<h3><a class="header" href="#zápis-snímků" id="zápis-snímků">Zápis snímků</a></h3>
<p>Když nyní máme vytvořenou animaci, můžeme do ní postupně zapisovat snímky. Zápis probíhá následovně:</p>
<ol>
<li>Do pole uloženého v atributu <code>gif-&gt;frame</code> zapíšeme hodnoty všech pixelů jednoho snímku.
Každá hodnota by měla být indexem odpovídající barvy z námi zvolené palety. Pro adresování použijeme
klasický převod z <a href="c/aplikovane_ulohy/../pole/vicerozmerne_pole.html#indexov%C3%A1n%C3%AD">2D na 1D index</a>.</li>
<li>Zavoláme funkci <code>ge_add_frame</code>, které řekneme, na jak dlouhou dobu se má tento snímek zobrazit.
Tato doba je v setinách vteřiny.</li>
</ol>
<p>Jakmile zapíšeme jeden snímek, můžeme celý proces opakovat pro zápis dalších snímků.</p>
<p>Uhodnete, jakou animaci vygeneruje následující kód<sup class='margin-toggle sidenote-number'>4</sup>?</p>
<span class='sidenote'><p><sup class='number'>4</sup>Pro ověření tipu si program přeložte a podívejte se na výslednou animaci. Zakomentujte řádek
s <code>memset</code> a zkuste odhadnout, jak a proč to změní výslednou animaci.</p>
</span>
<pre><code class="language-c">for (int i = 0; i &lt; 100; i++) {
    memset(gif-&gt;frame, 0, sizeof(uint8_t) * width * height);

    for (int row = 0; row &lt; height; row++) {
        gif-&gt;frame[row * height + i] = ((i * 10) / 30) % 3 + 1;
    }
    for (int col = 0; col &lt; width; col++) {
        gif-&gt;frame[i * height + col] = ((i * 10) / 30) % 3 + 1;
    }

    ge_add_frame(gif, 8);
}
</code></pre>
<details>
<summary>Výsledek animace</summary>
<p><img src="c/aplikovane_ulohy/../../static/img/animace.gif" alt="" /></p>
</details>
<h3><a class="header" href="#dokončení-práce-s-animací" id="dokončení-práce-s-animací">Dokončení práce s animací</a></h3>
<p>Jakmile zapíšeme všechny snímky, které chceme v animaci mít, nesmíme zapomenout animaci uložit do
souboru a uvolnit její paměť pomocí funkce <code>ge_close_gif</code>:</p>
<pre><code class="language-c">ge_close_gif(gif);
</code></pre>
<h2><a class="header" href="#načtení-gif-animace" id="načtení-gif-animace">Načtení <code>GIF</code> animace</a></h2>
<p>Pokud byste naopak chtěli nějakou <code>GIF</code> animaci načíst ze souboru a něco s ní dále provést, můžete
použít knihovnu <a href="https://github.com/lecram/gifdec"><code>gifdec</code></a> od stejného autora, která slouží k
načítání <code>GIF</code> souborů.</p>
<hr />
<p><strong>Cvičení</strong>: Zkuste použít knihovnu <code>gifdef</code> pro převod animace z <code>GIF</code> do <code>TGA</code>:</p>
<ol>
<li>Načtěte <code>GIF</code> animaci z disku.</li>
<li>Projděte všechny snímky animace.</li>
<li>Pro každý snímek převeďte pixely snímku z indexované palety do klasické mřížky pixelů používané
ve formátu <code>TGA</code>.</li>
<li>Zapište každý snímek na disk jako individuální <code>TGA</code> obrázek. Můžete na kraj obrázku vykreslit
informaci o pořadí snímku.</li>
</ol>
<hr />
<h1><a class="header" href="#sdl" id="sdl">SDL</a></h1>
<p><a href="https://www.libsdl.org/"><code>SDL</code></a> je knihovna pro tvorbu interaktivních grafických aplikací a her.
Umožňuje vám vytvářet okna, vykreslovat do nich jednotlivé pixely, obrázky či text, snímat vstup z
myši a klávesnice či třeba přehrávat zvuk. Jedná se tak v podstatě o tzv. <strong>herní engine</strong>, i když
ve srovnání např. s enginy <a href="https://unity.com/">Unity</a> nebo <a href="https://www.unrealengine.com/">Unreal</a>
je tento engine velmi jednoduchý.</p>
<h2><a class="header" href="#instalace-sdl" id="instalace-sdl">Instalace <code>SDL</code></a></h2>
<p>Narozdíl od knihovny, kterou jsme si ukazovali pro vytváření <a href="c/aplikovane_ulohy/gif.html"><code>GIF</code> animací</a>, <code>SDL</code> obsahuje
spoustu zdrojových i hlavičkových souborů, a nebylo by tak ideální ji kopírovat k našemu programu.
Připojíme ji tedy k našemu programu jako klasickou
<a href="c/aplikovane_ulohy/../modularizace/knihovny.html#pou%C5%BEit%C3%AD-knihoven-s-gcc">knihovnu</a> ve formě archivu. Abychom knihovnu
mohli použít, nejprve si ji musíme stáhnout. To můžeme udělat dvěma způsoby:</p>
<ul>
<li><strong>Instalace pomocí správce balíčků</strong> (<em>doporučeno</em>): Jelikož je <code>SDL</code> velmi známá a používaná
knihovna, ve většině distribucí Linuxu není problém ji nainstalovat přímo z balíčkového manažeru.
V Ubuntu to můžete provést pomocí následujícího příkazu v terminálu, který nainstaluje kromě balíčku
se základní funkcionalitou také dva další balíčky nutné pro vykreslování obrázků a textu<sup class='margin-toggle sidenote-number'>1</sup>:
<pre><code class="language-bash">$ sudo apt install libsdl2-dev libsdl2-image-dev libsdl2-ttf-dev
</code></pre>
Výhodou tohoto způsobu je, že knihovna bude nainstalována v systémových cestách, <code>gcc</code> ji tak
bude umět naleznout i bez toho, abychom mu museli zadat explicitní cestu. Nevýhodou je, že verze
knihoven nacházejících se v balíčkových manažerech bývají typicky dosti zastaralé.<span class='sidenote'><p><sup class='number'>1</sup>Pokud by vás zajímalo, které všechny soubory a kam se nainstalovaly, můžete po instalaci balíčků
použít příkaz</p>
<pre><code class="language-bash">$ dpkg -L libsdl2-dev
</code></pre>
</span></li>
</ul>
<ul>
<li><strong>Manuální stažení knihovny</strong>: Knihovnu si můžete také stáhnout manuálně, např. z
<a href="https://www.libsdl.org/download-2.0.php">webu SDL</a>. Některé knihovny můžete naleznout na internetu
už přeložené, nicméně <code>SDL</code> oficiálně pro Linux přeložené knihovní soubory (<code>.so</code>) nenabízí. V tomto
případě tak musíte knihovnu nejenom stáhnout, ale také ručně přeložit, než ji budete moct použít ve
svém programu.</li>
</ul>
<h2><a class="header" href="#přilinkování-knihovny-sdl" id="přilinkování-knihovny-sdl">Přilinkování knihovny <code>SDL</code></a></h2>
<p>Pokud jste nainstalovali <code>SDL</code> pomocí systémových balíčků, stačí při překladu programu přilinkovat
knihovnu <code>SDL2</code>:</p>
<pre><code class="language-bash">$ gcc main.c -lSDL2
</code></pre>
<p>Pokud jste knihovnu překládali manuálně, musíte ještě použít parametry <code>-I</code> pro předání cesty k
hlavičkovým souborům a <code>-L</code> pro předání cesty k adresáři s přeloženou knihovnou, jak již bylo
vysvětleno <a href="c/aplikovane_ulohy/../modularizace/knihovny.html#pou%C5%BEit%C3%AD-knihoven-s-gcc">zde</a>.</p>
<p>Pro práci s obrázky bude dále nutné přilinkovat knihovnu <code>SDL2_image</code> a pro práci s textem knihovnu
<code>SDL2_ttf</code>.</p>
<h2><a class="header" href="#dokumentace" id="dokumentace">Dokumentace</a></h2>
<p>Abyste mohli používat nějakou složitější knihovnu, je nutné se zorientovat v její dokumentaci. V té
naleznete jednak deklarace a popis fungování jednotlivých funkcí, které knihovna nabízí, ale také
různé návody pro to, jak s knihovnou pracovat.</p>
<p>Dokumentaci funkcí <code>SDL</code> naleznete <a href="https://wiki.libsdl.org/APIByCategory">zde</a>, návody pro jeho
použití například <a href="https://www.willusher.io/pages/sdl2/">tady</a>. V předmětu <code>UPR</code> budeme používat
pouze <code>SDL</code> verze 2, které se značně liší od předchozí verze. Dávejte si tedy u návodů na internetu
pozor na to, jestli se týkají správné verze <code>SDL</code>.</p>
<blockquote>
<p><code>SDL</code> je relativně rozsáhlá knihovna a není v silách tohoto textu, abychom ji plně popsali. Proto
níže naleznete pouze velmi stručný &quot;Hello world&quot; a seznam věcí, které vám SDL umožňuje. Zbytek
naleznete v dokumentaci a návodech na internetu.</p>
</blockquote>
<h2><a class="header" href="#sdl-hello-world" id="sdl-hello-world"><code>SDL</code> hello world</a></h2>
<p>Abychom něco vykreslili, tak jako první věc musíme nainicializovat SDL a vytvořit okno<sup class='margin-toggle sidenote-number'>2</sup>:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Pro zpřehlednění kódu bude v ukázkách níže vynechána kontrola chyb. Celý program i s kontrolou
chyb naleznete na konci této sekce.</p>
</span>
<pre><code class="language-c">#include &lt;SDL2/SDL.h&gt;  // Vložení hlavního hlavičkového souboru SDL
#include &lt;stdbool.h&gt;

int main()
{
    SDL_Init(SDL_INIT_VIDEO);   // Inicializace SDL

    // Vytvoření okna
    SDL_Window* window = SDL_CreateWindow(
        &quot;SDL experiments&quot;,  // Název
        100,                // Souřadnice x
        100,                // Souřadnice y
        800,                // Šířka
        600,                // Výška
        SDL_WINDOW_SHOWN    // Okno se má po vytvoření rovnou zobrazit
    );
</code></pre>
<p>Jakmile máme otevřené okno, můžeme do něj něco začít vykreslovat. K tomu musíme nejprve vytvořit
<code>SDL_Renderer</code>, neboli kreslítko:</p>
<pre><code class="language-c">    // Vytvoření kreslítka
    SDL_Renderer* renderer = SDL_CreateRenderer(
        window,
        -1,
        SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC
    );
</code></pre>
<p>S kreslítkem už můžeme něco nakreslit na obrazovku. Musíme vytvořit tzv.
<a href="https://en.wikipedia.org/wiki/Video_game_programming#Game_structure"><strong>herní smyčku</strong></a> (<em>game
loop</em>), která se bude provádět neustále dokola. Ve smyčce nejprve získáme události, které nastaly
(např. došlo ke stisknutí klávesy nebo pohybu myši), poté je zpracujeme, vykreslíme nový obsah
okna a odešleme jej k vykreslení (za použití tzv.
<a href="https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics"><strong>double bufferingu</strong></a>).</p>
<p>Konkrétně budeme vykreslovat jednoduchou posouvající se čáru, dokud uživatel nezavře otevřené okno:</p>
<pre><code class="language-c">    SDL_Event e;
    bool quit = false;
    int pos = 100;

    while (!quit)
    {
        // Dokud jsou k dispozici nějaké události, ukládej je do proměnné `e`
        while (SDL_PollEvent(&amp;e))
        {
            // Pokud došlo k uzavření okna, nastav proměnnou `quit` na `true`
            if (e.type == SDL_QUIT)
            {
                quit = true;
            }
        }

        // Nastavení barvy vykreslování na černou
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);

        // Vykreslení pozadí
        SDL_RenderClear(renderer);

        // Nastavení barvy na červenou
        SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);

        // Vykreslení čáry
        SDL_RenderDrawLine(renderer, pos, pos, pos + 100, pos + 100);

        pos++;

        // Zobrazení vykreslených prvků na obrazovku
        SDL_RenderPresent(renderer);
    }
</code></pre>
<p>A na konci už akorát vše uvolníme:</p>
<pre><code class="language-c">    // Uvolnění prostředků
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();

    return 0;
}
</code></pre>
<blockquote>
<p>Pokud spustíte program využívající <code>SDL</code> s Address sanitizerem, může se stát, že vám sanitizer
zobrazí nějakou <a href="c/aplikovane_ulohy/../../caste_chyby/pametove_chyby.html#memory-leak">neuvolněnou paměť</a>. Pokud zdroj
alokace nepochází z vašeho kódu, můžete tyto chyby ignorovat.</p>
</blockquote>
<details>
<summary>Celý kód i s ošetřením chyb</summary>
<pre><code class="language-c">#include &lt;SDL2/SDL.h&gt;
#include &lt;stdbool.h&gt;

int main()
{
    if (SDL_Init(SDL_INIT_VIDEO)) {
        fprintf(stderr, &quot;SDL_Init Error: %s\n&quot;, SDL_GetError());
        return 1;
    }
    SDL_Window* window = SDL_CreateWindow(&quot;SDL experiments&quot;, 100, 100, 800, 600, SDL_WINDOW_SHOWN);
    if (!window) {
        fprintf(stderr, &quot;SDL_CreateWindow Error: %s\n&quot;, SDL_GetError());
        SDL_Quit();
        return 1;
    }

    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
    if (!renderer) {
        SDL_DestroyWindow(window);
        fprintf(stderr, &quot;SDL_CreateRenderer Error: %s&quot;, SDL_GetError());
        SDL_Quit();
        return 1;
    }

    SDL_Event e;
    bool quit = false;
    int pos = 100;

    while (!quit)
    {
        while (SDL_PollEvent(&amp;e))
        {
            if (e.type == SDL_QUIT)
            {
                quit = true;
            }
        }
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255); // Nastavení barvy na černou
        SDL_RenderClear(renderer);                      // Vykreslení pozadí

        SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255); // Nastavení barvy na červenou
        SDL_RenderDrawLine(renderer, pos, pos, pos + 100, pos + 100); // Vykreslení čáry

        pos++;

        SDL_RenderPresent(renderer);  // Prezentace kreslítka
    }

    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();

    return 0;
}
</code></pre>
</details>
<h2><a class="header" href="#co-lze-dělat-pomocí-sdl" id="co-lze-dělat-pomocí-sdl">Co lze dělat pomocí <code>SDL</code>?</a></h2>
<p>Knihovna <code>SDL</code> nabízí spoustu funkcionality k tvorbě interaktivních aplikací a her. Můžete s ní
například:</p>
<ul>
<li><a href="https://wiki.libsdl.org/CategoryRender">Vykreslovat</a> body, čáry či obdélníky.</li>
<li>Reprezentovat <a href="https://wiki.libsdl.org/CategoryRect">obdélníky</a> a počítat jejich průniky (např.
pro detekci kolizí herních objektů).</li>
<li><a href="https://wiki.libsdl.org/CategoryEvents">Reagovat</a> na vstup uživatele, ať už z klávesnice nebo z myši.</li>
<li>Načítat a vykreslovat <a href="https://www.libsdl.org/projects/SDL_image/docs/SDL_image_frame.html">obrázky</a>.</li>
<li>Načítat a vykreslovat <a href="https://www.libsdl.org/projects/SDL_ttf/docs/SDL_ttf_frame.html">text</a>.</li>
<li>Přehrávat <a href="https://wiki.libsdl.org/CategoryAudio">zvuk</a>.</li>
</ul>
<h1><a class="header" href="#chipmunk" id="chipmunk">Chipmunk</a></h1>
<p>Při tvorbě interaktivních grafických aplikací nebo her můžeme chtít simulovat pohyb objektů tak, aby
dodržoval fyzikální zákony (působení gravitace, tření a kolize objektů, pohyb lana atd.). K tomu
můžeme použít nějakou knihovnu na simulaci fyziky. <a href="https://chipmunk-physics.net"><code>Chipmunk</code></a> je
knihovna pro simulování jednoduchých fyzikálních procesů ve 2D prostoru.
<a href="https://www.youtube.com/watch?v=K84I4qqU8wg">Zde</a> se můžete podívat, co všechno se s takovou
knihovnou dá udělat.</p>
<p>Možná znáte hry jako <a href="https://youtu.be/aiiQ8btusrs?t=399">Angry Birds</a> nebo
<a href="https://youtu.be/3bdBToxbGqg?t=212">Fruit Ninja</a>. Podobné typy her by se bez nějaké knihovny pro
simulaci fyziky neobešly.</p>
<h2><a class="header" href="#instalace-1" id="instalace-1">Instalace</a></h2>
<p>Knihovna Chipmunk nenabízí distribuci již přeložených objektových souborů, musíme tedy její zdrojové
soubory přidat k našemu projektu a přeložit je ručně.</p>
<p>Stáhněte si poslední verzi <a href="https://chipmunk-physics.net/release/ChipmunkLatest.tgz">zdrojových kódů knihovny</a>
z webu <a href="https://chipmunk-physics.net/downloads.php">Chipmunku</a>, rozbalte je a výslednou složku
přejmenujte z <code>Chipmunk-X.Y.Z</code> na <code>Chipmunk</code>.</p>
<p>Dále můžete knihovnu přidat ke svému <code>CMake</code> projektu pomocí následující <code>CMakeLists.txt</code> souboru:</p>
<details>
<summary>Ukázkový CMakeLists.txt soubor pro Chipmunk</summary>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.4)

project(physics)

# Parametr -pthread je nutný při použítí této knihovny
set(CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -pthread&quot;)

# Vložení složky Chipmunk
add_subdirectory(Chipmunk)

# Vytvoření programu
add_executable(physics main.c)

# Přidání knihovny k našemu programu
target_include_directories(physics PRIVATE Chipmunk/include/chipmunk)
target_link_libraries(physics chipmunk)
</code></pre>
</details>
<h2><a class="header" href="#chipmunk-hello-world" id="chipmunk-hello-world"><code>Chipmunk</code> hello world</a></h2>
<p>Stejně jako u <a href="c/aplikovane_ulohy/sdl.html"><code>SDL</code></a> není v silách tohoto textu poskytnout kompletního průvodce touto
knihovnou. Pro to můžete použít <a href="https://chipmunk-physics.net/release/ChipmunkLatest-Docs/">manuál</a>
nebo podrobnou <a href="https://chipmunk-physics.net/release/ChipmunkLatest-API-Reference/modules.html">dokumentaci funkcí</a>.</p>
<p>Zde je okomentovaná ukázka &quot;hello-world&quot; příkladu, který simuluje pád sady kostek a vykresluje je
pomocí SDL:</p>
<details>
<summary>Okomentovaný program využívající knihovny Chipmunk a SDL</summary>
<pre><code class="language-c">#include &lt;chipmunk.h&gt;
#include &lt;SDL2/SDL.h&gt;
#include &lt;SDL2/SDL_image.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;

const int WIDTH = 800;
const int HEIGHT = 600;

int main() {
    // Vytvoření SDL okna a kreslítka
    assert(!SDL_Init(SDL_INIT_VIDEO));

    SDL_Window* window = SDL_CreateWindow(&quot;Physics&quot;, 100, 100, WIDTH, HEIGHT, SDL_WINDOW_SHOWN);
    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);

    // Načtení obrázku z disku
    SDL_Texture* image = IMG_LoadTexture(renderer, &quot;wood.jpg&quot;);
    assert(image);

    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);

    // Vytvoření prostoru, ve kterém bude probíhat fyzikální simulace
    cpSpace* space = cpSpaceNew();
    // Nastavení síly gravitace
    cpSpaceSetGravity(space, (cpVect) { .x = 0, .y = -100.0f });

    // Vytvoření země
    cpShape* ground = cpSegmentShapeNew(
        cpSpaceGetStaticBody(space),
        (cpVect) { .x = 0, .y = 10},
        (cpVect) { .x = WIDTH, .y = 10},
        0
    );
    cpShapeSetFriction(ground, 1.0f);    // Nastavení tření země
    cpSpaceAddShape(space, ground);      // Přidání země do světa

    const float mass = 10.0f;            // Váha kostky
    const int dimension = 30;            // Rozměr kostky

    cpShape* boxes[10];                  // Pole kostek
    for (int i = 0; i &lt; 10; i++) {
        // Vytvoření těla kostky, které se bude hýbat
        cpBody* body = cpBodyNew(mass, cpMomentForBox(mass, dimension, dimension));
        // Přidání těla do prostoru
        cpSpaceAddBody(space, body);
        // Nastavení pozice kostky
        cpBodySetPosition(body, (cpVect) {
            .x = 100 + 5 * i,
            .y = 40 + i * (dimension + 10)
        });

        // Vytvoření tvaru kostky, který bude použito pro detekci kolizí
        cpShape* shape = cpBoxShapeNew(body, dimension, dimension, 1);
        // Přidání tvaru do prostoru
        cpSpaceAddShape(space, shape);
        // Nastavení tření kostky
        cpShapeSetFriction(shape, 1.0f);

        boxes[i] = shape;
    }

    Uint64 last = SDL_GetPerformanceCounter();   // Počítání času vykreslování
    float physics_counter = 0.0f;                // Počítání času fyziky
    float timestep = 1.0f / 60.0f;               // Časový krok, o který se bude fyzika posouvat

    bool quit = false;
    while (!quit) {
        SDL_Event event;
        while (SDL_PollEvent(&amp;event)) {
            if (event.type == SDL_QUIT) {
                quit = true;
            }
        }

        Uint64 now = SDL_GetPerformanceCounter();

        // Počet vteřin od poslední iterace herní smyčky
        float delta_time_s = ((float)(now - last) / (float)SDL_GetPerformanceFrequency());
        last = now;

        // Odsimulování času fyziky
        physics_counter += delta_time_s;
        while (physics_counter &gt;= timestep) {
            cpSpaceStep(space, timestep);  // Provedení jednoho časového kroku
            physics_counter -= timestep;
        }

        SDL_RenderClear(renderer);

        for (int i = 0; i &lt; 10; i++) {
            cpShape* shape = boxes[i];
            cpBody* body = cpShapeGetBody(shape);

            cpVect position = cpBodyGetPosition(body);  // Získání pozice kostky
            float angle_radians = cpBodyGetAngle(body); // Získání úhlu kostky (v radiánech)
            float angle_deg = angle_radians * (180 / M_PI); // Převod na stupně

            SDL_Rect rect = {
                .x = position.x - dimension / 2,
                .y = HEIGHT - (position.y + dimension / 2),  // V Chipmunku jde Y nahoru, v SDL dolů, musíme jej vyměnit
                .w = dimension,
                .h = dimension
            };

            SDL_RenderCopyEx(renderer, image, NULL, &amp;rect, -angle_deg, NULL, SDL_FLIP_NONE);
        }

        SDL_RenderPresent(renderer);
    }

    // Uvolnění prostředků
    for (int i = 0; i &lt; 10; i++) {
        cpShape* shape = boxes[i];
        cpBody* body = cpShapeGetBody(shape);

        cpSpaceRemoveShape(space, shape);
        cpSpaceRemoveBody(space, body);
        cpShapeFree(shape);
        cpBodyFree(body);
    }
    cpSpaceRemoveShape(space, ground);
    cpShapeFree(ground);
    cpSpaceFree(space);
    SDL_DestroyTexture(image);
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();

    return 0;
}
</code></pre>
</details>
<p>Ukázka fungování programu:</p>
<p><video src="../../static/video/chipmunk-boxes.webm" controls></video></p>
<p>Tento program spolu s <code>CMakeLists.txt</code> souborem a knihovnou Chipmunk si můžete stáhnout
<a href="c/aplikovane_ulohy/../../static/snippets/physics.zip">zde</a>. Přeložit a spustit ho můžete pomocí následujících příkazů:</p>
<pre><code class="language-bash">$ mkdir build
$ cd build
$ cmake ..
$ make -j
$ cd ..
$ ./build/physics
</code></pre>
<h1><a class="header" href="#co-dál" id="co-dál">Co dál?</a></h1>
<p><em>C</em> je relativně malý jazyk, pokud jste si tedy přečetli předchozí část tohoto textu, tak znáte
většinu důležitých konstrukcí, která jsou v <em>C</em> dostupné. Nicméně neukázali jsme si úplně všechny –
zde je seznam několika vybraných věcí, které byly buď moc pokročilé pro UPR anebo jsme je jednoduše
nepotřebovali použít:</p>
<ul>
<li><a href="https://en.cppreference.com/w/c/variadic"><strong>Variadiacké funkce</strong></a> umožňují přijímat
libovolný počet parametrů (takto funguje například i nám známá funkce
<a href="https://devdocs.io/c/io/fprintf"><code>printf</code></a>).</li>
<li><a href="https://en.cppreference.com/w/c/language/enum"><strong>Enumerace</strong></a> (<em>enumerations</em>) umožňují
seskupit pojmenované konstanty.</li>
<li><a href="https://en.cppreference.com/w/c/language/union"><strong>Sjednocené struktury</strong></a> (<em>unions</em>)
umožňují interpretovat strukturu jako více různých datových typů.</li>
<li><a href="https://en.cppreference.com/w/c/language/bit_field"><strong>Bitová pole</strong></a> (<em>bit fields</em>)
umožňují rozdělit paměť struktury na úrovni jednotlivých bitů. </li>
<li><a href="http://www.cplusplus.com/reference/cwchar/"><strong>Široké znaky</strong></a> (<em>wide chars</em>) a s nimi související
funkce standardní knihovny umožňují používat složitější kódování než ASCII.</li>
<li><a href="https://en.cppreference.com/w/c/numeric/complex"><strong>Komplexní čísla</strong></a> (<em>complex numbers</em>) vám
umožní pracovat s datovými typy reprezentujícími komplexní čísla.</li>
</ul>
<blockquote>
<p>Pokud si chcete ověřit, jak jste na tom se znalostí jazyka <em>C</em>, projděte si tyto
<a href="c/../static/files/deepc.pdf">slidy</a>. Pokud budete umět odpovídat jako blonďatý
kluk, tak znáte základy jazyka <em>C</em>. Pokud budete umět odpovídat jako dívka s růžovými vlasy,
tak už vás v jazyce <em>C</em> téměř nic nepřekvapí.</p>
</blockquote>
<h2><a class="header" href="#co-se-dále-naučit" id="co-se-dále-naučit">Co se dále naučit</a></h2>
<p>Se znalostí samotného jazyka <em>C</em> souvisí i spousta dalších konceptů, se kterými se postupně musíte
seznámit, pokud chcete opravdu dopodrobna pochopit, co přesně se v počítači děje, když spustíte
vámi napsaný program. Poté můžete těchto znalostí využít k tvorbě robustnějších a rychlejších
programů. Na následujících odkazech se můžete dozvědět například:</p>
<ul>
<li>Jak fungují <a href="http://poli.cs.vsb.cz/edu/osy/osnova.html">operační systémy</a>.
<ul>
<li>Nebo dokonce jak si nějaký <a href="https://littleosbook.github.io/">napsat od nuly</a>.</li>
</ul>
</li>
<li>Jak komunikovat s jinými programi po <a href="http://www.beej.us/guide/bgnet/">síti</a>.</li>
<li>Jak psát programy přímo pomocí <a href="http://poli.cs.vsb.cz/edu/soj/down/soj-skripta.pdf">instrukcí procesoru</a></li>
<li>Jak urychlit provádění programů:
<ul>
<li>Pomocí <a href="https://computing.llnl.gov/tutorials/pthreads/">vláken</a>, které umí využít potenciál
vícejádrových procesorů.</li>
<li>Pomocí <a href="http://www.cs.uu.nl/docs/vakken/magr/2017-2018/files/SIMD%20Tutorial.pdf">vektorových instrukcí</a>,
které umí pracovat s více než jednou hodnotou najednou.</li>
<li>Pomocí pochopení <a href="https://github.com/Kobzol/hardware-effects">architektury procesoru</a>, která
silně ovlivňuje výkon programů.</li>
</ul>
</li>
<li>Jak si napsat vlastní <a href="https://www3.nd.edu/%7Edthain/compilerbook/compilerbook.pdf">překladač</a> či
<a href="http://www.buildyourownlisp.com/chapter1_introduction">programovací jazyk</a>.</li>
<li>Jak si napsat vlastní <a href="https://cstack.github.io/db_tutorial/">databázi</a>.</li>
<li>Jak funguje <a href="http://mrl.cs.vsb.cz/people/fabian/pg1_course.html">počítačová grafika</a>.
<ul>
<li>Můžete si napsat vlastní <a href="https://learnopengl.com/">3D herní engine</a> pomocí OpenGL.</li>
</ul>
</li>
<li>Jak si napsat program pro nějaké vestavěné (<em>embedded</em>) zařízení, například <a href="https://www.arduino.cc/en/Tutorial/BuiltInExamples/Blink">Arduino</a>.</li>
</ul>
<h1><a class="header" href="#různé" id="různé">Různé</a></h1>
<p>Tato sekce obsahuje různá témata a návody, které nezapadají do zbytku textu, ale je dobré o nich
vědět.</p>
<h1><a class="header" href="#rozklad-problému" id="rozklad-problému">Rozklad problému</a></h1>
<p>Často se setkáte s tím, že dostanete k naprogramování úlohu, se kterou si nevíte rady a netušíte ani
jak začít. Například:</p>
<p><code>Načti obrázek z disku, změň jeho velikost, ulož ho do jiného souboru a vykresli jej na obrazovku.</code></p>
<p>Tato úloha vypadá velmi jednoduše, když je zadaná větou (v češtině), ale obzvláště pro začínající
programátory je obtížné převést takovouto úlohu do programovacího jazyka. Obecným pravidlem k usnadnění
řešení složitých úloh je rozdělovat je na menší a jednodušší podúlohy tak dlouho, dokud se nedostaneme
k podúloze, kterou již umíme vyřešit. Poté z těchto malých kousků, které máme vyřešené, zpětně poskládáme
celý program, který vyřeší původní úlohu.</p>
<p>Například zmíněnou úlohu můžeme rozdělit na následující podúlohy: </p>
<ul>
<li>Načti obrázek z disku
<ul>
<li>Otevři soubor se vstupním obrázkem</li>
<li>Načti hlavičku obrázku</li>
<li>Vytvoř paměť pro pixely obrázku
<ul>
<li>Naalokuj dostatek paměti dle hlavičky (šířka x výška)</li>
</ul>
</li>
</ul>
</li>
<li>Změň velikost obrázku
<ul>
<li>Vytvoř obrázek s novým rozměrem</li>
<li>Překopíruj původní obrázek do nového obrázku
<ul>
<li>Projdi všechny pixely nového obrázku
<ul>
<li>Projdi každý řádek</li>
<li>Pro každý řádek projdi každý sloupec</li>
</ul>
</li>
<li>Pro každý pixel spočítej původní pozici pixelu
<ul>
<li>Pro výpočet použij poměr šířky/výšky nového/starého obrázku</li>
</ul>
</li>
<li>Překopíruj pixel ze starého obrázku do nového</li>
</ul>
</li>
<li>Vrať nový obrázek</li>
</ul>
</li>
<li>Zapiš upravený obrázek
<ul>
<li>Otevři soubor k zápisu</li>
<li>Zapiš hlavičku obrázku do souboru</li>
<li>Zapiš pixely obrázku do souboru</li>
</ul>
</li>
<li>Vykresli upravený obrázek
<ul>
<li>Vytvoř okno pro vykreslení obrázku</li>
<li>Překopíruj pixely obrázku do otevřeného okna</li>
<li>Zobraz okno s obrázkem</li>
</ul>
</li>
</ul>
<p>Pomocí tohoto univerzálního postupu se dříve či později dostanete k (pod)úloze, kterou byste již měli umět
vyřešit (např. otevření souboru). Jakmile danou podúlohu vyřešíte, tak budete o krok blíže k řešení
původní složité úlohy.</p>
<p>Tímto způsobem můžeme programy rovnou od začátku začít psát. Například při řešení výše zmíněné úlohy
můžeme začít nadefinováním hlavní logiky programu pomocí volání funkcí, kde každá funkce bude reprezentovat
jednu podúlohu. I když funkce zatím nebudou naprogramované a později se třeba jejich název nebo rozhraní
trochu změní, tak nám toto rozdělení může pomoct přemýšlet nad problémem abstraktněji, zorientovat s
v něm a také získat naději, že se nám úlohu vůbec podaří vyřešit. Stejný princip opět můžeme použít
při implementaci jednotlivých funkcí. Program (či funkci) pak lze přečíst jako větu a je tak jednodušší
pochopit, co má vlastně dělat.</p>
<pre><code class="language-c">int main() {
    // Načti obrázek
    FILE* vstupni_soubor = otevri_soubor(...);
    Img obrazek = nacti_obrazek(vstupni_soubor);

    // Uprav jeho velikost
    Img upraveny_obrazek = uprav_velikost_obrazku(&amp;obrazek);

    // Zapiš obrázek
    FILE* vystupni_soubor = otevri_soubor(...);
    zapis_obrazek(vystupni_soubor, &amp;upraveny_obrazek);

    // Vykresli obrázek
    vykresli_obrazek(&amp;upraveny_obrazek);

    return 0;
}
</code></pre>
<h1><a class="header" href="#vyhodnocování-výrazů" id="vyhodnocování-výrazů">Vyhodnocování výrazů</a></h1>
<p>Abyste pochopili, co se děje, když váš program běží, a uměli ho odladit, tak je důležité, abyste si
uměli myšlenkově &quot;odsimulovat&quot;, co přesně procesor provádí, když vykonává příkazy vašeho programu.
Asi nejlepším nástrojem pro tento účel je použití <a href="ruzne/../prostredi/ladeni.html#krokov%C3%A1n%C3%AD">debuggeru</a>,
pomocí kterého můžete provádět váš program příkaz po příkazu a sledovat, jak se během toho měni
jeho výstup a hodnoty v paměti.</p>
<p>Důležité je zejména vědět, jak fungují příkazy <a href="ruzne/../c/rizeni_toku">řízení toku</a> a jak funguje
vyhodnocování <a href="ruzne/../c/prikazy_vyrazy.html">výrazů</a>. Níže naleznete několik příkladů, které slouží k
demonstraci toho, jak se postupně vyhodnocují výrazy v jazyce <em>C</em>.<sup class='margin-toggle sidenote-number'>1</sup></p>
<span class='sidenote'><p><sup class='number'>1</sup>Procesor ve skutečnosti s největší pravděpodobností nebude výrazy vyhodnocovat přesně tak,
jak je zde ukázáno, ale mnohem efektivněji. Výsledek by však měl být stejný, proto se vyplatí umět
vyhodnocovat výrazy &quot;v hlavě&quot;, abychom si ověřili, že program dělá to, co očekáváme.</p>
</span>
<ul>
<li>Aritmetické <a href="ruzne/../c/datove_typy/celociselne_typy.html">operace</a> a čtení <a href="ruzne/../c/promenne/promenne.html">proměnných</a>
<pre><code class="language-c">int a = 5;
int b = 8;
int c = 6;

// Níže je rozepsané vyhodnocení výrazu `c = (a + b) * c + 1 - b`
c = (a + b) * c + 1 - b;

// c = (a + b) * c + 1 - b
// c = (5 + b) * c + 1 - b
// c = (5 + 8) * c + 1 - b
// c = (13) * c + 1 - b
// c = 13 * c + 1 - b
// c = 13 * 6 + 1 - b
// c = 78 + 1 - b
// c = 79 - b
// c = 79 - 8
// c = 71

// Hodnota proměnné c je nyní 71
</code></pre>
</li>
<li>Volání <a href="ruzne/../c/funkce/funkce.html">funkcí</a>
<pre><code class="language-c">int foo(int a, int b) {
    int c = a + b;
    return c * 2 + b;
}
int main() {
    int x = 8;
    int y = foo(x, 5 + 2);
    // y = foo(x, 5 + 2)
    // y = foo(8, 5 + 2)
    // y = foo(8, 7)
    // y = 37

    int z = foo(foo(x, x), foo(y, 1) + 8);
    // z = foo(foo(x, x), foo(y, 1) + 8)
    // z = foo(foo(8, x), foo(y, 1) + 8)
    // z = foo(foo(8, 8), foo(y, 1) + 8)
    // z = foo(40, foo(y, 1) + 8)
    // z = foo(40, foo(37, 1) + 8)
    // z = foo(40, 77 + 8)
    // z = foo(40, 85)
    // z = foo(40, 85)
    // z = 335

    return 0;
}
</code></pre>
</li>
</ul>
<h1><a class="header" href="#funkce-main" id="funkce-main">Funkce <code>main</code></a></h1>
<p>Funkce <code>main</code> je speciální funkce, která se začne vykonávat při spuštění programu. Může vypadat
například takto:</p>
<pre><code class="language-c">int main() {
    return 0;
}
</code></pre>
<p>Proč tato funkce vrací číslo (<code>int</code>) a proč se obvykle z této funkce vrací hodnota <code>0</code>? Operační
systémy mají zavedenou konvenci, že každý spuštěný program by měl po svém vykonání vrátit číselnou
hodnotu, která systému napoví, jestli program proběhl úspěšně, nebo ne. Díky tomu pak lze relativně
jednoduše detekovat, jestli v programu nastala chyba, a případně na ni nějak zareagovat (z Windows
možná znáte dialog &quot;Program neproběhl správně…&quot;).</p>
<p>Číslo, které vrátíte z funkce <code>main</code>, se použije právě jako návratová hodnota programu pro operační
systém. Význam navrácených čísel není nijak standardizován, jediné, co platí obecně, je, že hodnota
<code>0</code> značí úspěch a jakákoliv jiná hodnota značí neúspěch. Proto tedy za normálních okolností z
<code>main</code>u vracíme <code>0</code>, abychom dali systému najevo, že program proběhl úspěšně.</p>
<h3><a class="header" href="#vstupní-parametry-funkce-main" id="vstupní-parametry-funkce-main">Vstupní parametry funkce <code>main</code></a></h3>
<p>Funkce <code>main</code> je speciální ve více ohledech. Kromě formy bez parametrů, kterou jste viděli výše,
můžete <code>main</code> použít také takto, s dvěma parametry:</p>
<pre><code class="language-c">int main(int argc, char** argv) {
    return 0;
}
</code></pre>
<p>První parametr je typu <code>int</code> a druhý parametr typu <a href="ruzne/../c/prace_s_pameti/ukazatele.html">ukazatel</a> na
<a href="ruzne/../c/text/retezce.html">řetězec</a>. Do těchto parametrů se uloží hodnoty zadané při spuštění programu v
terminálu, tzv. <strong>argumenty příkazového řádku</strong> (<em>command line arguments</em>). Parametr <code>argc</code>
(<em>argument count</em>) bude obsahovat počet předaných argumentů a parametr <code>argv</code> obsahuje ukazatel na
první prvek <a href="ruzne/../c/pole/pole.html">pole</a> <em>C</em> <a href="ruzne/../c/text/retezce.html">řetězců</a>, kde každý řetězec bude obsahovat
jeden argument. Prvním argumentem je dle konvence vždy cesta k spustitelnému souboru programu,
který je právě spouštěn, další argumenty se nastaví podle zadaného textu v terminálu (argumenty
jsou oddělené mezerou).</p>
<p>Například, pokud program spustíte takto: <code>./program hello world</code>, tak parametry funkce <code>main</code> budou
mít následující hodnoty:</p>
<ul>
<li><code>argc</code> bude obsahovat celé číslo <code>3</code> </li>
<li><code>argv[0]</code> bude obsahovat řetězec <code>&quot;./program&quot;</code></li>
<li><code>argv[1]</code> bude obsahovat řetězec <code>&quot;hello&quot;</code></li>
<li><code>argv[2]</code> bude obsahovat řetězec <code>&quot;world&quot;</code></li>
</ul>
<h1><a class="header" href="#generování-náhodných-čísel" id="generování-náhodných-čísel">Generování náhodných čísel</a></h1>
<p>Počítače jsou <strong>deterministické</strong> stroje, což znamená, že stejný program vždy na stejný vstup
vrátí stejný výstup. Často ovšem chceme, aby naše programy obsahovaly prvky &quot;náhody&quot;, když chceme
například:</p>
<ul>
<li>Hodit si kostkou v deskové hře</li>
<li>Udělit náhodný počet zranění v rozsahu zbraně</li>
<li>Oživit hráče na náhodné pozici na mapě</li>
</ul>
<p>Počítače samy o sobě opravdovou náhodu vytvořit nemohou, nicméně můžou ji simulovat pomocí tzv.
<strong>pseudo-náhodných generátorů čísel</strong> (<em>pseudo-random number generation</em>).</p>
<p>Vygenerovat (pseudo-)náhodnou sekvenci čísel pomocí deterministických operací můžeme například
následujícím algoritmem:</p>
<ol>
<li>Začneme s číslem <code>S</code>, které se nazývá <strong>počáteční náhodná hodnota</strong> (<em>random seed</em>).</li>
<li>Aplikujeme nějakou matematickou operaci na <code>S</code> a vyjde nám nové číslo <code>N</code>.</li>
<li><code>N</code> použijeme jako vygenerované &quot;náhodné číslo&quot;.</li>
<li>Nastavíme <code>S = N</code>.</li>
<li>Opakujeme postup od bodu 2).</li>
</ol>
<p>Ukázka kódu, který takovýto algoritmus implementuje:</p>
<pre><code class="language-c editable">int S = 5;
int vygeneruj_cislo() {
    int N = S;
    N = (5 * N + 3) % 6323;
    N = (4 * N + 2) % 8127;
    S = N;
    return N;
}
int main() {
    int r1 = vygeneruj_cislo(); // 114
    int r2 = vygeneruj_cislo(); // 2294
    int r3 = vygeneruj_cislo(); // 4348
    int r4 = vygeneruj_cislo(); // 2971
    int r5 = vygeneruj_cislo(); // 723
    return 0;
}
</code></pre>
<p>Takovýto algoritmus bude generovat (nekonečnou) sekvenci čísel, která bude lidem připadat &quot;náhodná&quot;
(bude těžké uhodnout, jaké číslo algoritmus vrátí příště).</p>
<h3><a class="header" href="#volba-počáteční-hodnoty-s" id="volba-počáteční-hodnoty-s">Volba počáteční hodnoty <code>S</code></a></h3>
<p>Určite jste si všimli, že výše zmíněný algoritmus bude pokaždé generovat stejnou sekvenci čísel pro
stejné počáteční <code>S</code>. To se může hodit, chceme-li například mít možnost zpětně přehrát sekvenci
pseudo-náhodných čísel, například pro odladění chyby v programu. Nicméně pokud by sekvence byla pokaždé
stejná, tak o (pseudo-)náhodě nemůže být řeč.</p>
<p>Proto se obvykle hodnota <em>seedu</em> volí tak, aby při každém spuštění programu byla jiná. Přirozenou
volbou pro počáteční hodnotu <code>S</code> je tak například čas<sup class='margin-toggle sidenote-number'>1</sup> při spuštění programu. Lze ale také použít
například pohyby myši nebo stisky kláves, které nedávno na počítači proběhly.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Ve formě <a href="https://en.wikipedia.org/wiki/Unix_time">UNIX časového razítka</a>, tedy počtu vteřin
uběhlých od 1. 1. 1970.</p>
</span>
<h3><a class="header" href="#pseudo-náhodný-generátor-ve-standardní-knihovně-c" id="pseudo-náhodný-generátor-ve-standardní-knihovně-c">Pseudo-náhodný generátor ve standardní knihovně <em>C</em></a></h3>
<p>Při praktickém použití si obvykle nebudete psát generátor pseudo-náhodných sami, ale použijete již
hotové řešení. To nabízí například standardní knihovna <em>C</em> ve formě funkcí <code>srand</code> (nastav hodnotu
<em>seed</em>u) a <code>rand</code> (vygeneruj pseudo-náhodné číslo):</p>
<pre><code class="language-c editable">#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

int main() {
    int cas = (int) time(NULL); // získej současný čas
    srand(cas); // nastav S na současný čas

    int cislo1 = rand(); // pseudo-náhodné číslo z intervalu [0, RAND_MAX]
    int cislo2 = rand() % 100; // z intervalu [0, 99]
    int cislo3 = rand() % 100 + 5; // z intervalu [5, 104]
    float cislo4 = rand() / (float) RAND_MAX; // z intervalu [0.0, 1.0]

    return 0;
}
</code></pre>
<h1><a class="header" href="#parametry-překladače" id="parametry-překladače">Parametry překladače</a></h1>
<p>Překladač <code>gcc</code> obsahuje sadu několika stovek parametrů, pomocí kterých můžeme ovlivnit, jak překlad
programu proběhne. Můžeme například určit, pro jaký procesor se mají vygenerovat instrukce, jakou
variantu jazyka <em>C</em> má překladač očekávat nebo jestli má náš program zoptimalizovat, aby běžel
rychleji.</p>
<blockquote>
<p>Kromě <code>gcc</code> existuje řada dalších překladačů <em>C</em>, například <a href="https://clang.llvm.org/"><code>clang</code></a>.
Nejčastější parametry (jako je např. <code>-O</code>) obvykle fungují ve všech překladačích obdobně, každý
překladač ale obsahuje sadu specifických parametrů, které můžete naleznout v jeho
<a href="https://clang.llvm.org/docs/ClangCommandLineReference.html">dokumentaci</a>.</p>
</blockquote>
<p>Seznam všech parametrů můžete naleznout v
<a href="https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html">dokumentaci <code>gcc</code></a>, zde je uveden seznam
nejužitečnějších parametrů:</p>
<ul>
<li>
<p><strong>Optimalizace</strong>: Existuje spousta parametrů, pomocí kterých můžete ovlivnit, jak překladač převede
váš zdrojový kód na strojové instrukce a jak je zoptimalizuje. Nejzákladnějším parametrem je <code>-O</code>:</p>
<ul>
<li><code>-O0</code> Nebudou použity téměř žádné optimalizace. Toto je implicitní nastavení,
pokud ho nezměníte. Program v tomto stavu lze dobře <a href="ruzne/../prostredi/ladeni.html#krokov%C3%A1n%C3%AD">krokovat</a>,
ale může být dost pomalý.</li>
<li><code>-O1</code> Aplikuje základní optimalizace.</li>
<li><code>-O2</code> Aplikuje nejužitečnější optimalizace. Pokud chcete získat rozumně rychlý program,
doporučujeme použít tento mód. Díky němu může být program třeba až 1000x rychlejší než s <code>-O0</code>.<sup class='margin-toggle sidenote-number'>1</sup><span class='sidenote'><p><sup class='number'>1</sup>Anebo nemusí být rychlejší vůbec, záleží na programu.</p>
</span></li>
<li><code>-O3</code> Aplikuje ještě více optimalizací. Program tak může být ještě rychlejší než s <code>-O2</code>.
Obecně při použití optimalizací však platí, že čím vyšší optimalizační stupeň, tím více hrozí,
že se váš program přestane chovat správně, pokud program obsahuje jakékoliv
<a href="ruzne/../c/promenne/promenne.html#v%C5%BEdy-inicializujte-prom%C4%9Bnn%C3%A9">nedefinované chování</a>. Je tak třeba dávat
pozor na to, aby k tomu nedošlo.</li>
</ul>
<p>Kromě parametru <code>-O</code> lze použít spousty dalších parametrů, které ovlivňují například použití
<a href="ruzne/../c/co_dal.html">vektorových instrukcí</a>.</p>
</li>
<li>
<p><strong>Ladění programu</strong>:
Jak už jste jistě poznali, při použití jazyka <em>C</em> je velmi jednoduché způsobit nějaké nedefinované
chování, například nějakou <a href="ruzne/../caste_chyby/pametove_chyby.html">paměťovou chybou</a>. Aby šlo tyto
chyby detekovat, obsahují překladače tzv. <em>sanitizery</em>. Při použití sanitizeru se do vašeho
programu přidají dodatečné instrukce, které poté při běhu programu kontrolují, jestli nedochází
k nějakému problému. Cenou za tuto kontrolu je pomalejší běh programu (cca 2-5x). Sanitizery tak
raději používejte pouze při vývoji programu.</p>
<p>Existuje více <a href="https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html">typů sanitizerů</a>,
my si ukážeme dva:</p>
<ul>
<li><code>-fsanitize=address</code> Použije tzv. <em>Address Sanitizer</em>, který hlídá paměťové chyby, například
přístup k nevalidní paměti nebo neuvolnění <a href="ruzne/../c/prace_s_pameti/dynamicka_pamet.html">dynamické paměti</a>.
Tento sanitizer je nesmírně užitečný a doporučujeme ho vždy používat při vývoji programů v <em>C</em>.</li>
<li><code>-fsanitize=undefined</code> Použije tzv. <em>Undefined behaviour sanitizer</em>, který hlídá dodatečné
situace, při kterých může dojít k nedefinovanému chování (kromě paměťových chyb).</li>
</ul>
<p>Obecně při ladění programu je taky vhodné vždy použít přepínač <code>-g</code>. Ten způsobí, že překladač
přidá do výsledného spustitelného souboru informace o zdrojovém kódu (ty jinak ve spustitelném
souboru chybí). Díky tomu budou sanitizery schopny zobrazit konkrétní řádek, na kterém vznikl
nějaký problém a také půjde program ladit a krokovat. </p>
</li>
<li>
<p><strong>Analýza kódu</strong>: Kromě sanitizerů, které kontrolují váš program za běhu, lze také spoustu chyb
odhalit již při překladu programu. Bohužel překladač <code>gcc</code> v implicitním módu není moc striktní a
některé vyloženě chybné situace vám promine a program přeloží, i když je již dopředu jasné, že při
běhu pak dojde např. k pádu programu. Abychom tomu předešli, můžeme zapnout při překladu dodatečná
<strong>varování</strong> (<em>warnings</em>), která nás mohou na potenciálně problematické situace upozornit:</p>
<ul>
<li><code>-Wall</code> Zapne sadu několika desítek základních varování.</li>
<li><code>-Wextra</code> Zapne dodatečnou sadu varování.</li>
<li><code>-pedantic</code> Zapne striktní kontrolu toho, že dodržujete předepsaný standard <em>C</em>. V kombinaci
s tímto přepínačem byste také měli explicitně říct, který standard chcete použít. V UPR používáme
standard <em>C99</em>, který lze zadat pomocí <code>-std=c99</code>.</li>
<li><code>-Werror</code> Tento přepínač způsobí, že libovolné varování bude vnímáno jako chyba. Pokud tak
v programu <code>gcc</code> nalezne jakoukoliv situaci, která vytvoří varování, program se nepřeloží.</li>
</ul>
<p>Pokud chcete mít při překladu co největší zpětnou vazbu od překladače a zajistit co největší
&quot;bezpečnost&quot; vašeho programu, doporučujeme používat tuto kombinaci přepínačů:</p>
<pre><code class="language-bash">$ gcc -g -fsanitize=address -Wall -Wextra -pedantic -std=c99
</code></pre>
</li>
</ul>
<h1><a class="header" href="#Úlohy-1" id="Úlohy-1">Úlohy</a></h1>
<p>V této sekci naleznete různé úlohy, které si můžete zkusit naimplementovat, abyste se zlepšili
v programování.</p>
<p>Další úlohy můžete najít také například na těchto odkazech:</p>
<ul>
<li><a href="https://adventofcode.com/2018/events">Advent of Code</a></li>
<li><a href="https://projecteuler.net/archives">Project Euler</a></li>
<li><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=3">Online Judge</a></li>
<li><a href="https://w3resource.com/c-programming-exercises/">W3 C programming exercises</a></li>
</ul>
<h1><a class="header" href="#základy" id="základy">Základy</a></h1>
<h2><a class="header" href="#obvod-a-obsah-obdélníku" id="obvod-a-obsah-obdélníku">Obvod a obsah obdélníku</a></h2>
<p>Program vypočítá a vypíše obvod a obsah obdélníku ze dvou celočíselných velikosti stran \( a \), \( b \) podle známých vzorců.</p>
<div style="display: flex; justify-content: center">
  <svg>
    <rect width=200 height=100 fill=#eee stroke=black />
    <text x=100 y=115 fill=black text-anchor=middle font-style=italic>a</text>
    <text x=210 y=50 fill=black text-anchor=middle font-style=italic>b</text>
  </svg>
  <div>
    $$\begin{aligned}
    o &= 2 \cdot (a + b) \\
    S &= a \cdot b
    \end{aligned}$$
  </div>
</div>
<details>
<summary>Výstup</summary>
<pre><code>a = 200
b = 100
o = 600
S = 20000
</code></pre>
</details>
<h2><a class="header" href="#obsah-vyšrafované-plochy" id="obsah-vyšrafované-plochy">Obsah vyšrafované plochy</a></h2>
<p>Ze zadané délky strany čtverce \( a \) a průměru kružnice \( d \) vypočítáme obsah vyšrafované plochy.
Výpočet budeme provádět pomocí datového typu <code>float</code> s využitím konstanty <code>M_PI</code> z knihovny <code>&lt;math.h&gt;</code>.
Druhou mocninu vypočítáme násobením, ale také pomocí funkce <code>pow</code> .
Při použití matematických funkcí je nutné program <a href="ulohy/../c/modularizace/knihovny.html">linkovat</a> s
knihovnou <code>math</code><sup class='margin-toggle sidenote-number'>10</sup>. Výsledek zapíšeme na výstup na 4 desetinná místa. </p>
<span class='sidenote'><p><sup class='number'>10</sup>Pro překlad s touto knihovnou použijte <code>-lm</code>:</p>
<pre><code class="language-bash">$ gcc obsah.c -o obsah -lm
</code></pre>
</span><div style="display: flex; justify-content: center">
	<svg viewBox="0 0 130 130" width=130 height=130>
		<pattern id="diagonalHatch" patternUnits="userSpaceOnUse" width="4" height="4">
		<path d="M-1,1 l2,-2
		M0,4 l4,-4
		M3,5 l2,-2" 
		style="stroke:black; stroke-width:1" />
		</pattern>
		<rect width=100 height=100 stroke=black fill="url(#diagonalHatch)" />
		<text x=50 y=115 fill=black text-anchor=middle font-style=italic>a</text>
		<text x=110 y=50 fill=black text-anchor=middle font-style=italic>a</text>
		<circle r=50 cx=50 cy=50 fill=#eee stroke=black />
		<text x=75 y=65 fill=black text-anchor=middle font-style=italic>r</text>
		<line x1=50 y1=50 x2=100 y2=50 stroke=black />
	</svg>
	<div>
		$$ S_{kruh} = \frac{\pi \cdot d^2}{4} $$
	</div>
</div>
<details>
<summary>Výstup</summary>
<pre><code>a = 8
r = 4
S = 50.27
</code></pre>
</details>
<h2><a class="header" href="#prohození-dvou-čísel" id="prohození-dvou-čísel">Prohození dvou čísel</a></h2>
<p>Pomocí dočasné proměnné provedeme prohození čísel ve dvou proměnných.</p>
<details>
<summary>Výstup</summary>
<pre><code>a = 10
b = 50

a = 50
b = 10
</code></pre>
</details>
<h2><a class="header" href="#maximum-ze-tří-čísel" id="maximum-ze-tří-čísel">Maximum ze tří čísel</a></h2>
<p>Ze tří čísel nalezneme maximum.</p>
<p><img src="ulohy/../mdbook-plantuml-img/d485221c14076d6e9b25b89453fbb420e46b02ed.svg" alt="" /></p>
<details>
<summary>Výstup</summary>
<pre><code>a = 10
b = 40
c = 20

maximum je 40
</code></pre>
</details>
<h2><a class="header" href="#výpis-sudých-čísel" id="výpis-sudých-čísel">Výpis sudých čísel</a></h2>
<p>Vypište sudá čísla od 0 do 100 (včetně).</p>
<h2><a class="header" href="#fizzbuzz" id="fizzbuzz">FizzBuzz</a></h2>
<p>Naimplementujte <a href="https://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz</a><sup class='margin-toggle sidenote-number'>1</sup>. Vypište čísla 1 až 100 tak, že:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Tento program často bývá obsahem interview programátorů ve firmách.</p>
</span>
<ul>
<li>pokud je číslo násobkem 3, tak vypište místo čísla <code>Fizz</code></li>
<li>pokud je číslo násobkem 5, tak vypište místo čísla <code>Buzz</code></li>
<li>pokud je číslo násobkem 3 i násobkem 5, tak vypíše místo čísla <code>FizzBuzz</code></li>
</ul>
<details>
<summary>Výstup programu</summary>
<pre><code>1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
Fizz Buzz
16
...
</code></pre>
</details>
<p><strong>Složitější varianta</strong>: Naimplementujte tento program bez použití podmínek. Nesimulujte ani podmínku
žádným cyklem. Použijte jediný cyklus <code>for</code> pro průchod čísly 1 až 100 a uvnitř tohoto cyklu nepoužijte
žádnou podmínku.</p>
<h2><a class="header" href="#fibonacciho-číslo" id="fibonacciho-číslo">Fibonacciho číslo</a></h2>
<p>Napište funkci, která vypočte <code>n</code>-té <a href="https://cs.wikipedia.org/wiki/Fibonacciho_posloupnost">Fibonacciho číslo</a>
(<code>n</code> bude parametrem funkce).</p>
<details>
<summary>Výstup funkce</summary>
<pre><code class="language-c">fibonacci(0);   // 0
fibonacci(1);   // 1
fibonacci(2);   // 1
fibonacci(3);   // 2
fibonacci(4);   // 3
fibonacci(5);   // 5
fibonacci(6);   // 8
</code></pre>
</details>
<h2><a class="header" href="#faktoriál" id="faktoriál">Faktoriál</a></h2>
<p>Napište funkci, která vypočte <a href="https://cs.wikipedia.org/wiki/Faktori%C3%A1l">faktoriál</a> předaného
parametru.</p>
<details>
<summary>Výstup funkce</summary>
<pre><code class="language-c">factorial(0);   // 1
factorial(1);   // 1
factorial(4);   // 24
factorial(5);   // 120
</code></pre>
</details>
<h2><a class="header" href="#textové-kreslení-obrazců" id="textové-kreslení-obrazců">Textové kreslení obrazců</a></h2>
<p>Vykreslete následující obrazce. Napište program tak, aby počet řádků, na který se
obrazec vykreslí, byl konfigurovatelný, tj. pro změnu počtu řádků by mělo stačit změnit jediný řádek
(jedinou proměnnou).</p>
<details>
<summary>Vyplněný čtverec</summary>
<pre><code>xxxx
xxxx
xxxx
xxxx
</code></pre>
</details>
<details>
<summary>Nevyplněný čtverec</summary>
<pre><code>xxxx
x  x
x  x
xxxx
</code></pre>
</details>
<details>
<summary>Čtverec vyplněný rostoucími čísly</summary>
<pre><code>xxxxx
x012x
x345x
x678x
xxxxx
</code></pre>
</details>
<details>
<summary>Diagonála</summary>
<pre><code>x
 x
  x
   x
    x
</code></pre>
</details>
<details>
<summary>Trojúhelník</summary>
<pre><code>  x  
 x x 
xxxxx
</code></pre>
</details>
<details>
<summary>Písmeno Z</summary>
<pre><code>xxxxxx
    x 
   x  
  x 
 x
xxxxxx
</code></pre>
</details>
<h2><a class="header" href="#načítání-pinu" id="načítání-pinu">Načítání PINu</a></h2>
<p>Načtěte od uživatele PIN (4 číslice). Poté opakovaně vyzývejte uživatele k zadání PINu. Pokud
uživatel zadá 3x nesprávný PIN, vypište chybovou hlášku a ukončete program.</p>
<h1><a class="header" href="#ukazatele-1" id="ukazatele-1">Ukazatele</a></h1>
<h2><a class="header" href="#nastavení-maxima" id="nastavení-maxima">Nastavení maxima</a></h2>
<p>Vytvořte funkci <code>set_max</code>, která přijme adresu celého čísla (<code>int</code>) pomocí ukazatele a dvě další
čísla a nastaví paměť na dané adrese na větší ze dvou zadaných čísel.</p>
<pre><code class="language-c">int res;
set_max(&amp;res, 5, 6);
// res == 6
</code></pre>
<h2><a class="header" href="#prohození-hodnoty" id="prohození-hodnoty">Prohození hodnoty</a></h2>
<p>Vytvořte funkci <code>swap</code>, která přijme dva ukazatele a prohodí hodnoty proměnných, na které ukazují.</p>
<pre><code class="language-c">int a = 5, b = 6;
swap(&amp;a, &amp;b);
// a == 6, b == 5
</code></pre>
<h2><a class="header" href="#výpočet-kořenů-kvadratické-rovnice" id="výpočet-kořenů-kvadratické-rovnice">Výpočet kořenů kvadratické rovnice</a></h2>
<p>Vytvořte funkci <code>quadratic_roots</code>, která vrátí počet kořenů kvadratické rovnice \( ax^2 + bx + c = 0 \) pomocí <code>return</code> a vypočítané kořeny vrátí pomocí předaných ukazatelů v argumentech funkce.</p>
<pre><code class="language-c">int quadratic_roots(float a, float b, float c, float *x1, float *x2);
</code></pre>
<p>Počet kořenů lze zjistit vypočítáním diskriminantu \( D = b^2 - 4ac \).
Pokud vyjde diskriminant záporný, tak funkce vrátí nulu, protože žádné řešení v \( \mathbb{R} \) neexistuje.
Pro nulový diskriminant funkce vrátí <code>1</code> a uloží dvojnásobný kořen na adresu ukazatelů <code>x1</code>, <code>x2</code>.
Pro kladný diskriminant funkce vrátí <code>2</code> a vypočítá kořeny pomocí:
$$ x_{1, 2} = \frac{-b \pm \sqrt{D}}{2a} $$</p>
<p><upr-parabola></upr-parabola></p>
<h1><a class="header" href="#pole-1" id="pole-1">Pole</a></h1>
<h2><a class="header" href="#naplnění-pole" id="naplnění-pole">Naplnění pole</a></h2>
<p>Vytvořte funkci <code>fill_array</code>, která naplní pole <code>array</code> čísly zvětšujícími se po <code>increment</code> a
začínajícími od <code>start</code>. </p>
<pre><code class="language-c">void fill_array(int* array, int len, int start, int increment);
</code></pre>
<p><upr-array-fill></upr-array-fill></p>
<h2><a class="header" href="#počítání-výskytů-čísla" id="počítání-výskytů-čísla">Počítání výskytů čísla</a></h2>
<p>Vytvořte funkci <code>num_count</code>, která spočítá a vrátí počet výskytů čísla <code>num</code> v poli <code>array</code>.</p>
<pre><code class="language-c">int num_count(int* array, int len, int num);
</code></pre>
<p><upr-array-interval array="[10, 2, 4, 3, 4, 8, 9, 4]" from="4" to="4"></upr-array-interval></p>
<h2><a class="header" href="#počítání-čísel-v-intervalu" id="počítání-čísel-v-intervalu">Počítání čísel v intervalu</a></h2>
<p>Vytvořte funkci <code>in_interval</code>, která spočítá počet čísel z uzavřeného intervalu <code>[from, to]</code> v poli
<code>array</code>.</p>
<pre><code class="language-c">int in_interval(int* array, int len, int from, int to);
</code></pre>
<p><upr-array-interval array="[10, 2, 4, 3, 4, 8, 9, 4]" from="2" to="5"></upr-array-interval></p>
<h2><a class="header" href="#průměrná-hodnota" id="průměrná-hodnota">Průměrná hodnota</a></h2>
<p>Vytvořte funkci <code>average</code>, která spočítá průměr čísel v poli <code>array</code>.</p>
<pre><code class="language-c">double average(int* array, int len);
</code></pre>
<p>Při dělení nezapomeňte přetypovat alespoň jeden operand na typ <code>double</code>, aby nedošlo k
celočíselnému dělení.</p>
<h2><a class="header" href="#minimální-hodnota-v-poli" id="minimální-hodnota-v-poli">Minimální hodnota v poli</a></h2>
<p>Vytvořte funkci, která v poli <code>array</code> nalezne minimální hodnotu.</p>
<pre><code class="language-c">int array_min(int *array, int len);
</code></pre>
<p><upr-array-min array="[3, 5, 2, 8, 7, 1, 3]"></upr-array-min></p>
<p>Následně funkci upravte, aby funkce vrátila pomocí ukazatele první index s minimální hodnotou.</p>
<pre><code class="language-c">int array_min(int *array, int len, int *min_index);
</code></pre>
<h2><a class="header" href="#minimální-a-maximální-hodnota" id="minimální-a-maximální-hodnota">Minimální a maximální hodnota</a></h2>
<p>Předchozí funkci upravte, aby hledala minimum a maximum zároveň.
Nalezené extrémy vraťte pomocí ukazatelů <code>min</code> a <code>max</code>.</p>
<pre><code class="language-c">void min_max(int* array, int len, int *min, int *max);
</code></pre>
<p>Ve funkci si nejprve nastavte index minimální a maximální hodnoty na nultý prvek.
Parametr <code>min</code> je ukazatel, a je tedy nutné přistupovat k jeho hodnotě pomoci dereference - <code>*min</code>,
protože výraz <code>min</code> obsahuje pouze adresu, kde je minimální index uložen. Následně projděte
pole a pokud bude hodnota aktuálního prvku menší než hodnota prvku na dosud nalezeném indexu,
nastavte hodnotu minimálního indexu na aktuální index. Stejný postup aplikujte i pro nalezení
maximálního prvku (stačí udělat jeden průchod polem).</p>
<h2><a class="header" href="#obrácení-pole" id="obrácení-pole">Obrácení pole</a></h2>
<p>Vytvořte funkci <code>array_reverse</code>, která obrátí prvky v poli.</p>
<pre><code class="language-c">void array_reverse(int* array, int len);
</code></pre>
<p>Pole projděte pomoci cyklu do jeho půlky a vždy prohazujte prvky z obou konců.</p>
<p><upr-array-reverse array="[10, 20, 30, 40, 50, 60]"></upr-array-reverse></p>
<p>Přehození dvou prvků nemůžete udělat najednou. Uložte si například prvek z levého konce do proměnné
a následně do tohoto prvku zapište hodnotu z pravého konce. Poté hodnotu z proměnné uložte do pravého
konce. Alternativně také můžete využít dříve naimplementovanou funkci <code>void swap(int* a, int* b)</code>.</p>
<h2><a class="header" href="#skalární-součin" id="skalární-součin">Skalární součin</a></h2>
<p>Vytvořte funkci <code>dot</code>, která spočítá
<a href="https://cs.wikipedia.org/wiki/Skal%C3%A1rn%C3%AD_sou%C4%8Din">skalární součin</a>.</p>
<pre><code class="language-c">int dot(int* a, int* b, int len);
</code></pre>
<h2><a class="header" href="#načtení-dynamického-počtu-hodnot" id="načtení-dynamického-počtu-hodnot">Načtení dynamického počtu hodnot</a></h2>
<p>Načtěte od uživatele číslo <code>n</code>. Poté naalokujte paměť o velikosti <code>n</code> <code>int</code>ů a 
načtěte ze vstupu <code>n</code> čísel, které postupně uložte do vytvořeného pole. Vypište součet načteného
pole.</p>
<h2><a class="header" href="#counting-sort" id="counting-sort">Counting sort</a></h2>
<p>Vygenerujte pole 10 000 000 <a href="ulohy/../ruzne/nahodna_cisla.html">náhodných čísel</a> z intervalu \( \langle 1000, 2000 \rangle \).
Pomocí algoritmu counting sort seřaďte čísla v poli od nejmenšího po největší.</p>
<ol>
<li>vytvořte pole počítadel pro všechny možné hodnoty v poli</li>
<li>vynulujte počitadla na 0</li>
<li>sekvenčně projděte pole čísel a inkrementujte odpovídající počítadlo</li>
<li>projděte pole počítadel a tiskněte hodnotu tolikrát, kolik je hodnota počítadla</li>
</ol>
<p><upr-counting-sort></upr-counting-sort></p>
<h2><a class="header" href="#třízení" id="třízení">Třízení</a></h2>
<p>Naimplementujte funkci, která setřídí pole. Můžete použít například algoritmus
<a href="https://en.wikipedia.org/wiki/Bubble_sort">bubble sort</a>.</p>
<h2><a class="header" href="#střelba-na-terč" id="střelba-na-terč">Střelba na terč</a></h2>
<p>Vytvořte program, který načte souřadnice terčů a střel, a vykreslí je do obrázku ve formátu
vektorové grafiky <a href="https://en.wikipedia.org/wiki/Scalable_Vector_Graphics">SVG</a>. Po najetí myší
na terč by se mělo ukázat skóre vybraného terče.</p>
<p><object data="terc/01_basic.svg"></object></p>
<p>Ze vstupu přečtěte počet terčů a následně si dynamicky alokujte 3 pole typu <code>float</code> pro <code>x</code> souřadnice terčů, <code>y</code> souřadnice terčů a poloměry terčů.</p>
<p>Poté pro každý terč přečtěte jeho <code>x</code> souřadnici, <code>y</code> souřadnici, poloměr a uložte je do
odpovídajících polí.
Například následující vstup nám popisuje 2 terče.
První terč má střed na souřadnici \( [50, 70 ] \) a poloměr \( 40 \) a druhý terč leží na středu \( [160, 90 ] \) s poloměrem \( 60 \).</p>
<pre><code>2
50 70 40
160 90 60
</code></pre>
<p>Tento vstup nezadávejte pořad dokola z klávesnice, ale <a href="ulohy/../c/text/vstupavystup.html">přesměrujte</a> si jej do programu ze souboru:</p>
<pre><code>$ ./main &lt; terce.txt
</code></pre>
<p>Terče si pomocí <code>printf</code> vykreslete do vektorového obrázku ve formátu svg, ve kterém lze pomocí tagů definovat útvary.
Útvary v obrázku obalte tagem <code>svg</code>:</p>
<pre><code class="language-xml">&lt;svg xmlns='http://www.w3.org/2000/svg'&gt;
  &lt;!-- kresleni kruhu --&gt;
&lt;/svg&gt;
</code></pre>
<p>Terč se středem \( [50, 70] \) a poloměrem \( 40 \) lze vykreslit pomocí: </p>
<pre><code class="language-svg">&lt;circle cx='50' cy='70' r='40' stroke='black' fill='red' /&gt;
</code></pre>
<p>Vytvořený SVG obrázek si ze standardního výstupu <a href="ulohy/../c/text/vstupavystup.html">přesměrujte</a> do souboru a otevřete si jej například v prohlížeči firefox.</p>
<pre><code class="language-shell">$ ./main &lt; terce.txt &gt; obrazek.svg
$ firefox obrazek.svg
</code></pre>
<p>Následně si ze vstupu přečtěte počet střel a alokujte pro ně dvě pole - jedno bude reprezentovat <code>x</code> souřadnice a druhé <code>y</code> souřadnice jednotlivých střel.
Souřadnice si následně přečtěte do těchto polí.
Pole si projděte a vykreslete do obrázku jako kruhy např. s poloměrem \( 4 \).</p>
<p>Střela zasáhla terč, pokud leží na kruhu.
Jinými slovy - střela zasáhla terč, pokud je vzdálenost od středu terče menší než poloměr terče.
Vzdálenost vypočítáme jednoduše pomocí Pythagorovy věty, kde <code>x</code> odvěsna je rozdíl mezi <code>x</code> souřadnici středu terče a <code>x</code> souřadnici střely. Odvěsna <code>y</code> lze vypočítat obdobně a poté můžeme vypočítat přeponu, která reprezentuje vzdálenost střely od středu terče.</p>
<svg>
   <circle cx="50" cy="50" r="50" fill="rgb(190, 83, 85)" />
   <circle cx="75" cy="20" r="5" fill="black" />
   <line x1=50 y1=50 x2=75 y2=20 stroke='black'/>
   <line x1=50 y1=50 x2=75 y2=50 stroke='black'/>
   <line x1=75 y1=20 x2=75 y2=50 stroke='black'/>
   <text x=60 y=35 text-anchor="end">dist</text>
</svg>
<p>Protože máme více terčů a více střel, tak musíme aplikovat výpočet vzdálenosti mezi každou střelou
a každým terčem pomocí dvou vnořených <code>for</code> cyklů.
Vnější cyklus bude procházet střely a vnitřní cyklus bude procházet terče.
Ve vnitřním cyklu vypočítáme vzdálenost mezi střelou a terčem a pokud je menší než poloměr,
tak tento konkrétní terč byl zasažen střelou z vnějšího cyklu.
V případě, že se více kruhů překrývá, tak střela zasáhla terč s menším poloměrem.
Budeme tedy hledat zasáhnutý terč s nejmenším poloměrem.</p>
<p>Skóre při zasažení středu s poloměrem 20 je 10 bodů a body postupně klesají.
Zdrojový kód SVG ukázek si můžete zobrazit.</p>
<details>
<summary>Dva terče</summary>
<p><object data="terc/01_basic.svg"></object></p>
<pre><code>2
50 70 40
160 90 60

4
25 70
80 90
150 100
55 140
</code></pre>
</details>
<details>
<summary>Překrývající se terče</summary>
<p><object data="terc/02_overlayed.svg"></object></p>
<pre><code>2
160 90 60
90 70 40

4
125 70 
80 90
150 100
55 140
</code></pre>
</details>
<details>
<summary>Překrývající se terče se stejným středem</summary>
<p><object data="terc/03_same_c.svg"></object></p>
<pre><code>3
50 70 40
160 90 60
160 90 40
7
25 70
80 90
55 140
125 60
140 130
150 100
215 100
</code></pre>
</details>
<h1><a class="header" href="#pvp-fight-game" id="pvp-fight-game">PvP fight game</a></h1>
<p><asciinema-player src="pvp.cast"></asciinema-player></p>
<p>Vytvořte simulaci PvP bitevní hry dle vašich představ.
Hra bude simulována dle náhody v herních kolech dle následující kostry programu:</p>
<pre><code class="language-c">while(nepratele_nebo_hrac_nazivu()) {
  // zvolim si nepritele
  // zautocim na nej a sebere mu zivoty
  // nepritel zautoci na me a sebere mi zivoty
  
  // smazani terminalu
  printf(&quot;\e[1;1H\e[2J&quot;);

  // nove vykresleni

  // uspani na 500 ms
  usleep(500 * 1000);
}
</code></pre>
<p>Životy nepřátel reprezentujme pomocí pole čísel a na začátku hry jim náhodně přiřaďme čísla z intervalu např. 150 - 400.
Hrdinovi životy vygenerujme obdobně - využijte tedy <strong>funkci</strong> pro vygenerovaní životů, ať zbytečně nekopírujeme kód.
Obdobně můžeme také vytvořit pole štítů a zbraní.
Konkrétního nepřítele můžeme vybrat pomocí několika strategií - každá může být naimplementovaná ve funkci přijímající pole životů/štítů/zbraní a počet nepřátel.
Funkce pak může vracet index vybraného hrdiny na kterého zaútočíme.</p>
<ol>
<li>vybrat nepřítele náhodně</li>
<li>vybrat nepřítele s nejmenším počtem životů</li>
<li>vybrat nepřítele s nejmenším počtem životů a štítu</li>
<li>vybrat nepřítele s nejslabší zbraní</li>
</ol>
<p>Po zaútočení ubereme nepříteli životy a zajistíme, aby nemohly být záporné - například pomocí ternárního výrazu.
Pokud má však štít, tak musíme mu nejprve ubrat životy ze štítu a poté z životů.</p>
<p>Zraněný nepřítel poté zaútočí na nás a odebere nám štít či životy - použijme funkci ať nekopírujeme kód.</p>
<p>Poté naimplementujeme funkci v podmínce cyklu - funkce bude vracet <code>TRUE</code>, pokud je hrdina naživu a zároveň je naživu alespoň jeden nepřítel.</p>
<p>Hru můžeme dále vylepšit o:</p>
<ul>
<li>critical damage 4%
<ul>
<li>pokud vygenerujeme číslo z rozsahu 0-99 a hodnota bude menší než např. 4, tak zaútočíme s dvojnásobným poškozením</li>
</ul>
</li>
<li>degradace zbraní
<ul>
<li>po každém útoku se poškozeni zbraně zmenší o 5%</li>
</ul>
</li>
<li>inventář zbraně hrdiny
<ul>
<li>hrdina bude mít několik zbraní</li>
<li>po každém útoku si hrdina vymění zbraň za následující v inventáři
<ul>
<li>realizujte to posunováním zbraní v inventáři
<ul>
<li>zazálohujeme si nultý prvek v poli do proměnné</li>
<li>první prvek nakopírujeme do nultého prvku</li>
<li>druhý prvek nakopírujeme do prvního prvku atd</li>
<li>následně na poslední index uložíme hodnotu zazálohovanou v proměnné</li>
</ul>
</li>
<li>alternativně si pamatujte index aktuální zbraně a ten inkrementujeme
<ul>
<li>pokud bude index vetší nebo roven počtu prvků, tak jej vrátíme opět na začátek</li>
<li>můžeme elegantně také využít operátor zbytku po dělení - tím nám odpadne podmínka či ternární výraz</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>prohazování zbraní dvou nepřátel po každém útoku</li>
<li>náhodné uzdravování a postupná regenerace štítu</li>
</ul>
<p><a href="https://en.wikipedia.org/wiki/Box-drawing_character">Rámečky</a> můžeme kreslit pomocí Unicode znaků - stačí je jenom zkopírovat a vložit do <code>printf</code>.</p>
<p>Barvy v terminálu můžeme měnit pomocí escape sekvencí:</p>
<pre><code class="language-c">#define RESET &quot;\x1B[0m&quot;
#define RED &quot;\x1B[31m&quot;
#define GREEN &quot;\x1B[32m&quot;
#define YELLOW &quot;\x1B[33m&quot;
#define BLUE &quot;\x1B[34m&quot;
#define MAGENTA &quot;\x1B[35m&quot;
#define CYAN &quot;\x1B[36m&quot;
#define WHITE &quot;\x1B[37m&quot;
...
printf(RED &quot;%d&quot; RESET, hp_left); 
</code></pre>
<p>Návrh hry také můžete později vylepšit pomocí <a href="ulohy//c/struktury/vlastni_datove_typy.html">struktury</a> <code>Player</code>, která by obsahovala životy, štít a zbraně jednoho hráče po kupě.</p>
<h1><a class="header" href="#dvourozměrné-pole" id="dvourozměrné-pole">Dvourozměrné pole</a></h1>
<h2><a class="header" href="#vytisknutí-matice" id="vytisknutí-matice">Vytisknutí matice</a></h2>
<p>Vytvořte funkci <code>print_matrix</code>, která vypíše obrázek reprezentovaný
<a href="ulohy/../c/pole/vicerozmerne_pole.html">dvourozměrným</a> (2D) polem.</p>
<pre><code class="language-c">void print_matrix(int* matrix, int rows, int cols);
</code></pre>
<p>Projděte matici po řádcích a sloupcích a vypište jednotlivé prvky.</p>
<h2><a class="header" href="#vykreslení-hvězdice" id="vykreslení-hvězdice">Vykreslení hvězdice</a></h2>
<p>Vytvořte funkci <code>draw_star</code>, která do 2D matice vykreslí hvězdici.</p>
<pre><code class="language-c">void draw_star(int* matrix, int rows, int cols);
</code></pre>
<pre><code>X    X    X
 X   X   X 
  X  X  X  
   X X X   
    XXX    
XXXXXXXXXXX
    XXX    
   X X X   
  X  X  X  
 X   X   X 
X    X    X
</code></pre>
<p>Hvězdici můžete vykreslit do pole pomocí jediného cyklu.
Zkuste vytvořit funkce na vykreslení dalších tvarů (čára, čtverec, kružnice, trojúhelník, …).</p>
<h2><a class="header" href="#násobení-matice-skalárem" id="násobení-matice-skalárem">Násobení matice skalárem</a></h2>
<p>Vytvořte funkci <code>matrix_mul_scalar</code>, která vynásobí každý prvek matice číslem <code>k</code>. </p>
<pre><code class="language-c">void matrix_mul_scalar(int* matrix, int rows, int cols, int k);
</code></pre>
<p><img src="ulohy/../static/img/matrix_scalar.svg" alt="Násobení matice skalárem" /></p>
<h2><a class="header" href="#násobení-matice-vektorem" id="násobení-matice-vektorem">Násobení matice vektorem</a></h2>
<p>Vytvořte funkci <code>matrix_mul_vector</code>, která vynásobí matici vektorem.</p>
<pre><code class="language-c">int* matrix_mul_vec(int* matrix, int rows, int cols, int *vec, int len);
</code></pre>
<!--
![Násobení matice vektorem](../static/img/matrix_vector.svg)
-->
<p><upr-matrix-mul a="[[1, 2, 3], [4, 5, 6], [7, 8, 9]]" b="[[10], [20], [30]]"></upr-matrix-mul></p>
<h2><a class="header" href="#násobení-matice-maticí" id="násobení-matice-maticí">Násobení matice maticí</a></h2>
<p>Vytvořte funkci pro násobení matice \( A \) o rozměrech \( rows_1 \times cols_1 \) s druhou matici \( B \) o rozměrech \( rows_2 \times cols_2 \).
Funkce vrátí <code>NULL</code> v případě, že matice nepůjdou vynásobit např. v případě, že počet řádků první matice není shodný s počtem sloupců druhé matice.
Výslednou matici o rozměrech \( rows_1 \times cols_1 \) alokujte dynamicky.</p>
<upr-container>
  <upr-matrix-mul a="[[1, 2, 3], [4, 5, 6]]" b="[[10, 20], [30, 40], [50, 60]]"></upr-matrix-mul>
  <!--
  <upr-arrow dst="table" dst-anchor="south" src-anchor="north">a</upr-arrow>
  <upr-arrow dst="table:nth-of-type(2)" dst-anchor="south" src-anchor="north">b</upr-arrow>
  <upr-arrow dst="table:nth-of-type(3)" dst-anchor="south" src-anchor="north">result</upr-arrow>
  -->
</upr-container>
<h1><a class="header" href="#digitální-hodiny" id="digitální-hodiny">Digitální hodiny</a></h1>
<upr-segment />
<p>Vytvořme real-time digitální hodiny ukazující aktuální čas ve stylu <a href="https://en.wikipedia.org/wiki/Seven-segment_display">7-segmentových</a> displejů.</p>
<p>Cifry hodin budeme vykreslovat do 2D matice realizované pomocí jednodimenzionálního pole.
Jeden segmentový displej bude mít délku či výšku například 3 znaky.
Mezi každou cifrou bude jeden znak volný.
Na základě těchto parametrů vypočítáme potřebnou velikost 2D matice a následně alokujeme potřebnou paměť.</p>
<p>Pro čitelnější kód bude vhodné vytvořit funkcí <code>void screen_draw_pixel(char* screen, int width, int height, int x, int y, char c)</code>, která vykreslí znak <code>c</code> (mřížku nebo mezeru) na souřadnici <code>[x, y]</code>.
Uvnitř funkce by také měla byt kontrola, zda se souřadnice nevyskytuje mimo vykreslovanou plochu pro rychlejší detekci případných chyb.</p>
<p>Segmenty jsou reprezentované vodorovnou či svislou čarou.
Vytvoříme si funkci pro kreslení vodorovné čáry <code>void screen_draw_hline(char* screen, int width, int height, int x, int y, int len)</code>.
V cyklu délky <code>len</code> budeme následně vykreslovat pixely pomocí dříve vytvořené funkce <code>screen_draw_pixel</code>.
Obdobně vytvoříme i funkci <code>screen_draw_vline</code> pro vykreslení vertikální čáry.</p>
<p>Následně si vytvoříme funkci, která nám vykreslí pro <code>n</code>-tou cifru segment <code>s</code> pomocí dříve vytvořených funkcí kreslení čár:</p>
<pre><code>void screen_draw_segment(char* screen, int width, int height, int n, int s);
</code></pre>
<p>A poté si uděláme funkci pro vykreslení číslice <code>num</code>:</p>
<pre><code>void screen_draw_num(char* screen, int width, int height, int n, int num);
</code></pre>
<p>Alternativně také můžeme obě funkce spojit do jedné a informaci o zobrazovaných segmentech zakódovat do bitů, kde na nejnižším bitu je jednička, pokud má svítit segment G.
Díky této úpravě se nám kod zjednoduší.</p>
<pre><code>//     ABCDEFG
// 0 - 1111110
// 1 - 0110000
</code></pre>
<p>Po úspěšném otestování všech cifer si můžeme vytvořit nekonečnou smyčku a zobrazovat aktuální čas:</p>
<pre><code class="language-c">#include &lt;time.h&gt;

int main() {
  char *display = ...;

  for(;;) {
    // vymazani terminalu
    printf(&quot;\e[1;1H\e[2J&quot;);

    // TODO: vykresleni aktualniho casu
    time_t t = time(NULL);
    struct tm *tm = localtime(&amp;t);
    printf(&quot;%d:%d:%d\n&quot;, tm-&gt;tm_hour, tm-&gt;tm_min, tm-&gt;tm_sec);

    usleep(1000 * 1000);
  }
}
</code></pre>
<h1><a class="header" href="#Řetězce-1" id="Řetězce-1">Řetězce</a></h1>
<h3><a class="header" href="#převod-na-velké-znaky" id="převod-na-velké-znaky">Převod na velké znaky</a></h3>
<p>Vytvořte funkci, která převede textový řetězec na velké znaky.</p>
<pre><code class="language-c">char str[] = { &quot;hello&quot; };
uppercase(str);
// str by se zde měl rovnat &quot;HELLO&quot;
</code></pre>
<h3><a class="header" href="#nahrazení-znaku" id="nahrazení-znaku">Nahrazení znaku</a></h3>
<p>Vytvořte funkci, která v řetězci nahradí všechny výskyty daného znaku za znak <code>'X'</code>.</p>
<pre><code class="language-c">char str[] = { &quot;hello&quot; };
replace(str, 'l');
// str by se zde měl rovnat &quot;heXXo&quot;
</code></pre>
<h3><a class="header" href="#Šifrování-řetězce" id="Šifrování-řetězce">Šifrování řetězce</a></h3>
<p>Vytvořte funkci, která &quot;zašifruje&quot; řetězec tím, že ke každému znaku přičte číslo (klíč).
K ní vytvořte funkci, která řetězec opět odšifruje (odečtením klíče).</p>
<pre><code class="language-c">char str[] = { &quot;abc&quot; };
encrypt(str, 1);
// str by se zde měl rovnat &quot;bcd&quot;
decrypt(str, 1);
// str by se zde měl opět rovnat &quot;abc&quot;
</code></pre>
<h3><a class="header" href="#délka-řetězce" id="délka-řetězce">Délka řetězce</a></h3>
<p>Vytvořte funkci <code>my_strlen</code>, která vypočte délku řetězce (obdoba funkce
<a href="https://devdocs.io/c/string/byte/strlen"><code>strlen</code></a> ze standardní knihovny <em>C</em>).</p>
<pre><code class="language-c">my_strlen(&quot;&quot;);          // 0
my_strlen(&quot;abc&quot;);       // 3
my_strlen(&quot;abc 0 asd&quot;); // 9
</code></pre>
<h3><a class="header" href="#porovnávání-řetězců" id="porovnávání-řetězců">Porovnávání řetězců</a></h3>
<p>Vytvořte funkci, která vrátí <code>true</code>, pokud jsou dva předané řetězce stejné.
Vytvořte i variantu funkce, která porovnává řetězce bez ohledu na velikosti znaků.</p>
<pre><code class="language-c">strequal(&quot;ahoj&quot;, &quot;ahoj&quot;);               // 1
strequal(&quot;ahoj&quot;, &quot;aho&quot;);                // 0
strequal_ignorecase(&quot;ahoj&quot;, &quot;AhOj&quot;);    // 1
</code></pre>
<h3><a class="header" href="#palindrom" id="palindrom">Palindrom</a></h3>
<p>Vytvořte funkci, která vrátí <code>true</code>, pokud je předaný řetězec
<a href="https://cs.wikipedia.org/wiki/Palindrom">palindrom</a> (slovo, které se čte stejně zepředu i pozpátku).</p>
<p><img src="ulohy/../static/img/palindrom.svg" alt="palindrom" /></p>
<h3><a class="header" href="#histogram" id="histogram">Histogram</a></h3>
<p>Vytvořte funkci, která vypočte <a href="https://cs.wikipedia.org/wiki/Histogram">histogram</a> znaků v řetězci.
Histogram je pole, ve kterém prvek na pozici <code>x</code> udává, kolikrát se znak <code>x</code> vyskytoval v daném řetězci.</p>
<pre><code class="language-c">int histogram[255] = {};
calc_histogram(&quot;aabacc&quot;, histogram);
// histogram['a'] == 3
// histogram['b'] == 1
// histogram['c'] == 2
// histogram['d'] == 0
</code></pre>
<h3><a class="header" href="#převod-textu-na-číslo" id="převod-textu-na-číslo">Převod textu na číslo</a></h3>
<p>Vytvořte funkci, která převede řetězec na číslo v desítkové soustavě. Pokud číslo nelze převést,
vraťte hodnotu <code>0</code>.</p>
<pre><code class="language-c">convert(&quot;5&quot;);   // vrátí int s hodnotou 5
convert(&quot;123&quot;); // vrátí int s hodnotou 123
</code></pre>
<p>Zkuste přidat i podporu pro záporná čísla.</p>
<h1><a class="header" href="#chat-cleaner" id="chat-cleaner">Chat cleaner</a></h1>
<p>Napište program, který transformuje cO0l zPráVy<img height="20" src="https://emoji.gg/assets/emoji/GWjiangoOmegaLUL.png"><img height="20" src="https://emoji.gg/assets/emoji/1219_KEKW.png"> z chatu do čitelné podoby.
Zprávy jsou do našeho programu přesměrovány na standardní vstup - úkolem bude číst zprávy nebo části zprav po řádcích a provádět následující úpravy:</p>
<ol>
<li>
<p>odstranit bílé znaky (whitespace - mezera, tabulátor, ...) ze začátku a konce každého řádku</p>
<p>možné řešení:</p>
<ol>
<li>najít pozici prvního non-whitespace znaku</li>
<li>překopírovat všechny znaky od této pozice na začátek pomocí vlastního cyklu nebo <code>strcpy</code>, <code>memcpy</code> či <code>memmove</code></li>
<li>cyklem jít od konce řetězce a najít první non-whitespace znak</li>
<li>uložit za něj nový konec <code>\0</code></li>
</ol>
</li>
<li>
<p>transformovat cO0L tExT do čitelné podoby</p>
<p>Každá věta začne velkým písmem a všechna ostatní písmena ve větě budou převedena na malá písmena.
Věta je ukončena znakem <code>.</code>, <code>!</code> nebo <code>?</code>.</p>
<p>Např. si před cyklem vytvořit proměnnou indikující start nové věty.
Cyklem projít všechny znaky a první písmeno věty zvětšit a zbytek zmenšovat.
Tečka, otazník či vykřičník poté nastaví nastaví proměnnou indikující novou větu.</p>
</li>
<li>
<p>nahrazení opakujících se znaků jedním výskytem</p>
<p>Např. si pamatovat proměnnou s předchozím znakem nebo porovnávat přímo předchozí znak - pozor abychom nepřistoupili před/za pole.
Na velikosti písmen nebude záležet - <code>xXxxXx</code> se také nahradí jedním <code>x</code>.
Můžeme si udržovat dva indexy - jeden ve vstupním stringu a druhý ve výstupním stringu.
Pokud se znak opakuje, tak jej nepřidáváme do výstupního stringu.</p>
</li>
<li>
<p>smazání smajlíku zapsaných pomocí <code>:nazev:</code></p>
<p>Procházíme znak po znaku a pamatujeme si, jestli jsme narazili na <code>:</code>.
Pokud ano, tak nepřidáváme znaky do výstupního stringu.
Pokud nenarazíme na ukončovací <code>:</code>, tak text musíme do stringu přidat - viz ukázka v testu.</p>
</li>
<li>
<p>cenzura slov pomocí hvězdiček</p>
<p>Každé slovo z pole blocklistu o velikosti <code>sizeof(blocklist) / sizeof(blocklist[0])</code> zkusíme najít v řetězci.
Pokud najdeme, tak celé slovo vyhvězdičkujeme a zkusíme hledat další výskyt od konce tohoto výskytu.
Při hledání nebude záležet na velikosti písmen.</p>
<pre><code class="language-c">const char *blocklist[] = {
   &quot;windows&quot;,
   &quot;mac&quot;,
   &quot;c#&quot;,
   &quot;fortnite&quot;,
   &quot;php&quot;,
   &quot;javascript&quot;,
   &quot;.net&quot;,
};
// blocklist[0] je &quot;windows&quot;
</code></pre>
</li>
</ol>
<h1><a class="header" href="#struktury-1" id="struktury-1">Struktury</a></h1>
<p>Vytvořte strukturu <code>Student</code>, která bude obsahovat atributy pro jeho věk, jméno, počet bodů a
nejlepšího přítele (to bude také student). Dále naimplementujte tyto funkce:</p>
<pre><code class="language-c">/**
 * Nainicializujte studenta se zadaným věkem a jménem.
 * Počet bodů i nejlepší přítel by měli být nastaveni na nulu.
 */
void student_init(Student* student, int age, const char* name) {}

/**
 * Spočítejte, kolik studentů v předaném poli má maximálně zadaný věk.
 * Příklad:
 *   Student students[3];
 *   students[0].age = 18;
 *   students[1].age = 19;
 *   students[2].age = 16;
 *
 *   count_young_students(students, 3, 18); // 2
 */
int count_young_students(Student* students, int count, int maximum_age) {}

/**
 * Přiřaďte studentům body na základě výsledků testů.
 * V poli `points` jsou body pro jednotlivé studenty v poli `students`.
 * Parameter `count` obsahuje počet studentů a testů.
 */
void assign_points(Student* students, const int* points, int count) {}

/**
 * Vraťe v parametru `good_students` pole studentů, kteří mají alespoň 51 bodů a v
 * parametru `good_student_count` jejich počet.
 * Budete muset dynamicky naalokovat nové pole s odpovídající velikostí.
 */
void filter_good_students(
    const Student* students,
    int count,
    Student** good_students,
    int* good_student_count
);

/**
 * Otestujte, jestli je student šťastný.
 * Student je šťastný, pokud:
 * 1) Má alespoň 51 bodů, a zároveň
 * 2) Jeho nejlepší přítel je šťastný
 *
 * Pokud student nemá nejlepšího přítele, pokládejte podmínku 2) za splněnou.
 */
int student_is_happy(Student* student) {}
</code></pre>
<p>K otestování vaší implementace můžete použít následující testovací program<sup class='margin-toggle sidenote-number'>1</sup>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Implementace svých funkcí v tomto programu umístěte nad <code>main</code> a program spusťte s
<a href="ulohy/../prostredi/ladeni.html#address-sanitizer"><code>Address sanitizerem</code></a>. Pokud program nic nevypíše, máte
implementaci pravděpodobně správně.</p>
</span><details>
<summary>Testovací program</summary>
<pre><code class="language-c">#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

// Zde vložte implementace funkcí

int main()
{
    Student jirka;
    student_init(&amp;jirka, 18, &quot;Jiri Novak&quot;);
    assert(jirka.age == 18);
    assert(!strcmp(jirka.name, &quot;Jiri Novak&quot;));
    assert(jirka.points == 0);
    assert(jirka.best_friend == NULL);

    Student students[3];
    for (int i = 0; i &lt; 3; i++)
    {
        student_init(students + i, 17 + i, &quot;&quot;);
    }
    assert(count_young_students(students, 3, 18) == 2);

    int points[] = { 10, 15, 3 };
    assign_points(students, points, 3);
    assign_points(students, points, 1);
    assert(students[0].points == 20);
    assert(students[1].points == 15);
    assert(students[2].points == 3);

    Student a = {}, b = {}, c = {};
    a.points = 51;
    b.points = 50;
    c.points = 50;
    assert(student_is_happy(&amp;a));
    a.best_friend = &amp;b;
    assert(!student_is_happy(&amp;a));
    b.points = 51;
    assert(student_is_happy(&amp;a));
    b.best_friend = &amp;c;
    assert(!student_is_happy(&amp;a));
    c.points = 100;
    assert(student_is_happy(&amp;a));

    Student students2[3] = {};
    students2[0].age = 15;
    students2[2].age = 18;
    int points2[] = { 51, 20, 60 };
    assign_points(students2, points2, 3);

    Student* good_students;
    int good_students_count;
    filter_good_students(students2, 3, &amp;good_students, &amp;good_students_count);
    assert(good_students_count == 2);
    assert(good_students[0].age == 15);
    assert(good_students[1].age == 18);

    free(good_students);

    return 0;
}
</code></pre>
</details>
<h1><a class="header" href="#kreslení-obrazovky-apple-watch" id="kreslení-obrazovky-apple-watch">Kreslení obrazovky Apple Watch</a></h1>
<p>Pro tuto úlohu využijte stuktury a funkce pro zápis obrázku formátu <a href="ulohy/../c/aplikovane_ulohy/tga.html">TGA</a> do souboru.</p>
<p>Vše má svůj příběh a tak tedy započněme naši cestu např. ve firmě <a href="https://www.apple.com">Apple</a>…</p>
<p>Představte si, že jste vývojářem/kou ve firmě Apple a <a href="https://en.wikipedia.org/wiki/Steve_Jobs">Steve Jobs</a> Vás pověří programátorským úkolem.</p>
<p>Firma aktuálně pracuje na super tajném projektu <a href="https://en.wikipedia.org/wiki/Apple_Watch">nových smart hodinek</a>, které chce uvést na trh.
Vašim úkolem je pod přímým vedením Steva Jobse (původního zakladatele firmy) naprogramovat digitální ciferník nových hodinek.</p>
<h3><a class="header" href="#technické-specifikace-displeje" id="technické-specifikace-displeje">Technické specifikace displeje</a></h3>
<p>Displej hodinek má rozlišení <code>368x448</code> px (<a href="https://en.wikipedia.org/wiki/Pixel">pixelů</a>).</p>
<h3><a class="header" href="#schéma-pro-zobrazení-znaků" id="schéma-pro-zobrazení-znaků">Schéma pro zobrazení znaků</a></h3>
<p>Na obrázku níže je rozklesleno, jak by se měl zobrazovat čas na hodinkách.</p>
<p><img src="ulohy/../static/img/watches_clock.svg" alt="" /></p>
<p>První řádek slouží pro zobrazeni hodin, druhý řádek pro zobrazení minut.
Tloušťky jednotlivých segmentů a rozestupy jsou také zakresleny.
Modře je znázorněna oblast, kde se nevykreslují číslice, ale je možno kreslit pozadí ciferníku.
Jsou znázorněna jen čtyři čísla, zbytek si již odvodíte sami.</p>
<h3><a class="header" href="#funkce-a-struktury-na-implementaci" id="funkce-a-struktury-na-implementaci">Funkce a struktury na implementaci</a></h3>
<p>Postupně naimplementujte následující funkce a struktury.</p>
<h4><a class="header" href="#funkce-pro-vykreslení-času" id="funkce-pro-vykreslení-času">Funkce pro vykreslení času</a></h4>
<pre><code class="language-c">void watch_draw_time(TGAImage* self, const int hours, const int minutes);
</code></pre>
<p>Funkce nakreslí do obrázku <code>self</code> čas zadaný pomocí času v hodinách (<code>hours</code>) a minutách (<code>minutes</code>).
Barvu čísel si zvolte libovolně, stejně jako barvu pozadí.</p>
<h4><a class="header" href="#struktura-pro-reprezentaci-barvy-pixelu-rgba" id="struktura-pro-reprezentaci-barvy-pixelu-rgba">Struktura pro reprezentaci barvy pixelu (<code>RGBA</code>)</a></h4>
<p>Barva se do každého pixelu zapisuje jako čtveřice bajtů <code>BGRA</code> (<code>B</code> - Blue, <code>G</code> - Green, <code>R</code> - Red,
<code>A</code> - Alpha). Nadefinujte si strukturu <code>RGBA</code>, která bude tyto bajty reprezentovat pomocí čtyř
proměnných: <code>r</code>, <code>g</code>, <code>b</code>, <code>a</code> patřičného datového typu.</p>
<h4><a class="header" href="#funkce-pro-vykreslení-času-s-určením-barev" id="funkce-pro-vykreslení-času-s-určením-barev">Funkce pro vykreslení času s určením barev</a></h4>
<pre><code class="language-c">void watch_draw_time_color(
    TGAImage* self,
    const int hours,
    const int minutes,
    const RGBA* fg_color,
    const RGBA* bg_color
);
</code></pre>
<p>Funkce nakreslí do obrázku <code>self</code> čas zadaný pomocí času v hodinách (<code>hours</code>) a minutách (<code>minutes</code>).
Barva čísel je předána parametrem <code>fg_color</code>, barva pozadí pak parametrem <code>bg_color</code>.</p>
<h1><a class="header" href="#létající-písmenka" id="létající-písmenka">Létající písmenka</a></h1>
<p>Využijte znalosti <a href="ulohy//c/pole/vicerozmerne_pole.html">dvourozměrných polí</a>, <a href="ulohy//c/text/retezce.html">řetězců</a> a <a href="ulohy//ruzne/funkce_main.html#vstupn%C3%AD-parametry-funkce-main.html">argumentů programu</a> pro vytvoření následující animace:</p>
<p><asciinema-player src="letters.cast"></asciinema-player></p>
<ol>
<li>
<p>Vytvoříme si strukturu reprezentující vykreslovací plochu</p>
<pre><code class="language-c">typedef struct {
 char *content; // rows x cols &quot;pixelu&quot;
 int rows;
 int cols;
} Board;
</code></pre>
</li>
<li>
<p>Naimplementujeme si funkci pro vytvoření nové vykreslovací plochy o předaných rozměrech</p>
<pre><code class="language-c">Board* board_new(int rows, int cols) {
 // dynamická alokace paměti pro strukturu složenou z pointeru na obsah a dvou proměnných udávající rozměry
 // dynamická alokace paměti pro rows*cols pixelů typu char a uložení do pointeru content
 // uložení rows a cols do struktury a vrácení
}
</code></pre>
<p>Nesmíme také zapomenout ošetřovat různé chybové stavy - alokace paměti nemusí být vždy úspěšná a musíme provést kontrolu, zda navrácená paměť není <code>NULL</code>.
K této funkci je také vhodné doimplementovat funkci pro uvolnění pixelů a poté samostatné struktury:</p>
<pre><code class="language-c">void board_delete(Board* b);
</code></pre>
</li>
<li>
<p>Funkce pro vykreslení pixelu / znaku</p>
<p>Pro jednoduší a čitelnější kód si naimplementujeme funkci, která nám vykreslí znak <code>c</code> na řádek <code>row</code> a sloupec <code>col</code>.
Funkce by také měla zkontrolovat, zda souřadnice není před nultým či posledním řádkem a sloupcem, aby nedocházelo k pádu programu nebo k vykreslování jinam.</p>
<pre><code class="language-c">void board_draw_pixel(Board *b, int row, int col, char c);
</code></pre>
<p>Přepočet 2D souřadnice <code>[row, col]</code> na 1D index můžeme podle následujícího obrázku:
<img src="ulohy//static/img/2d_array.svg"></p>
</li>
<li>
<p>Vykreslení rámečku</p>
<p>Kolem okrajů vykreslíme rámeček pomocí funkce <code>board_draw_pixel</code>.
Pro vykreslování rámečku <strong>NENÍ</strong> potřeba procházet vnitřek - stačí dvě smyčky za sebou.
První smyčka bude procházet všechny řádky a kreslit na nultý a poslední sloupec.
Obdobně druhá smyčka bude procházet sloupce a kreslit na nultý a poslední řádek.
Procházením vnitřku plochy se může znatelně zpomalit např. při rozlišení 8k.</p>
<pre><code>#################
#               #
#               #
#               #
#               #
#               #
#               #
#################
</code></pre>
</li>
<li>
<p>Reprezentace písmenka a jeho vykreslování</p>
<p>Písmenko budeme reprezentovat pomocí struktury složené ze znaku, pozice a rychlost pohybu:</p>
<pre><code class="language-c">typedef struct {
 int row;
 int col;
} Coord;

typedef struct {
  char c;
  Coord position;
  Coord speed;
} Letter;
</code></pre>
<p>Rychlost pohybu <code>speed</code> bude nabývat hodnot <code>-1</code> pro směr vlevo v případě sloupcové souřadnice nebo směr nahoru v případě řádkové souřadnice.
Hodnota <code>1</code> pak bude znamenat směr doprava respektive dolů.</p>
<p>Následně si vytvoříme funkci pro jeho vykreslení do plochy:</p>
<pre><code>void letter_render(Letter *letter, Board *board);
</code></pre>
</li>
<li>
<p>Pohyb písmenka s odrážením od stěn</p>
<p>Vytvoříme si funkci simulující jeden pohyb písmenka:</p>
<pre><code>void letter_step(Letter *letter, Board *board);
</code></pre>
<p>K aktuální pozici písmenka v řádku a sloupci přičteme rychlost <code>speed</code> z odpovídající souřadnice.
Poté zkontrolujeme, zda je nová pozice na prvním řádku/sloupci či předposledním řádku/sloupci.
Pokud ano, tak změníme směr písmenka a tím dojde v příštím kroku k odrazu.</p>
</li>
<li>
<p>Hlavní smyčka</p>
<p>Pro otestování odrazu je opět vhodné si udělat hlavní vykreslovací smyčku:</p>
<pre><code class="language-c">Board *b = board_new(20, 50);
Letter l;
l.c = 'O';
l.position.row = b-&gt;rows / 2;
l.position.col = b-&gt;cols / 2;
l.speed.row = 1;
l.speed.col = -1;

for(;;) {
 // smazani terminalu
 printf(&quot;\e[1;1H\e[2J&quot;);

 // vykresleni ramecku
 board_draw_border(b);

 // jeden krok pismenka
 letter_step(&amp;l, b);

 // vykresleni pismenka
 letter_render(&amp;l, b);

 // uspani na 500 ms
 usleep(500 * 1000);
}
</code></pre>
</li>
<li>
<p>Více písmenek</p>
<p>Textový řetězec si převedeme na pole létajících písmenek pomocí funkce:</p>
<pre><code class="language-c">typedef struct {
 Letter *letters;
 int count;
} Sentence;

Sentence* sentence_new(const char* sentence) {
 // dynamická alokace struktury sentence
 // dynamická alokace pole pro písmenka letters
 // v cyklu projdeme řetězec sentence a nastavíme písmenka v letters, tak aby následovala za sebou a měla náhodnou rychlost
 // vrátíme ukazatel na strukturu
}
</code></pre>
<p>Vykreslovací smyčku poté upravíme, aby uměla pracovat s celou větou a ne jenom s jediným písmenkem - prakticky půjde pouze o doplnění cyklu přes všechna písmenka.</p>
</li>
</ol>
<h1><a class="header" href="#soubory-1" id="soubory-1">Soubory</a></h1>
<h2><a class="header" href="#spočítání-řádků" id="spočítání-řádků">Spočítání řádků</a></h2>
<p>Naimplementujte funkci, která načte soubor na zadané cestě a vrátí počet řádků, které se v něm
vyskytují.</p>
<pre><code class="language-c">int count_lines(const char* path) {}
</code></pre>
<h2><a class="header" href="#kopírování-souboru" id="kopírování-souboru">Kopírování souboru</a></h2>
<p>Naimplementujte funkci, která přijme cestu ke vstupnímu a výstupnímu souboru a zkopíruje obsah
vstupního souboru do výstupního souboru.</p>
<pre><code class="language-c">void copy_file(const char* src, const char* destination) {}
</code></pre>
<h2><a class="header" href="#Šifrování-souboru" id="Šifrování-souboru">Šifrování souboru</a></h2>
<p>Naimplementujte funkci, která přičte číslo <code>key</code> ke všem znakům v souboru na zadané cestě.</p>
<pre><code class="language-c">void encrypt_file(const char* path, int key) {}
</code></pre>
<p>Dále udělejte druhou funkci, která od znaků v souboru na zadané cestě naopak číslo <code>key</code> odečte.
Otestujte, že soubor po zašifrování a odšifrování obsahuje stejný obsah. Pro testování používejte
soubory s ASCII textem.</p>
<pre><code class="language-c">void decrypt_file(const char* path, int key) {}
</code></pre>
<h1><a class="header" href="#střelba-na-terče" id="střelba-na-terče">Střelba na terče</a></h1>
<svg xmlns="http://www.w3.org/2000/svg">
	<!-- targets -->
	<circle cx="50" cy="70" r="40.000000" fill="red" />
	<circle cx="160" cy="90" r="60.000000" fill="#32CD32" />
	<!-- missiles -->
	<circle cx="25" cy="70" r="5" fill="black" />
	<circle cx="80" cy="90" r="5" fill="black" />
	<circle cx="150" cy="100" r="5" fill="black" />
	<circle cx="55" cy="140" r="5" fill="black" />
</svg>
<ol>
<li>
<p>načíst terče z textového souboru předaného v prvním argumentu programu</p>
<pre><code class="language-c">TargetsArray* targets_load(const char* path);
</code></pre>
<ul>
<li>terče reprezentovat pomocí struktury</li>
<li>souřadnice jsou typu <code>int</code></li>
<li>radius je typu <code>float</code></li>
<li>barva může mít maximálně 15 znaků</li>
<li>na řádku může být pouze jeden terč</li>
<li>ošetřit neexistenci souboru a různé chyby nesplňující formát (viz testy):</li>
</ul>
<pre><code># targets.txt
pocet_tercu
terc0_x terc0_y terc0_radius terc0_barva
terc1_x terc1_y terc1_radius terc1_barva
...
</code></pre>
</li>
<li>
<p>načíst střely z binárního souboru předaného v prvním argumentu programu</p>
<pre><code class="language-c">MissilesArray* missiles_load(const char* path) {
  // 1. otevreme soubor path pro binarni cteni
  // 2. zkontrolujeme, zda se podarilo nacist
  
  // 3. nacist ze souboru bajt s poctem prvku N (a zkontrolovat)
  // 4. alokovat strukturu MissilesArray (sizeof(MissilesArray)
  // 5. alokovat pamet pro N items typu Missile 
  
  // 6. cyklus pres vsechny prvky N
  // 7. precteme 2x uint32_t a ulozime do struktury (a kontrolujeme)
  
  // 8. zkontrolujeme, ze je konec souboru
  
  // 9. vratime pointer na missiles
}
</code></pre>
</li>
</ol>
<ul>
<li>střely také reprezentovat pomocí struktury</li>
<li>ošetřit různé chyby při čtení (kratší soubor, delší soubor, ...)</li>
<li>první bajt soubor obsahuje počet terčů</li>
<li>každý terč je pak reprezentován dvěma čísly o velikosti 4 bajty (lépe použít <code>uint32_t</code>)</li>
</ul>
<br>
   Obsah souboru: (lze najet myší na skupinky bajtů)<br>
   <code>$ xxd -g 1 01_missiles.bin</code>
<div class="hex">
 <span>04<span>1 unsigned bajt<br>počet střel</span></span>
 <span>19 00 00 00<span>unsigned int (uint32_t) v low endian<br>0x00000019 = 25<br>X souřadnice nulté střely</span></span>
 <span>46 00 00 00<span>unsigned int (uint32_t) v low endian<br>Y souřadnice nulté střely</span></span>
 <span>50 00 00 00<span>unsigned int (uint32_t) v low endian<br>X souřadnice první střely</span></span>
 <span>5a 00 00 00<span>unsigned int (uint32_t) v low endian<br>Y souřadnice první střely</span></span>
 <span>96 00 00 00<span>unsigned int (uint32_t) v low endian<br>X souřadnice druhé střely</span></span>
 <span>64 00 00 00<span>unsigned int (uint32_t) v low endian<br>Y souřadnice druhé střely</span></span>
 <span>37 00 00 00<span>unsigned int (uint32_t) v low endian<br>X souřadnice třetí střely</span></span>
 <span>8c 00 00 00<span>unsigned int (uint32_t) v low endian<br>Y souřadnice třetí střely</span></span>
</div>
<ol start="3">
<li>
<p>vykreslit terče a střely do textového SVG obrázku <code>result.svg</code></p>
<pre><code class="language-c">bool render_svg(const char *path, const TargetsArray *targets, const MissilesArray *missiles) {
	// 1. otevreme soubor pro textovy zapis
 // 2. zkontrolovat
  
 // 3. projdeme vsechny targets a vytiskneme &lt;circle&gt;
 // 4. projdeme vsechny missiles a vytiskneme &lt;circle&gt;
  
 // 5. zavrit soubor
}
</code></pre>
<p>SVG obrázek musí byt v tomto formátu:</p>
<pre><code>&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
   &lt;!-- targets --&gt;
   &lt;circle cx=&quot;90&quot; cy=&quot;70&quot; r=&quot;40.000000&quot; fill=&quot;red&quot; /&gt;
   &lt;circle cx=&quot;160&quot; cy=&quot;90&quot; r=&quot;60.000000&quot; fill=&quot;#ffaabb&quot; /&gt;
   &lt;!-- missiles --&gt;
   &lt;circle cx=&quot;125&quot; cy=&quot;70&quot; r=&quot;5&quot; fill=&quot;black&quot; /&gt;
   &lt;circle cx=&quot;80&quot; cy=&quot;90&quot; r=&quot;5&quot; fill=&quot;black&quot; /&gt;
   &lt;circle cx=&quot;150&quot; cy=&quot;100&quot; r=&quot;5&quot; fill=&quot;black&quot; /&gt;
   &lt;circle cx=&quot;55&quot; cy=&quot;140&quot; r=&quot;5&quot; fill=&quot;black&quot; /&gt;
 &lt;/svg&gt;
</code></pre>
</li>
<li>
<p>vypočitání zásahu a uložení do binárního souboru <code>score.dat</code></p>
<pre><code class="language-c">void calculate_score(TargetsArray *targets, const MissilesArray *missiles) {
	// projdeme vsechny terce
   // projdeme vsechny strely
     // spocitame vzdalenost stredu terce od strely pomoci Pythagorovy vety
     // zjistime, jestli je to v terci - tj. vzdalenost je mensi nebo rovna polomeru
  	// inkrementujeme pocet zasahu ve strukture Terce
}

bool save_score(const char *path, TargetsArray *targets) {
	// 1. otevreme soubor pro binarni zapis
 // 2. zkontrolujeme
 // 3. projdeme vsechny strely
 // 4. pokud je nenulovy pocet zasahu, tak ulozime index terce (1 `uint8_t`) + pocet zasahu (`uint32_t`)
}
</code></pre>
<ul>
<li>
<p>každý terč s <strong>nenulovým</strong> počtem zásahu bude uložen do souboru</p>
</li>
<li>
<p>index terče uložen jako <code>unsigned char</code></p>
</li>
<li>
<p>počet zásahů uložen jako <code>unsigned int</code></p>
<p><code>$ xxd -g 1 score.dat</code></p>
</li>
</ul>
</li>
</ol>
<div class="hex" style="margin-bottom: 95px">
 <span>00<span>1 unsigned bajt<br>index nultého terče</span></span>
 <span>02 00 00 00<span>unsigned int (uint32_t) v low endian<br>0x00000002 = 2<br>nultý terč má dva zásahy</span></span>
 <span>01<span>1 unsigned bajt<br>index prvního terče</span></span>
 <span>01 00 00 00<span>unsigned int (uint32_t) v low endian<br>0x00000001 = 1<br>první terč má jeden zásah</span></span>
</div>
<style>
    div.hex > p > span {
      position: relative;
      border: 1px solid black !important;
      cursor: pointer;
      font-family: monospace;
    }
    div.hex span span {
      font-family: arial;
      display: none;
      position: absolute;
      white-space: nowrap;
      background: white;
      padding: 3px;
    }
    div.hex span:hover span {
      display: block;
      left: 0;
      z-index: 5;
    }
 </style>
<h1><a class="header" href="#meme-generátor" id="meme-generátor">Meme generátor</a></h1>
<p>Vytvořme generátor meme obrázku dle instrukcí na standardním vstupu:</p>
<pre><code>blank.tga
meme.tga
2 2
I dont always do
memes
but when i do
i do them in C
</code></pre>
<img src="ulohy/meme.png">
<p>Možné kroky pro vytvoření generátoru:</p>
<ol>
<li>načíst <a href="ulohy//c/aplikovane_ulohy/tga.html">TGA obrázek</a> pozadí, uložit a otestovat správnost</li>
</ol>
<p>Jeden pixel obrázku budeme reprezentovat pomocí čtyř kanálu/bajtů: RGB + alfa průhlednost</p>
<ol start="2">
<li>
<p>načíst obrázek s jedním písmenkem a vložit jej na pozadí</p>
<p>Pro začátek zapisovat pixel písmenka pouze, pokud není průhledný (tj. alfa &gt; 0).</p>
</li>
<li>
<p>načíst si všechna písmenka do pole (interpunkci a jiné znaky neřešme)</p>
</li>
<li>
<p>vykreslit string do obrázku</p>
<img src="ulohy/memerect.png">
<p>Po vykreslení písmenka se musíme posunout v X o šírku písmene</p>
</li>
<li>
<p>načíst a zpracovat data ze vstupu (vstupní soubor/výstupní)</p>
<p>Jednotlivé řádky vstupu je vhodné získávat pomocí funkce <code>fgets</code>.
První řádek obsahuje cestu ke vstupnímu obrázku pozadí, druhý řádek je cesta k výstupnímu obrázku.
Následující řádek se dvěma čísly značí počet řádků ve vrchní a spodní části obrázku.</p>
</li>
<li>
<p>vykreslit více řádků do obrázku</p>
</li>
<li>
<p>Alfa blending</p>
<p>Výslednou barvu pixelu vypočítáme pro každou barevnou složku jako: 
$$ \text{RES} = \frac{\text{LETTER} \cdot \text{LETTER.ALFA} + \text{BG} \cdot (255 - \text{LETTER.ALFA})}{255} $$</p>
</li>
</ol>
<h1><a class="header" href="#sdl-1" id="sdl-1">SDL</a></h1>
<h1><a class="header" href="#had" id="had">Had</a></h1>
<p><a href="ulohy/snake/demo/a.html">Demo</a></p>
<ol>
<li>
<p>vykreslit mřížku s políčky o rozměrech 32x32</p>
<ul>
<li>nekreslit první dvě a poslední dvě políčka</li>
<li>do struktury <code>Game</code> přidat rozměry vnitřní mřížky</li>
<li>přesunout vykreslování do vlastní funkce</li>
</ul>
<img src="ulohy/snake/grid.png" width="400px">
</li>
<li>
<p>reprezentace a inicializace hada pomocí struktury <code>Snake</code></p>
<pre><code class="language-c">typedef struct {
   SDL_Point *parts; // pole souradnic clanku hada
   int tail; // index souradnice ocasu v poli parts
   int head; // index souradnice hlavy v poli parts
} Snake;
</code></pre>
<ul>
<li>
<p>pamatujeme si souřadnice (<code>SDL_Point</code>) všech aktivních článků hada v mřížce</p>
<ul>
<li>had může maximálně zabírat celou mřížku - alokace pole o velikosti ROWS x COLS</li>
<li>pamatujeme si index ocasu a index hlavy, které pak budeme posunovat pro pohyb</li>
</ul>
</li>
<li>
<p>vytvoříme hada o dvou článcích uprostřed mřížky</p>
<ul>
<li>uložíme souřadnici článku a inkrementujeme indexy hlavy</li>
<li>a ještě jednou pro ten druhý článek</li>
</ul>
<p><upr-snake></upr-snake></p>
</li>
</ul>
</li>
<li>
<p>vykreslení hada</p>
<ul>
<li>projdeme všechny články od ocasu k hlavě a vykreslíme jako čtverce v mřížce</li>
<li>nastavíme si <code>i = tail</code></li>
<li>cyklus dokud <code>i</code> není index hlavy
<ul>
<li>vykreslíme čtverec se souřadnici <code>i</code> v mřížce</li>
<li>posuneme se na další článek
<ul>
<li>pokud jsme na konci pole, tak pokračujeme od začátku pole <code>parts</code> (modulo...)</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="ulohy/snake/init.png" width="300px">
</li>
<li>
<p>pohybování hada</p>
<ul>
<li>pokud uběhlo 200 ms, tak pohnout hada o políčko</li>
<li>inkrementace indexu ocasu (opět s modulem)</li>
<li>výpočet nové hlavy jako <code>old_head + direction</code></li>
<li>uložení nové hlavy do pole parts na index hlavy</li>
<li>inkrementace indexu hlavy (opět s modulem)</li>
</ul>
</li>
<li>
<p>pohyb pomocí šípek</p>
</li>
<li>
<p>generování jablek</p>
<ul>
<li>vygenerovat náhodnou souřadnici jablka a vykreslovat jako čtverec</li>
<li>pokud se hlava dostane na pozici jablka, tak neposunovat index ocasu (dojde k zvětšeni hada)</li>
</ul>
</li>
<li>
<p>při nárazu do stěny či do sebe vypsat konec hry se skórem</p>
</li>
<li>
<p>vykreslení hada pomoci textur včetně záhybů</p>
<p>Textura obsahuje v mřížce políčka o velikosti 64x64. 
Jednotlivá políčka lze vybrat pomocí třetího parametru <code>srcrect</code> v <code>SDL_RenderCopy</code>.
Záhyb lze vybrat podle pozice předchozího a následujícího článku.</p>
<img src="https://rembound.com/files/creating-a-snake-game-tutorial-with-html5/snake-graphics.png" width="300px" />
</li>
</ol>
<h1><a class="header" href="#různé-1" id="různé-1">Různé</a></h1>
<h2><a class="header" href="#hádací-hra-guessing-game" id="hádací-hra-guessing-game">Hádací hra (<em>guessing game</em>)</a></h2>
<p>Vygenerujte <a href="ulohy/../ruzne/nahodna_cisla.html">náhodné číslo</a>. Poté nechte uživatele hádat, jaké číslo
program vygeneroval. Po každém tipu uživateli dejte vědět, jestli uhádl správně nebo jestli jeho
tip byl vyšší či nižší než číslo, které hádá.</p>
<h2><a class="header" href="#odrážející-se-kulička-v-terminálu" id="odrážející-se-kulička-v-terminálu">Odrážející se kulička v terminálu</a></h2>
<p>Vykreslujte do terminálu obdélník spolu s pohybující se kuličkou. Jakmile kulička narazí do stěny
čtverce, zvyšte počítadlo nárazů pro danou zeď. Dodržujte princip
<a href="https://cs.wikipedia.org/wiki/Odraz_vln%C4%9Bn%C3%AD">zákonu odrazu</a>.</p>
<details>
<summary>Přibližný postup řešení</summary>
Kuličku reprezentujte dvěmi proměnými (pozice X a Y). Opakovaně provádějte následující akce:
<ul>
<li>Posuňte kuličku ve směru jejího pohybu.</li>
<li>Pokud kulička narazí do stěny, změňte směr jejího pohybu.</li>
<li>Vyčistěte terminál, aby zmizelo herní pole z minulé iterace. Lze to provést více způsoby:
<ul>
<li>Vytiskněte velké množství prázdných řádků.</li>
<li>Vytiskněte text <code>&quot;\e[1;1H\e[2J&quot;</code>, který terminál bude interpretovat jako vyčistění obrazovky.</li>
</ul>
</li>
<li>Vykreslete kuličku a obdélník.</li>
<li>Uspěte na chvíli program, abyste mohli pozorovat změněný stav hry. Můžete použít například funkci
<code>usleep</code>: <code>usleep(100 * 1000)</code>.</li>
</ul>
</details>
<p>Výsledek by měl vypadat zhruba takto:</p>
<p><img src="ulohy/../static/video/ball_terminal.gif" alt="Odrážející se kulička v terminálu" /></p>
<h2><a class="header" href="#kalkulačka" id="kalkulačka">Kalkulačka</a></h2>
<p>Načtěte ze vstupu programu nebo z <a href="ulohy/../ruzne/funkce_main.html">parametrů příkazového řádku</a> matematický
výraz, který bude obsahovat celá čísla a operátory <code>+</code>, <code>-</code>, <code>/</code>, <code>*</code> a vypište výsledek tohoto
výrazu.</p>
<ul>
<li><em>Varianta 1</em>: Použijte klasický zápis v <a href="https://cs.wikipedia.org/wiki/Infixov%C3%A1_notace">infixové notaci</a>.
Nemusíte řešit prioritu operátorů.</li>
<li><em>Varianta 2</em>: Přidejte podporu pro prioritu operátorů a závorky <code>(</code>, <code>)</code>. Použijte algoritmus
<a href="https://cs.wikipedia.org/wiki/Algoritmus_shunting-yard">Shunting yard</a>.</li>
<li><em>Varianta 3</em>: Použijte <a href="https://cs.wikipedia.org/wiki/Postfixov%C3%A1_notace">postfixovou notaci</a>.
Zde bude fungovat priorita operátorů a &quot;závorkování&quot; bez nutnosti složitého načítání vstupu z
varianty 2.</li>
</ul>
<h2><a class="header" href="#tvorba-animace" id="tvorba-animace">Tvorba animace</a></h2>
<p>Pomocí knihovny pro práci s <a href="ulohy/../c/aplikovane_ulohy/gif.html">GIF animacemi</a> vytvořte nějakou zajímavou
animaci. Například se zkuste přiblížit této animaci z Matrixu:</p>
<p><img src="ulohy/../static/img/matrix-rain.gif" alt="" /> </p>
<h1><a class="header" href="#Časté-chyby" id="Časté-chyby">Časté chyby</a></h1>
<p>V této sekci naleznete často se vyskytující chyby, na které můžete narazit, spolu s návodem, jak je
vyřešit.</p>
<h3><a class="header" href="#záměna--a-" id="záměna--a-">Záměna <code>=</code> a <code>==</code></a></h3>
<ul>
<li>Operátor <code>=</code> <a href="caste_chyby/../c/promenne/promenne.html#z%C3%A1pis">přiřazuje</a> hodnotu do svého levého operandu a vyhodnotí se s
hodnotou pravého operandu.</li>
<li>Operátor <code>==</code> <a href="caste_chyby/../c/datove_typy/pravdivostni_typy.html#porovn%C3%A1v%C3%A1n%C3%AD-hodnot">porovnává</a> dvě hodnoty a vyhodnotí
se jako pravdivostní hodnota <code>bool</code>.</li>
</ul>
<p>Je důležité tyto operátory nezaměňovat! Oba dva operátory jsou výrazy, takže se v něco vyhodnotí a
i když je použijete špatně, tak často nedostanete chybovou hlášku, což jejich záměnu dělá ještě
nebezpečnější.</p>
<pre><code class="language-c">int a = 0;
a = 5; // nastaví hodnotu `5` do proměnné `a`
a == 5; // porovná `a` s hodnotou `5`, vrátí hodnotu `true`, ale nic se neprovede

// podmínka se provede, pokud se `a` rovná `5`
if (a == 5) {}

// podmínka se provede vždy, výraz `a = 5` se vyhodnotí na `5` (`true`)
// zároveň při provedení podmínky se přepíše hodnota proměnné `a` na `5`
if (a = 5) {}
</code></pre>
<h3><a class="header" href="#záměna--s--nebo--s-" id="záměna--s--nebo--s-">Záměna <code>&amp;</code> s <code>&amp;&amp;</code> nebo <code>|</code> s <code>||</code></a></h3>
<ul>
<li>Operátor <code>&amp;</code> provádí <a href="caste_chyby/../c/datove_typy/celociselne_typy.html#tabulka-aritmetick%C3%BDch-oper%C3%A1tor%C5%AF">bitový součin</a>,
očekává jako operandy celá čísla (např. <code>int</code>) a vrací celé číslo.</li>
<li>Operátor <code>&amp;&amp;</code> provádí <a href="caste_chyby/../c/datove_typy/pravdivostni_typy.html#tabulka-logick%C3%BDch-oper%C3%A1tor%C5%AF">logický součin</a>,
očekává jako operandy pravdivostní hodnoty (<code>bool</code>) a vrací pravdivostní hodnotu.</li>
</ul>
<p>Je důležité tyto operátory nezaměňovat. Jelikož <code>bool</code> lze implicitně převést na celé číslo a naopak,
záměna těchto operátorů opět typicky nepovede k chybě při překladu, nicméně program nejspíše při
jejich záměně nebude fungovat tak, jak má. Operátor <code>&amp;</code> má zároveň větší
<a href="https://en.cppreference.com/w/c/language/operator_precedence">přednost</a> než <code>&amp;&amp;</code>, takže se výraz
s tímto operátorem může vyhodnotit jinak, než očekáváte. Obdobná situace platí i u dvojice
operátorů <code>|</code> (bitový součet) a <code>||</code> (logický součet).</p>
<pre><code class="language-c">int a = 3;
a &amp; 4; // `0` 
a &amp;&amp; 4; // `true`

// stejné jako a &gt; (5 &amp; a) &lt; 6
if (a &gt; 5 &amp; a &lt; 6) {}
</code></pre>
<h3><a class="header" href="#použití-operátoru--pro-umocnění" id="použití-operátoru--pro-umocnění">Použití operátoru <code>^</code> pro umocnění</a></h3>
<p>Operátor <code>^</code> provádí v <em>C</em> bitovou operaci <a href="caste_chyby/../c/datove_typy/celociselne_typy.html#operace-s-%C4%8D%C3%ADseln%C3%BDmi-typy">XOR</a>,
nesnažte se jej tedy použít k výpočtu mocnin! Pro výpočet mocniny použijte funkci <a href="https://devdocs.io/c/numeric/math/pow"><code>pow</code></a>
(<em>power</em> je anglické označení pro mocninu).</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
    int a = 5 ^ 2;
    printf(&quot;%d\n&quot;, a);

    int b = pow(5, 2);
    printf(&quot;%d\n&quot;, b);

    return 0;
}
</code></pre>
<h3><a class="header" href="#použití-neexistujících-negací-operátorů-porovnávání" id="použití-neexistujících-negací-operátorů-porovnávání">Použití neexistujících negací operátorů porovnávání</a></h3>
<p>Jediné existující operátory porovnávání v <em>C</em> jsou <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code> a <code>!=</code>.
Operátory jako <code>!&lt;</code> nebo <code>!&gt;</code> neexistují! Negací operátoru <code>&lt;</code> je operátor <code>&gt;=</code> a negací operátoru
<code>&gt;</code> je operátor <code>&lt;=</code>.</p>
<h3><a class="header" href="#porovnávání-výrazu-s-více-hodnotami-najednou" id="porovnávání-výrazu-s-více-hodnotami-najednou">Porovnávání výrazu s více hodnotami najednou</a></h3>
<p>Pokud budete chtít zjistit, jestli např. nějaká proměnná je menší než jedna hodnota a zároveň větší
než jiná hodnota, musíte tyto dvě kontroly provést separátně a poté jejich výsledek spojit logickým
operátorem <code>&amp;&amp;</code>. Pokud použijete výraz jako např. <code>2 &lt; a &lt; 8</code>, tak se <code>2 &lt; a</code> vyhodnotí jako hodnota
typu <code>bool</code>, a poté se provede porovnání <code>true &lt; 8</code>, popřípadě <code>false &lt; 8</code>, což nejspíše není to, co
zamýšlíte.</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 100;

    // špatně
    if (2 &lt; a &lt; 8) {
        printf(&quot;A: a patri do intervalu (2, 8)\n&quot;);
    }

    // správně
    if (2 &lt; a &amp;&amp; a &lt; 8) {
        printf(&quot;B: a patri do intervalu (2, 8)\n&quot;);
    }

    return 0;
}
</code></pre>
<h3><a class="header" href="#středník-za-for-while-nebo-if" id="středník-za-for-while-nebo-if">Středník za <code>for</code>, <code>while</code> nebo <code>if</code></a></h3>
<p>Příkazy <code>for</code>, <code>while</code> nebo <code>if</code> za svou uzavírací závorkou <code>)</code> očekávají jeden příkaz:</p>
<pre><code class="language-c">if (a &gt; b) printf(&quot;%d&quot;, a);
</code></pre>
<p>nebo blok s příkazy:</p>
<pre><code class="language-c">if (a &gt; b) {
    printf(&quot;%d&quot;, a);
    ...
}
</code></pre>
<p>Pokud však za závorku dáte rovnou středník (<code>;</code>), tak to překladač pochopí jako prázdný příkaz, který
nic nedělá.</p>
<p>V následující ukázce se provede 10× prázdné tělo cyklu <code>for</code> a následně se jednou vypíše řetězec <code>&quot;Hello\n&quot;</code>.</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    for(int i = 0; i &lt; 10; i++); {
        printf(&quot;Hello\n&quot;);
    }
    return 0;
}
</code></pre>
<p>Zde opět středník za <code>if</code> reprezentuje prázdný příkaz, takže blok kódu s příkazem <code>printf</code> se provede
vždy, i když je tato podmínka nesplnitelná.</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    if(0); {
        printf(&quot;Hello\n&quot;);
    }

    return 0;
}
</code></pre>
<p>Je to ekvivalentní, jako byste napsali</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    if (0) { /* zde není co provést */ }

    // tento blok se provede vždy
    {
      printf(&quot;Hello\n&quot;);
    }

    return 0;
}
</code></pre>
<h3><a class="header" href="#Špatné-volání-funkce" id="Špatné-volání-funkce">Špatné volání funkce</a></h3>
<p>Abychom zavolali funkci (tj. řekli počítači, aby začal vykonávat kód, který v ní je), napíšeme
název funkce, závorky a do nich případně seznam argumentů. Při volání funkce už nezadáváme její
návratový typ, ten se udává pouze u definice funkce.</p>
<pre><code class="language-c">int secti(int a, int b) {
    return a + b;
}
int main() {
    secti(1, 2);        // správně
    int secti(1, 2);    // špatně

    return 0;
}
</code></pre>
<h3><a class="header" href="#záměna--s" id="záměna--s">Záměna <code>'</code> s <code>&quot;</code></a></h3>
<ul>
<li>Apostrof (<code>'</code>) slouží k zapsání (jednoho) <a href="caste_chyby/../c/text/znaky.html">znaku</a>. Neukládejte do něj více znaků či celý text.</li>
<li>Uvozovky (<code>&quot;</code>) slouží k zapsání <a href="caste_chyby/../c/text/text.html">řetězce</a>, tj. pole znaků ukončeného hodnotou <code>0</code>.</li>
</ul>
<pre><code class="language-c">char a = 'asd'; // špatně, více znaků v ''
char a = &quot;asd&quot;; // špatně, ukládáme řetězec do typu `char` (mělo by být `const char*`)

char a = 'x';               // správně
const char* str = &quot;hello&quot;;  // správně
</code></pre>
<h3><a class="header" href="#Špatná-práce-s-ukazatelem" id="Špatná-práce-s-ukazatelem">Špatná práce s ukazatelem</a></h3>
<p><a href="caste_chyby/../c/prace_s_pameti/ukazatele.html">Ukazatele</a> jsou čísla, která interpretujeme jako
<a href="caste_chyby/../uvod/pamet.html">adresy v paměti</a>. Můžete s nimi sice provádět některé aritmetické operace
(například sčítání či odčítání), nicméně v takovém případě provádíte výpočet s adresou, ne s
hodnotou, která je na dané adrese uložena.</p>
<p>Například v této funkci, která by měla přičíst hodnotu <code>x</code> k paměti na adrese <code>ptr</code>, musíte
nejprve přistoupit k hodnotě na dané adrese (<code>*ptr</code>), a až k této hodnotě pak přičíst <code>x</code>:</p>
<pre><code class="language-c">void pricti_hodnotu(int* ptr, int x) {
    ptr += x;   // špatně, přičteme `x` k adrese `ptr`
    *ptr += x;  // správně, přičteme `x` k hodnotě na adrese `ptr` 
}
</code></pre>
<h3><a class="header" href="#vytváření-spousty-proměnných-místo-použití-pole" id="vytváření-spousty-proměnných-místo-použití-pole">Vytváření spousty proměnných místo použití pole</a></h3>
<p>Pokud potřebujete jednotně pracovat s větším počtem hodnot v paměti, použijte <a href="caste_chyby/../c/pole/pole.html">pole</a>.
Signálem, že jste měli použít pole, může být to, že máte ve funkci spoustu proměnných a pro rozlišení
každé proměnné musíte přidat nový řádek kódu:</p>
<pre><code class="language-c">for (a0 = 0, a1 = 0, a2 = 0, a3 = 0, a4 = 0, a5 = 0; i &lt; pocet; i++)
{
    if (hodnota == 1)
    {
        a0++;
    }
    else if (hodnota == 2)
    {
        a1++;
    }
    else if (hodnota == 3)
    {
        a2++;
    }
    ...
}
</code></pre>
<h3><a class="header" href="#undefined-reference-to-nazev" id="undefined-reference-to-nazev"><code>undefined reference to 'NAZEV'</code></a></h3>
<p>Snažíte se zavolat funkci <code>NAZEV</code>, která nebyla nalezena v žádném
<a href="caste_chyby/../c/modularizace/linker.html">objektovém souboru</a>, který jste předali pro překlad. Ověřte si, že
máte název volané funkce správně.</p>
<h1><a class="header" href="#paměťové-chyby" id="paměťové-chyby">Paměťové chyby</a></h1>
<p>V <em>C</em> lze s pamětí programu pracovat <a href="caste_chyby/../c/prace_s_pameti/dynamicka_pamet.html">manuálně</a>, což velmi často vede
k různým paměťovým chybám, které můžou způsobit špatné chování či pád programu. Jsou také
nejčastějším zdrojem různých
<a href="https://owasp.org/www-community/attacks/Buffer_overflow_attack">zranitelností</a>, které umožňují
útočníkům převzít kontrolu nad programem nebo celým počítačem.</p>
<p>Pro částečnou prevenci paměťových chyb silně doporučujeme při vývoji <em>C</em> programů používat
nástroj <a href="caste_chyby/../prostredi/ladeni.html#address-sanitizer">Address sanitizer</a>.</p>
<h2><a class="header" href="#stack-overflow" id="stack-overflow">Stack overflow</a></h2>
<p>Pokud bychom vytvořili v zásobníkovém rámci moc proměnných, proměnné, které jsou
<a href="caste_chyby/../c/pole/pole.html">moc velké</a>, anebo bychom měli v jednu chvíli aktivních moc zásobníkových rámců
(například při moc hluboké <a href="caste_chyby/../c/funkce/rekurze.html">rekurzi</a>), tak může dojít paměť určená pro zásobník.
Tato situce se nazývá <strong>přetečení zásobníku</strong> (<em>stack overflow</em>):</p>
<pre><code class="language-c">int funkce(int x) {
    return funkce(x + 1);
}
int main() {
    funkce(0);
    return 0;
}
</code></pre>
<h2><a class="header" href="#segmentation-fault" id="segmentation-fault">Segmentation fault</a></h2>
<p>Tato chyba je způsobena pokusem o zapsání nebo čtení neplatné adresy v paměti. K této chybě často
dochází zejména při těchto situacích:</p>
<ul>
<li>
<p>Zapísujeme nebo čteme z paměti pole mimo jeho rozsah (tj. &quot;před&quot; nebo &quot;za&quot; pamětí pole).
Tato situace se nazývá <a href="https://owasp.org/www-community/vulnerabilities/Buffer_Overflow"><em>buffer overflow</em></a>.
Tato chyba už způsobila nespočet bezpečnostních chyb v různých softwarech.</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

int main() {
    int* p = (int*) malloc(sizeof(int));
    p[1] = 5;
    return 0;
}
</code></pre>
</li>
<li>
<p>Pokoušíme se přečíst hodnotu na adrese 0 (<code>NULL</code>), která je používána pro inicializaci
ukazatelů. Tato situace se nazývá
<a href="https://owasp.org/www-community/vulnerabilities/Null_Dereference"><em>null pointer dereference</em></a>.</p>
<pre><code class="language-c">int main() {
    int* p = (void*) 0;
    int a = *p;

    return 0;
}
</code></pre>
</li>
<li>
<p>Snažíme se přistoupit k paměti, která již byla <a href="caste_chyby/../c/prace_s_pameti/dynamicka_pamet.html#uvoln%C4%9Bn%C3%AD-pam%C4%9Bti">uvolněna</a>.
Tato situace se nazývá
<a href="https://owasp.org/www-community/vulnerabilities/Using_freed_memory"><em>use-after-free</em></a>.</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

int main() {
    int* p = (int*) malloc(sizeof(int));
    free(p);

    *p = 1;
    return 0;
}
</code></pre>
<p>Přístup k již uvolněné paměti může nastat i bez použití
<a href="caste_chyby/../c/prace_s_pameti/dynamicka_pamet.html">dynamické paměti</a>. Například tento kód není správně:</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

int* vrat_ukazatel(int x) {
    int y = x + 1;
    return &amp;y;
}

int main() {
    int* p = vrat_ukazatel(1);
    *p = 1;
    return 0;
}
</code></pre>
<p>Jakmile totiž vykonávání funkce <code>vrat_ukazatel</code> skončí, tak se
<a href="caste_chyby/../c/prace_s_pameti/automaticka_pamet.html">uvolní</a> paměť jejich lokálních proměnných. Adresa
uložená v <code>p</code> tak obsahuje nevalidní paměť a je chybou k ní přistupovat (ať už číst, tak
zapisovat).</p>
</li>
<li>
<p>Snažíme se uvolnit pamět, která již byla uvolněna. Tato situace se nazývá
<a href="https://owasp.org/www-community/vulnerabilities/Doubly_freeing_memory"><em>double free</em></a>.</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

int main() {
    int* p = (int*) malloc(sizeof(int));
    free(p);
    free(p);
    return 0;
}
</code></pre>
</li>
</ul>
<blockquote>
<p>Zkuste si programy výše spustit nejprve bez Address sanitizeru a poté s ním. Dokázal sanitizer
detekovat některé z popsaných paměťových chyb?</p>
</blockquote>
<h2><a class="header" href="#memory-leak" id="memory-leak">Memory leak</a></h2>
<p>Pokud (opakovaně) alokujeme <a href="caste_chyby/../c/prace_s_pameti/dynamicka_pamet.html">dynamickou paměť</a> a neuvolňujeme ji, tak
dochází k tzv. <a href="https://owasp.org/www-community/vulnerabilities/Memory_leak"><em>memory leaku</em></a>
(úniku paměti). Pokud paměť programu stále roste a není nijak uvolňována, tak postupem času počítači
nutně dojde paměť a program tak bude násilně ukončen.</p>
<pre><code class="language-c">void leak() {
    // adresa alokované paměti je zahozena, nelze ji tedy uvolnit
    malloc(sizeof(int));
}
</code></pre>
<p>Tato chyba je celkem zákeřná, protože pokud paměť roste pomalu, tak může trvat dost dlouho, než
paměť programu dojde a vy se tak dozvíte o problému. K nalezení chyby doporučujeme opět použít Address
sanitizer, který na konci programu zkontroluje, jestli všechny dynamicky naalokované bloky byly
korektně uvolněny.</p>
<blockquote>
<p>Nemusíte se však bát, že by neuvolněná paměť ve vašem programu nějak narušovala chod operačního
systému. I když paměť manuálně neuvolníte, tak moderní operační systémy veškerou paměť vašeho
spuštěného programu uvolní, jakmile program skončí. Dokud však program běží, tak bude neuvolněná
paměť zabírat místo, což může způsobovat problémy.</p>
</blockquote>
<h1><a class="header" href="#galerie-projektů" id="galerie-projektů">Galerie projektů</a></h1>
<p>Zde naleznete vybrané projekty od studentů minulých ročníků <code>UPR</code>:</p>
<ul>
<li><a href="galerie_projektu/2020.html">Ročník 2020/2021</a></li>
</ul>
<h1><a class="header" href="#galerie-projektů-20202021" id="galerie-projektů-20202021">Galerie projektů 2020/2021</a></h1>
<p>Galerie vybraných projektů od studentů z ročníku <code>2020/2021</code>.</p>
<h2><a class="header" href="#fruit-ninja" id="fruit-ninja">Fruit Ninja</a></h2>
<p><a href="galerie_projektu/../c/aplikovane_ulohy/sdl.html">SDL</a> + <a href="galerie_projektu/../c/aplikovane_ulohy/chipmunk.html">Chipmunk</a></p>
<p><video width="500" src="../static/projekty_2020/projekt1.webm" controls></video></p>
<h2><a class="header" href="#angry-birds" id="angry-birds">Angry Birds</a></h2>
<p><a href="galerie_projektu/../c/aplikovane_ulohy/sdl.html">SDL</a> + <a href="galerie_projektu/../c/aplikovane_ulohy/chipmunk.html">Chipmunk</a></p>
<p><video width="500" src="../static/projekty_2020/projekt2.webm" controls></video></p>
<h2><a class="header" href="#pacman" id="pacman">PacMan</a></h2>
<p><a href="galerie_projektu/../c/aplikovane_ulohy/sdl.html">SDL</a></p>
<p><video width="500" src="../static/projekty_2020/projekt3.webm" controls></video></p>
<h2><a class="header" href="#space-invaders" id="space-invaders">Space Invaders</a></h2>
<p><a href="galerie_projektu/../c/aplikovane_ulohy/sdl.html">SDL</a></p>
<p><video width="500" src="../static/projekty_2020/projekt4.webm" controls></video></p>
<h2><a class="header" href="#tetris" id="tetris">Tetris</a></h2>
<p><a href="galerie_projektu/../c/aplikovane_ulohy/sdl.html">SDL</a></p>
<p><video width="500" src="../static/projekty_2020/projekt5.webm" controls></video></p>
<p><video width="500" src="../static/projekty_2020/projekt6.webm" controls></video></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-177556287-1', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="theme/mode-c_cpp.min.js"></script>
        
        <script type="text/javascript" src="theme/asciinema-player.js"></script>
        
        <script type="text/javascript" src="src/wasm/xterm.min.js"></script>
        
        <script type="text/javascript" src="src/wasm/fit.min.js"></script>
        
        <script type="text/javascript" src="src/wasm/shared.js"></script>
        
        <script type="text/javascript" src="src/wasm/web.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
